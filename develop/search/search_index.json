{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Installation Direct <script> include via CDN In case you're not using any JS bundling/compilation technique, the SDK can also be loaded with the traditional <script> tag, as follows: Latest SDK version < script src = \"https://unpkg.com/@aeternity/aepp-sdk/dist/aepp-sdk.browser-script.js\" ></ script > Specific SDK version < script src = \"https://unpkg.com/@aeternity/aepp-sdk@VERSION/dist/aepp-sdk.browser-script.js\" ></ script > ...where VERSION is the version number of the SDK you want to use (eg. 8.1.0 ). Browser <script> tag The bundle will assign the SDK to a global variable called Ae that makes all functionalities of the SDK accessible. Usage: <!doctype html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > </ head > < body > <!-- include latest SDK version --> < script src = \"https://unpkg.com/@aeternity/aepp-sdk/dist/aepp-sdk.browser-script.js\" ></ script > < script type = \"text/javascript\" > Ae . Node ({ url : 'https://testnet.aeternity.io' }). then ( node => { Ae . Universal ({ nodes : [{ name : 'testnet' , instance : node }] }). then ( aeInstance => { aeInstance . height (). then ( height => { console . log ( \"Current Block Height:\" + height ) }) }) }) </ script > </ body > </ html > NPM Latest Release npm i @aeternity/aepp-sdk Pre Release To install a Pre-Release (latest beta or alpha version) you have to install the package appending the @next tag reference. npm i @aeternity/aepp-sdk@next Specific Github Branch You can also install a version coming from a specific branch. In this case you would install the SDK version of the develop branch. npm i github:aeternity/aepp-sdk-js#develop Note : If you experience errors during the installation, you might need to install build tools for your OS. Windows: Windows Build Tools npm install -g windows-build-tools Ubuntu / Debian: Build Essential sudo apt-get update sudo apt-get install build-essential Mac Download Xcode from AppStore, then run xcode-select --install Command Line Interface (CLI) If you don't need to include specific functionality into your application and just want to use or play around with features the SDK provides you can make use of the \ud83d\udcbb CLI and follow the instructions mentioned there.","title":"Installation"},{"location":"#installation","text":"","title":"Installation"},{"location":"#direct-script-include-via-cdn","text":"In case you're not using any JS bundling/compilation technique, the SDK can also be loaded with the traditional <script> tag, as follows:","title":"Direct &lt;script&gt; include via CDN"},{"location":"#latest-sdk-version","text":"< script src = \"https://unpkg.com/@aeternity/aepp-sdk/dist/aepp-sdk.browser-script.js\" ></ script >","title":"Latest SDK version"},{"location":"#specific-sdk-version","text":"< script src = \"https://unpkg.com/@aeternity/aepp-sdk@VERSION/dist/aepp-sdk.browser-script.js\" ></ script > ...where VERSION is the version number of the SDK you want to use (eg. 8.1.0 ).","title":"Specific SDK version"},{"location":"#browser-script-tag","text":"The bundle will assign the SDK to a global variable called Ae that makes all functionalities of the SDK accessible. Usage: <!doctype html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > </ head > < body > <!-- include latest SDK version --> < script src = \"https://unpkg.com/@aeternity/aepp-sdk/dist/aepp-sdk.browser-script.js\" ></ script > < script type = \"text/javascript\" > Ae . Node ({ url : 'https://testnet.aeternity.io' }). then ( node => { Ae . Universal ({ nodes : [{ name : 'testnet' , instance : node }] }). then ( aeInstance => { aeInstance . height (). then ( height => { console . log ( \"Current Block Height:\" + height ) }) }) }) </ script > </ body > </ html >","title":"Browser &lt;script&gt; tag"},{"location":"#npm","text":"","title":"NPM"},{"location":"#latest-release","text":"npm i @aeternity/aepp-sdk","title":"Latest Release"},{"location":"#pre-release","text":"To install a Pre-Release (latest beta or alpha version) you have to install the package appending the @next tag reference. npm i @aeternity/aepp-sdk@next","title":"Pre Release"},{"location":"#specific-github-branch","text":"You can also install a version coming from a specific branch. In this case you would install the SDK version of the develop branch. npm i github:aeternity/aepp-sdk-js#develop Note : If you experience errors during the installation, you might need to install build tools for your OS. Windows: Windows Build Tools npm install -g windows-build-tools Ubuntu / Debian: Build Essential sudo apt-get update sudo apt-get install build-essential Mac Download Xcode from AppStore, then run xcode-select --install","title":"Specific Github Branch"},{"location":"#command-line-interface-cli","text":"If you don't need to include specific functionality into your application and just want to use or play around with features the SDK provides you can make use of the \ud83d\udcbb CLI and follow the instructions mentioned there.","title":"Command Line Interface (CLI)"},{"location":"CHANGELOG/","text":"Changelog All notable changes to this project will be documented in this file. See standard-version for commit guidelines. 11.0.1 (2022-04-07) Bug Fixes contract: do not check payable if contract call is init ( c09fc0c ) importing in mjs ( 01d493b ) oracle: do not include address for oracle respond signature ( ad4bddc ) 11.0.0 (2022-03-18) Request batching: SDK now supports batching transactions Custom error types: Introduced error types Naming convention: Instances of the SDK in the examples and tests are now called as aeSdk . \u26a0 BREAKING CHANGES return empty array instead of throwing UnsignedTxError rpc: remove forceValidation flag hd-wallet: expect that bip39 used externally hd-wallet: remove default export crypto: make (encode/decode)Base(58/64)Check private use bs58 instead of bs58check update rlp to 3.0.0 tx builder: throw exception if deposit is not zero tx schema: remove default NAME_FEE equal to 0 tx builder: accept unencoded name in nameClaimTx spelling of GeneralizedAccount aci: remove call/callStatic from deployInfo aci: remove createdAt property generated at client contract: remove deprecated contractCallStatic contract: remove deprecated contractDeploy contract: remove contractCompile contract: remove deprecated contractCall remove deprecated topBlock remove unused functions contract events: remote contract support contract instance: store aci as it is wallet-rpc: inline resolveOnAccount helper aepp-wallet schema: convert to TS aepp-wallet schema: rearrange METHODS enum aepp-wallet schema: remove unused enums contractCompile: remove encodeCall compiler: remove contractEncodeCallDataAPI compiler: remove getCompilerVersion contract: remove compileContractAPI contract: remove contractGetACI contract: remove contractDecodeCallDataByCodeAPI contract: remove contractDecodeCallDataBySourceAPI contract: remove contractDecodeCallResultAPI compiler: remove validateByteCodeAPI compiler: remove getFateAssembler compiler: remove getBytecodeCompilerVersion poll: avoid extra transaction info request to node drop https scheme workaround for hosted compiler node: don't wrap internal endpoints if internalUrl missed tx builder: inline VALIDATION_MESSAGE decodeEvents: accept event schemas as it is in ACI contract: remove already processed fields from decoded events aci: drop redundant per-method event decoding Features aci: use dry-run to estimate gas and get rich errors ( bb6977d ) calculate default polling intervals depending on node settings ( d9c6cf9 ) chain: combine multiple dry-run requests at one ( ddcdaef ) contract events: ability to resolve multiple definitions of event ( c5b77fa ) contract events: remote contract support ( c7599c7 ) createGeneralizeAccount: estimate gas limit instead of using const ( da88852 ) decode encode: validate base58 prefix and payload length ( e836260 ) error: introduce error types ( #1345 ) ( 444bb33 ) package: build es version compatible with node ( 480c747 ) poll: use getCheckTxInPool if available ( 690db5b ) swagger: converts operationId in snake case to pascal ( e52b739 ) swagger: split transactions by queues to post batch of txs from one account ( 0023fc7 ) tx builder: accept unencoded name in nameClaimTx ( eea92be ) tx builder: don't require produceNameId to create AENS txs ( 57ef9c7 ) tx builder: provide default name fee ( 18e4bab ) validator: check contractId ( 5e667a5 ) wallet: add switch for aepp wallet node sharing ( b5640d6 ) wallet: enable aepp to wallet node connection ( d87e1fa ) wallet: provide switch for aepp wallet node connection ( dfbab59 ) Bug Fixes aens helpers: improve naming, add additional validations ( d2a10e1 ) babel: compatibility with create-react-app ( e4b56fe ) babel: depend on buffer package in es build ( 0ba51e9 ) babel: don't rewrite import of rlp package for @vue/cli@4.5.15 ( 0fdd296 ) chain: don't require address function to post transaction ( 07bc105 ) channel force progress: add missed binary prefixes ( 78660d2 ) channel: ignore messages that can't be handled, print to console ( aaad8e3 ) compatibility: update argon2-browser to version with default export ( 0e69d8b ) compatibility: use blakejs that doesn't refer to Buffer ( 94f1879 ) contract events: don't throw error if events emitted by remote ( fa1c569 ) delegate signature: don't encode address depending on onAccount ( 563a972 ) dry-run: don't combine requests by default ( 0f36efc ) error: remove duplicate error message ( 8b4df9a ) es: babel build on windows ( 30f5213 ) keystore: encoding of hex privateKey, simplify tests ( 9f3ad6b ) spelling of GeneralizedAccount ( 21c1dd3 ) tx builder: reject more than 32 pointers ( 9c06dab ) tx builder: throw exception if deposit is not zero ( 7b3d0e3 ) aci: drop redundant per-method event decoding ( a84d781 ) aci: remove call/callStatic from deployInfo ( 84d082d ) aci: remove createdAt property generated at client ( 406684c ) aepp-wallet schema: convert to TS ( 1775e91 ) aepp-wallet schema: rearrange METHODS enum ( 8a40105 ) aepp-wallet schema: remove unused enums ( 95bf0e9 ) compiler: remove contractEncodeCallDataAPI ( 7d02317 ) compiler: remove getBytecodeCompilerVersion ( 13283be ) compiler: remove getCompilerVersion ( fb929f8 ) compiler: remove getFateAssembler ( 165d492 ) compiler: remove validateByteCodeAPI ( 90ba164 ) contract instance: store aci as it is ( 978225e ) contractCompile: remove encodeCall ( 6d0ade5 ) contract: remove already processed fields from decoded events ( 45bae5f ) contract: remove compileContractAPI ( 5ae9c62 ) contract: remove contractCompile ( 7390629 ) contract: remove contractDecodeCallDataByCodeAPI ( 2fe798a ) contract: remove contractDecodeCallDataBySourceAPI ( 8b13f70 ) contract: remove contractDecodeCallResultAPI ( b9fbfa6 ) contract: remove contractGetACI ( 23ada71 ) contract: remove deprecated contractCall ( c079e6e ) contract: remove deprecated contractCallStatic ( 1e3ac6d ) contract: remove deprecated contractDeploy ( 08e423e ) crypto: make (encode/decode)Base(58/64)Check private ( c151183 ) decodeEvents: accept event schemas as it is in ACI ( 17b9cc4 ) drop https scheme workaround for hosted compiler ( 9fc0a02 ) hd-wallet: expect that bip39 used externally ( f6243ad ) hd-wallet: remove default export ( 951ebb2 ) node: don't wrap internal endpoints if internalUrl missed ( 50d7bba ) poll: avoid extra transaction info request to node ( 22c4838 ) remove deprecated topBlock ( 4535c07 ) remove unused functions ( 8c00de5 ) return empty array instead of throwing UnsignedTxError ( c6bacdf ) rpc: remove forceValidation flag ( 9f958c3 ) tx builder: inline VALIDATION_MESSAGE ( defb7e1 ) tx schema: remove default NAME_FEE equal to 0 ( 9d8339a ) update rlp to 3.0.0 ( bb32b77 ) use bs58 instead of bs58check ( 32e836b ) wallet-rpc: inline resolveOnAccount helper ( 1277b5b ) 10.0.0 (2021-12-07) \u26a0 BREAKING CHANGES crypto: remove unused asymmetric encode/decode functions aens: don't limit pointer keys specify browserlist to better choice of features to transpile aci: don't require source code make contractDeploy a wrapper, remove unused code inline getConsensusProtocolVersion function invert and rename forceCodeCheck option to validateByteCode require compiler 6 and above make contractCall/Static a wrapper around getContractInstance contract instance: thread all extra options as contract's contract instance: remove unnecessary setOptions function remove contractDecodeData as extra wrapper remove contractEncodeCall as extra wrapper don't accept ak_ addresses as hash, bytes and signature transformation: drop extra wrapper around bindings transformation: don't export extra functions drop unnecessary skipTransformDecoded option drop unnecessary skipArgsConvert option Features aci: don't require source code ( 5c690d2 ) aens: don't limit pointer keys ( f6b8999 ) aens: enable commitmentHash preclaim in tests ( 5de05e5 ) decode using calldata package ( 2bb494d ) encode using calldata package ( eeebbd5 ) poll-interval: reduce poll interval to be a more sensible default ( 9e55b2b ) support for new node feature next-nonce of release 6.2.0 ( #1299 ) ( e40b046 ) Bug Fixes commitlint issue ( 2c1cf54 ) compiler errors: construct error message by server response ( 8621352 ) don't accept ak_ addresses as hash, bytes and signature ( cbaac62 ) events: don't require function name for events decoding ( f963bdb ) events: fix event decoding order and address prefix ( faad530 ) events: fix test for incorrect address return type ( 31aaeec ) events: ignore unknown events in decoding ( 45795fa ) node errors: construct error message by server response ( d556936 ) semverSatisfies: ignore build number ( c3cce0a ) swagger: detection of empty response ( 9bfab02 ) contract instance: remove unnecessary setOptions function ( b88e767 ) contract instance: thread all extra options as contract's ( 10fb7ba ) crypto: remove unused asymmetric encode/decode functions ( 51def34 ) drop unnecessary skipArgsConvert option ( 6d4a599 ) drop unnecessary skipTransformDecoded option ( bb49239 ) inline getConsensusProtocolVersion function ( 75f0447 ) invert and rename forceCodeCheck option to validateByteCode ( 72122fa ) make contractCall/Static a wrapper around getContractInstance ( c4ec019 ) make contractDeploy a wrapper, remove unused code ( 48d36f9 ) remove contractDecodeData as extra wrapper ( 5df2285 ) remove contractEncodeCall as extra wrapper ( a4b303f ) require compiler 6 and above ( f9cef12 ) specify browserlist to better choice of features to transpile ( c2ec71a ) transformation: don't export extra functions ( fa38b40 ) transformation: drop extra wrapper around bindings ( 9b70f8e ) 10.0.0-beta.1 (2021-11-24) \u26a0 BREAKING CHANGES specify browserlist to better choice of features to transpile aci: don't require source code make contractDeploy a wrapper, remove unused code inline getConsensusProtocolVersion function invert and rename forceCodeCheck option to validateByteCode require compiler 6 and above make contractCall/Static a wrapper around getContractInstance contract instance: thread all extra options as contract's contract instance: remove unnecessary setOptions function remove contractDecodeData as extra wrapper remove contractEncodeCall as extra wrapper don't accept ak_ addresses as hash, bytes and signature transformation: drop extra wrapper around bindings transformation: don't export extra functions drop unnecessary skipTransformDecoded option drop unnecessary skipArgsConvert option Features aci: don't require source code ( 5c690d2 ) decode using calldata package ( 2bb494d ) encode using calldata package ( eeebbd5 ) poll-interval: reduce poll interval to be a more sensible default ( 9e55b2b ) support for new node feature next-nonce of release 6.2.0 ( #1299 ) ( e40b046 ) aens: enable commitmentHash preclaim in tests ( 5de05e5 ) Bug Fixes compiler errors: construct error message by server response ( 8621352 ) events: fix event decoding order and address prefix ( faad530 ) events: fix test for incorrect address return type ( 31aaeec ) node errors: construct error message by server response ( d556936 ) semverSatisfies: ignore build number ( c3cce0a ) commitlint issue ( 2c1cf54 ) don't accept ak_ addresses as hash, bytes and signature ( cbaac62 ) drop unnecessary skipArgsConvert option ( 6d4a599 ) drop unnecessary skipTransformDecoded option ( bb49239 ) inline getConsensusProtocolVersion function ( 75f0447 ) invert and rename forceCodeCheck option to validateByteCode ( 72122fa ) make contractCall/Static a wrapper around getContractInstance ( c4ec019 ) make contractDeploy a wrapper, remove unused code ( 48d36f9 ) remove contractDecodeData as extra wrapper ( 5df2285 ) require compiler 6 and above ( f9cef12 ) specify browserlist to better choice of features to transpile ( c2ec71a ) contract instance: remove unnecessary setOptions function ( b88e767 ) contract instance: thread all extra options as contract's ( 10fb7ba ) remove contractEncodeCall as extra wrapper ( a4b303f ) transformation: don't export extra functions ( fa38b40 ) transformation: drop extra wrapper around bindings ( 9b70f8e ) 9.0.1 (2021-10-04) Refactoring Remove channel from universal stamp ( 63e88ce74 ) 9.0.0 (2021-09-30) \u26a0 BREAKING CHANGES drop following AENS delegation signature methods over the new common createAensDelegationSignature implementation which accepts an object as param ( 456fe00 ) delegateNamePreclaimSignature delegateNameClaimSignature delegateNameTransferSignature delegateNameRevokeSignature drop following oracle delegation signature methods over the new common createOracleDelegationSignature implementation accepts an object param ( 88b7bf3 ) delegateOracleRegisterSignature delegateOracleExtendSignature delegateOracleRespondSignature drop assertedType , use decode instead ( 00d563f ) drop waitMined static method ( 2f299de ) tx-validator now gives different, more meaningful, errors ( 95a2a23 ) no longer exports buildHash function, use hash or buildTxHash ( 9e1fde7 ) tx-verification is now done by default ( 989b36f ) Features payForTransaction method ( fbf204d ) don't check is GA if innerTx ( 0ee9db4 ) don't sent to blockchain if innerTx ( 523e9bb ) deposit-trap: enforce zero value for deposit during contract deploy ( cfb5f22 ) Maintenance change default gas limit to 25000 ( 831e4dd ) Bug Fixes AENS: name length minimum bid fee ( db6ca4c ) delegate-signature: stop using the default account in the context of signing ( 29d760e ) mustAccountStamp: process accounts only if supplied ( 10ec2c3 ) swagger https issue ( 3a876bb ) tx serialisation: accept unpackTx output produced by deserialisator ( ff0b3f5 ) 8.2.1 (2021-06-21) Bug Fixes swagger file of aeternity's compiler ( 4001e64 ) swagger file of aeternity's latest compiler ( a1caa03 ) 8.2.0 (2021-06-17) \u26a0 BREAKING CHANGES crypto: remove outdated generateSaveWallet function crypto: remove unused prepareTx, encodeTx, decodeTx functions crypto: remove unused hexStringToByte function crypto: rename messageToBinary to messageToHash adding hashing crypto: drop extra \"personal\" from message functions crypto: remove unused formatAddress function crypto: remove unused addressToHex function node-pool: inline helpers, export by default string: use isAddressValid instead of isAeAddress string: remove unused snakeOrKebabToPascal function drop outdated protocols and transactions schemas drop compatibility with node@5 Bug Fixes export aepp-wallet-communication ( d5d741c ) ponyfill Buffer in browser ( 953bf08 ) ponyfill process in browser ( 798ab63 ) rlp: import as it is ( 736b0f5 ) typo name of broadcast failed error generator ( ae7e823 ) examlple-aepp: open only when ready to accept connection ( 4872eb9 ) crypto: drop extra \"personal\" from message functions ( 34288cb ) crypto: remove outdated generateSaveWallet function ( 37298be ) crypto: remove unused addressToHex function ( 93f9def ) crypto: remove unused formatAddress function ( a5d4b62 ) crypto: remove unused hexStringToByte function ( ed39a76 ) crypto: remove unused prepareTx, encodeTx, decodeTx functions ( 64d15eb ) crypto: rename messageToBinary to messageToHash adding hashing ( df37004 ) node-pool: inline helpers, export by default ( ed1cfb5 ) string: remove unused snakeOrKebabToPascal function ( 79bdc04 ) string: use isAddressValid instead of isAeAddress ( ac7d827 ) drop compatibility with node@5 ( f5e2fdb ) drop outdated protocols and transactions schemas ( f18d305 ) 8.1.0 (2021-05-31) Bug Fixes poi-tx schema: use proper type name ( 9e7c7b2 ) wait-for-tx-confirm: validate transaction height after awaitHeight ( 95e0d93 ) Features support compiler@6.0.0 and above ( 3cdc7f9 ) 8.0.0 (2021-05-18) Bug Fixes avoid instanceof between possible not/polyfilled objects ( 906ee0e ) 8.0.0-beta.2 (2021-05-12) Bug Fixes revert conversion of case in calls to compiler ( 0a69e49 ) Maintenance avoid ts definitions based on broken JsDoc ( 572d19f ) 8.0.0-beta.1 (2021-05-6) Important changes Iris compatibility (compatible with nodes >= 5.2.0 < 7.0.0) initial TypeScript support (not enough type definitions yet) documentation is generated using MkDocs on Travis BREAKING CHANGES Drop old aepp-wallet RPC interface ( 254f5a93 ) refactor: don't retrieve account from process.env ( 59e5c9b5 ) refactor(crypto): don't reexport RLP methods ( c6004bc7 ) refactoring: remove legacy contractDecodeDataAPI compiler method ( dfadac8d ) refactor: rename forceCompatibility to more clear ignoreVersion ( 72f1d326 ) refactoring: require compiler above or equal to 4.1.0 ( c9f48f91 ) RpcClient: Drop unnecessary action stuff ( 84545fd7 ) Combine RpcWallet and RpcClients ( 12892002 ) Drop old names support, split ensureNameValid and isNameValid ( 315a78a9 ) refactor(contract-aci): export single function instead of stamp ( 091b3282 ) Combine Accounts and Selector into AccountMultiple ( 0cacd3b3 ) Use swagger-client instead of a custom implementation ( 4b3260d5 ) Remove OracleNodeAPI wrapper ( c6f9a76d ) Flatten options of contractCallStatic, remove extra dryRunContractTx ( f3ffb664 ) txDryRun: Simplify arguments, support txEvents option ( 401c53da ) contracts: Mark handleCallError as private, simplify arguments ( bdf76e24 ) import/no-named-as-default linter error ( d63e1511 ) oracle: make pollForQueries a sync function ( dc955e14 ) chore: drop aevm support and backend (compiler) option ( 6eb702dd ) refactor(schema): export enum with consensus protocol versions ( e92f187d ) Features swagger: allow to provide external specification ( 683082b3 ) swagger: make compatible with OpenAPI 3 ( 1d83f1a4 ) switch to v3 endpoints on Iris ( eca6697b ) traverse-keys: add keysOfValuesToIgnore option as a workaround ( 8ff5afe4 ) Use es modules version in browser if supported ( b49c38f0 ) Add typescript support ( abde033a ) Docs contract: fix default backend value ( 9fcbeb32 ) wallet-iframe: fix disconnect button ( 59014bd0 ) examples-browser: rearrange files and docs ( 985e3b96 ) use relative links between docs pages ( d34d8181 ) remove outdated aecrypto example ( 7df05bfe ) refactor node examples ( e8c443cf ) changelog: add missed single quote in example ( 45fd0002 ) resolveName: Document verify option ( ca865596 ) Remove outdated docs ( cf9c166f ) decodeTx: Fix arg naming and annotation ( 883819c0 ) contract-events: Remove outdated contract, update links and markup ( 37d39d61 ) Update docs/guides/import-nodejs.md ( 9dc274ed ) Update docs/guides/import-nodejs.md ( 93bfce11 ) break down json obj keys necessary for account initialization in nodejs docs ( af5ee41d ) Ignore pycache in the docs folder ( 9989e8e7 ) Specify the python version more precisely ( d6204523 ) Add pycache to .gitignore ( f0b7e1f1 ) Add navigation and update some titles ( 8ad15ced ) docco template: Remove extra new lines around code, skip extra blocks ( 65ce3cf1 ) aecontract: Make a list out of a long sentence ( 8ff7839c ) aens-usage: Use more semantic markup, compatible with mkdocs ( de3d3cd5 ) docs readme: Fix typos and formatting ( 5b0c790d ) Add initial mkdocs and readthedocs configuration ( b688a96b ) Extract quick-start to guides ( 28f7e6f7 ) Update testnet URL ( 7bb823f8 ) assertedType: Make the last parameter more obvious ( 50094d3a ) travis: Build docs to gh-pages ( 7c935a2b ) Docs root: Add link to API reference ( 4a36102d ) Move outdated disclaimer to the root readme ( 80a6a663 ) Remove generated docs ( fd802b00 ) Fix api docs generation ( 56e3aa9d ) Code Refactoring use BigNumber constructor instead of custom wrapper ( 4488b4d7 ) avoid extra object nesting ( f99d3045 ) compiler: use swagger file ( 0d821614 ) semver-satisfies: remove extra splitting by dash ( 35d5c11a ) remove extra char in regex ( 37eeefae ) refactor wallet detector ( 1bc8d027 ) shareWalletInfo: Don't create unnecessary copy of info ( 3a4e50b9 ) Inline receive helper that is used once ( a4a13889 ) rpc: Inline helpers used once ( 21903f4d ) rpc: Prefer default export ( 70fc3f0f ) rpc helpers: Remove unused getWindow function ( c12b528f ) don't use AsyncInit where it is not necessary ( 84373697 ) contract-aci: reuse defaults from Contract stamp ( 47013962 ) cleanup MIN_GAS_PRICE ( a5b28842 ) remove unused option string ( 0e28af23 ) remove unused dryRunAccount default option ( 8c42b706 ) Consistent new on Error creation ( 39f93d3f ) height: Use a shorter syntax ( b013bf9d ) height: Improve naming of internal promise ( 7915119a ) Move source code to \"src\" folder ( ddbce389 ) sign-using-ga: don't pass extra options ( 44bab6d0 ) Bug Fixes traverse-keys: add missed null check ( 7b724b86 ) swagger: add workaround to get transaction details of GAAttachTx ( bb7ec479 ) top-block: use getTopHeader on Iris, mark deprecated ( 2b410257 ) nonce-verification: add missed space ( 3f244dfb ) missed aepp id in wallet connect handler ( 1ed9284a ) get-node-info: bring url and internalUrl back ( e984f3b3 ) contract error decoding ( d56931ac ) contract-aci: don't proxy prepareArgsForEncode from helpers ( 7e40eda0 ) Improve handling of call error ( 584eb5e4 ) Maintenance Use ts-standard instead of standard ( be5aece7 ) tsconfig: Set target version to es5 ( ed131b1b ) Fix eslint errors manually ( dfe3a05e ) require node below 7.0.0 ( ae1a5ef5 ) require node above or equal to 5.2.0 ( ebb36f06 ) update dependencies ( d876cff7 ) deps: bump ssri from 6.0.1 to 6.0.2 ( e0dfb8c9 ) deps: bump y18n from 4.0.0 to 4.0.1 ( 9e4acd61 ) deps: bump elliptic from 6.5.3 to 6.5.4 ( feb3aa68 ) deps: bump axios from 0.19.2 to 0.21.1 ( 0f619f27 ) deps: bump ini from 1.3.5 to 1.3.7 ( 95580324 ) deps: bump highlight.js from 10.4.0 to 10.4.1 ( 9fcfadfe ) deps: bump highlight.js from 10.1.1 to 10.4.0 ( 43aff25f ) deps: bump node-fetch from 2.6.0 to 2.6.1 ( 80ed6d70 ) Update node to 5.8.0 ( b6ff3422 ) Update .gitignore ( 1f1563dc ) add vscode .history folder to gitignore ( f4d61df4 ) Update testnet URL in JS files ( dc1b807a ) add Iris consensus protocol ( 41fd4a13 ) add vsn 2 version of GA_META transaction ( b5abe098 ) add new versions of CHANNEL, CHANNEL_CREATE transactions ( 366981a3 ) support compilers below 6.0.0 ( 876e5164 ) Performance Optimize height queries ( f74ca4cb ) Tests simplify GA tests ( 7b9628c2 ) oracle: avoid explicit waiting for 1 second ( f81cd3a1 ) passing of forceCompatibility flag ( 6f900b98 ) contract: remove extra backend option ( 184566f9 ) update channel tests to fate ( 35a996d8 ) Faster tests ( 5d629103 ) Extract strings tests into separate file ( f3c7d3fa ) ga: Remove extra await ( 72bfc746 ) Make tests more precise ( fe7a8567 ) 7.7.0 (2020-08-18) Features transferFunds: Accept onAccount option ( #1060 ) bigNumberToByteArray: Avoid unexpected behaviour by throwing exception ( #1066 ) example: Add disconnect button on wallet side ( #1056 ) Code Refactoring Use external version of json-bigint ( #1033 ) Make tests configuration more flexible ( #1037 ) test-else: Exclude aens tests and speedup jobs ( #1040 ) Avoid unnecessary eslint-disable ( #1043 ) Add lint script ( #1045 ) Refactor tests ( #1039 ) Refactor bytes unit tests ( #1050 ) travis: Run linter and unit tests firstly ( #1051 ) Disable Travis on all branches except master, develop ( #1054 ) Refactor contract, oracle, chain ( #1048 ) Refactor state channels ( #1047 ) Docs Fix typo in Readme.md ( #1053 ) 7.6.0 (2020-07-22) Features wallet-detector: allow to connect wallet to aepp between iframes ( 3f74a05 ) 7.5.0 (2020-06-18) Features Account: Build signature from transaction hash ( #1025 ) ( 2cb8cc2 ) ACI: External contract integration ( #1027 ) ( a14d13a ) Refactor Deps: Clean up repository ( #1029 ) Env: Simplify Travis and docker-compose ( #1031 ) Env: Remove unused packages ( #1032 ) 7.4.2 (2020-06-10) Bug Fixes AEX-2: Handler always as Promise ( #1018 ) ( a8b0aab ) Refactor AEX-2: Add debug option for getHandler . Hide unknown message logs ( #1021 ) ( 22c452c ) Contract Add AENS name resolver for Contract API 7.4.1 (2020-05-30) Bug Fixes AEX-2: Fix isExtensionContext check ( #1011 ) ( 814f99b ) 7.4.0 (2020-05-29) Bug Fixes AEX-2: Fix getBrowserAPI helper for cross-browser compatibility ( #1007 ) ( 98b0e29 ) Features ACI: Event decoding ( #1006 ) ( 6b8e6fe ) 7.3.1 (2020-05-25) Improvements AEX_2: Handle network switch and update state on both sides. Adjust networkId check for signing request. Add node switcher for example apps ( #996 ) 7.3.0 (2020-05-20) Bug Fixes example: Regenerate lock ( #960 ) ( 5b6a30e ) Features ACI: expose events decoding through Contract ACI stamp ( #971 ) ( 4930635 ) AEX_2: Allow to connect without node ( #991 ) ( 87b9ef9 ) AEX_2: Connect to extension from iframe ( #992 ) ( 47179f7 ) Build: Expose ACIHelpers and ACITransformation to bundle ( #970 ) ( 8b475e0 ) Chain: Add option allowUnsynced for poll method which allow to depend on get tx/info API ( 9c80ce0 ) Channel: add timeout message handler ( #983 ) ( 1940a15 ) Channel: Channel force progress ( #964 ) ( 8f15bef ) Contract: Add unpacked transaction to contract call with error ( #981 ) ( 4efd341 ) Node: Add debug option to Channel stamp ( #967 ) ( 68fcba5 ) 7.2.1 (2020-03-25) Fix build Remove resolving of minimist using npx 7.2.0 (2020-03-24) Docs Guide: Adjust guide for RPC Wallet/Aepp usage Code Refactoring RPC: Refactor rpc-related stuff ( #921 ) Build: Include amountFormatter and SCHEMA in bundle( #936 ) Examples Update examples apps Features TX: Introduce new stamp TxObject ( #933 ) This stamp give more flexibility on transaction serialization/deserialization process Keystore: Allow to store secret as hex or buffer ( #939 ) AEX-2: Add permission layer for account management ( #937 ) 7.1.1 (2020-02-27) Bug Fixes TxBuilder: Fix fee calculation for Oracles ( #924 ) ( a9d784f ) AEX-2: Broken wallet detection ( #926 ) 7.1.0 (2020-02-25) Refactor AEX: Simplify message id processing ( #916 ). Pass AEEP origin to Wallet callback ( #918 ) Node: Move getNetworkId to helpers ( #910 ) ACI: Minor ACI validation improvement. Move decoding of events to builder. Add ability to decode events without ACI Features ACI: Implement Contract Events for ACI( Contract Event Guide ) Contract: Helpers for Oracle and AENS signature delegation( Signature delegation guide ) AmountFormatter: Rework amount formatter. Change formatter units naming. Add more units ( #909 ) ( 6970efe ) TxBuilder: Integrate amount formatter to transaction builder ( #897 ) Account: Implement Message Signing ( singMessage , verifyMessage ) ( #903 ) AEX-2: Add removeRpcClient method to RpcClient/RpcWallet stamp's( #912 ) 7.0.0 (2020-01-31) Bug Fixes AEX-2: Fix firefox compatibility issue ( #882 ) ( 2e16e10 ) Features Chain: add new method waitFOrTxConfirm . Add new option { confirm: 3 } to all of high lvl SDK API. Add tests. Adjust docs ( #874 ) ( 43528f9 ) Compiler: Add new compiler methods API ( #875 ) ( a939395 ) network: Throw error when can not get networkId ( #863 ) ( 41b7bd1 ) Docs Guide Add 7.0.0 migration guide Guide: Add Oracle , AENS and Contract guides BREAKING CHANGES Please check out 7.0.0 migration guide This release include all changes from 7.0.0-next.1 , 7.0.0-next.2 , 7.0.0-next.3 7.0.0-next.3 (2020-01-22) Features aens: implement aensExtendTtl function. Refactor aensUpdate ( #866 ) ( 72b073a ), closes #865 aensUpdate now accept array of pointers aensUpdate have new option extendPointers=false which retrieve pointers from the node and merge with provided Build: update node to 5.4.0 and compiler to 4.2.0 Guide Add guide for AENS usage BREAKING CHANGES AENS: Change AENS methods arguments Now all of AENS module methods accept name as a first argument instead of nameId 7.0.0-next.2 (2020-01-10) Bug Fixes codecov: Adjust codecov badge. Move @babel/runtime to dev-deps ( #848 ) ( 109b851 ) AEX-2: Fix getBrowserAPI function for firefox ( #853 ) Features Account: Add ability to pass keypair or MemoryAccount as nAccount` option ( #847 ) ( 75d8ad8 ) Test: Increase code coverage ( #830 ) ( 6f760fb ) Chain: Extend transaction verification error ( #849 ) Aepp<->Wallet: Add tests for Aepp<->Wallet communication ( #834 ) Documentation Guide: Add guide for Contract ACI usage ( #852 ) 7.0.0-next.1 (2019-12-18) Bug Fixes Contract/Chain: Using { waitMined: false } with Contract high lvl API ( #828 ) ( 475c2aa ) HdWallet: Fix derive function ( #801 ) ( 6c6177d ) Compiler: Filter compiler options Code Refactoring Cross-Node: Remove cross-node compatibility code ( #829 ) ( b29a162 ) Chain: Handle time until tx is not added to mempool ( #816 ) Git: Update issue template( #806 ) Flavors: Remove deprecated code ( #697 ) Test: Increase code covarage ( #830 ) ( 6f760fb ) Features Wallet<->AEPP: Add new Wallet<->Aepp communication API Add two new stamps RpcWallet and RpcAepp Example of usage you can find heere: Aepp example and Wallet example Wallet: Use postMessage for communication with extension wall\u2026 ( #815 ) ( dc7b4c2 ) CI: Move to Travis CI ( #809 ) ( 2d77f20 ) CI: enable daily builds on latest node and compiler and enable codecov ( #820 ) ( 3c52a1e ) ACI: Add check for contract address validity and existence. Add forceCodeCheck option for bytecode verification skip ( #788 ) ( c0cccc9 ) Contract: Add ability to pass arguments or callData for contract deploy/call/callStatic API ( #768 ) ( a828076 ) Contract: Adjust fee calculation for contractCall tx using FATE backend ( #793 ) ( 7254ac1 ) Compiler: Add new API validateByteCodeAPI available on compiler >= 4.1.0 ( #788 ) ( c0cccc9 ) Tx: Always verify transaction before send it to the node ( #798 ) ( 170f479 ) BREAKING CHANGES Tx: By default sdk make a transaction verification Node: Change node compatibility range to node >= 5.0.0 && node < 6.0.0 Compiler: Drop compiler version to version >= 4.0.0 && version < 5.0.0 ACI: Add additional method to RPC communication. Required sdk update on wallet side Add getContractByteCode API Flavor: Remove deprecated params: remove url and internalUrl instead use nodes: [ { name: 'NODE_NAME', instance: await Node({ url, internalUrl }) } ] remove keypair params instead use accounts: [MemmoryAccount({ keypair })] remove setKeypair function from Account stamps 6.1.3 (2019-12-11) Bug Fixes Channel: 5.2.0 compatibility ( 4be8eb8 ) 6.1.2 (2019-11-12) Bug Fixes Composition: Chain composition ( 9ac705f ) 6.1.1 (2019-11-12) Bug Fixes ACI: Disable bytecode check for source and code on-chain. This changes will be included in next major release ( #783 ) ( fe6021b ) Features KeyStore: Remove argon2 package, use libsodium for both browser and node ( #782 ) ( c18047e ) 6.1.0 (2019-11-11) Bug Fixes AENS: auction end block calculation ( #746 ) ( 4c1f5e4 ) AENS: Fix produceNameId function(Make name lowercase). Enable \u2026 ( #750 ) ( fd14225 ) state channels: wait for connection to be established before sending generic message ( #723 ) ( c5f35d1 ) TxHelpers: Use BigNumber in auction end block calculation ( 777c012 ) Features ACI: Add validation for contractAddress ( #764 ) ( 07cb0e7 ) AENS: Add nameFee validation to TxValidator ( #765 ) ( 5250e75 ) AENS: Increase default nameTtl ( #775 ) ( c5f2582 ) Contract: Add ability to pass arguments or callData for contract deploy/call/callStatic API ( #768 ) ( 12aaca3 ) Http: Assign error object to http error ( #770 ) ( 87062ea ) state channels: add round method ( #763 ) ( c950937 ) state channels: allow off chain updates to be cancelled with custom error code ( #753 ) ( ae4426e ) state channels: allow to pass metadata to transfer update ( #755 ) ( ddc6611 ) state channels: make state channels compatible with node v5.0.0\u2026 ( #688 ) ( deed7fc ), closes #632 #653 #658 #660 #680 #693 #687 state channels: make state channels compatible with node v5.1.0\u2026 ( #776 ) ( 74952aa ) 6.0.2 (2019-10-31) Bug Fixes name claim: Revert ignoring waitMined from user passed options (#727) 6.0.1 (2019-10-29) Bug Fixes aens: added lower case transformation for aens names ( #730 ) ( f7f9f17 ), closes #728 6.0.0 (2019-10-16) Code Refactoring SPEND: Add additional validation for recipient ( #715 ) ( c1854bf ) Features State Channels: make state channels compatible with node v5.0.0\u2026 ( #688 ) ( 23936f5 ), closes #632 #653 #658 #660 #680 #693 #687 AENS: Change tld for Lima from aet to chain ( #714 ) ( 323ef6a ) AENS: Implement name bid function ( #706 )) AENS: auction name fee calculation. Name fee validation and calculation in claim/bid ( #706 ) AENS: Add nameId computation function (#709) ( #706 ) BREAKING CHANGES AENS: Change tld for Lima from .aet to .chain 5.0.0 (2019-10-04) Bug Fixes rpc: fix resolution rpc ops ( #669 ) ( abd7c56 ) Code Refactoring ACI: rework Sophia Option type representation ( #691 ) ( 0dbb2fe ) Features AENS: Add ability to spend by name ( #682 ) ( 0d43804 ) AENS: Add ability to claim contract, oracle, SC ( #671 ) ( 49fd0fd ) GA: enbale GA ( #692 ) ( eded912 ) Lima: Lima compatibility ( #683 ) ( a88042e ), closes #632 #653 #658 #660 #680 #693 #687 AENS auction support compiler 4.0.0 support node 5.0.0 support SDK use FATE for contract by default AE : Add pointers verification for spend by name BREAKING CHANGES aci: Change Sophia option type representation in ACI // from await contract . methods . optionFn ( Promise . resolve ( 1 ) || Promise . reject ()) // to await contract . methods . optionFn ( 1 || undefined ) 5.0.0-next.1 (2019-09-10) Bug Fixes package: update serialize-javascript to version 2.0.0 ( #647 ) ( 1ddb392 ) Features Contract/ACI Add payable feature Compiler: Compiler 4.0.0 compatibility ( #632 ) ( d5f1632 ) Contract/ACI: Add ability to use contract with external namespaces( include \"someLib\" ) ( #653 ) ( 9708b43 ) 4.7.0 (2019-09-11) Features Oracle: Add methods for polling queries #637 Chain: Add getBalance method ( #655 ) ( 15147af ) state channels: add reconnect method ( #662 ) ( 9d8d1e8 ) state channels: add backchannel updates test #664 4.6.0 (2019-08-28) Bug Fixes Compiler: Fix forceCompatibility option ( 26beba8 ) Features Lima : add preliminary support for lima ACI/Contract: Implement static-call for deploy transaction for ACI methods/Contract low lvl API ( #630 ) ( 5b7eeb4 ) Notes GA support has been disabled until further notice due to node compatibility issues This version support aeternity node up to 5.0.0-rc.1 4.5.1 (2019-08-22) Refactor Example Add node info to AEPP ( #620 ) Bug Fixes GA Fix GA account composition ( 211e409 ) 4.5.0 (2019-08-20) Bug Fixes Crypto: Fix keypair verification ( #605 ) ( 83a52fb ) RPC: Remove NodePool stamp from AE composition ( #612 ) ( 21af2eb ) state channels: add missing argument in onOnChainTx callback ( #604 ) ( 165cfe8 ) state channels: fix awaitingOnChainTx state handler ( #608 ) ( 8b7b65a ) Swagger: Always throw error from axios error handler ( #607 ) ( 0e5cf61 ) Features MemoryAccount: Add validation of keypair ( #594 ) ( b8c2b20 ) state channels: handle BigNumbers with json-bigint ( #596 ) ( 14eaa3d ) state channels: send generic messages immediately ( #600 ) ( 8ad7583 ) Generalize Account Implement Generalized account support ( #449 ) const authContract = `YOUR_AUTH_CONTRACT` // Make current account Generalized await client . createGeneralizeAccount ( authFnName , authContract , [... authFnArguments ] // Make spend transaction using GA // One Way // encoded call data for auth contract const callData = 'cb_...' await client . spend ( 10000 , receiverPub , { authData : { callData } }) // or // sdk will prepare callData itself await client . spend ( 10000 , receiverPub , { authData : { source : authContract , args : [... authContractArgs ] } }) 4.4.0 (2019-08-09) Bug Fixes Package: update commander to version 3.0.0 ( #597 ) ( 9aaa05c ) Contract: Fix dry-run without account ( 227fc5c ) Features Contract: add ability to use call-static/dry-run without keyPair ( #577 ) ( c38edd9 ) AE: Add ability to make operation on specific account using onAccount option. Exm: await client.spend(1, receiver, { onAccount: 'PUBLIC_KEY' }) Add `onAccount` to `AENS`, `Contract`, `Oracle`. Add tests for using specific account to Contract, ACI, Account. JSON: : Add serialization to JSON for bigNumbers MemoryAccount: Add validation of keypair ( #594 ) ( b8c2b20 ) State Channels: persist connection by pinging every 10 seconds ( #571 ) ( a70f919 ) 4.3.0 (2019-08-05) Bug Fixes State Channels: Fix onChainTx event params ( #566 ) ( 11c85eb ) State Channels: Fix websocket url ( #558 ) ( 33c1fd8 ) Swagger: Pass query params in case of get request ( #570 ) Code Refactoring State Channel: Do not include white space for outgoing websocket messages ( #559 ) Features ACI: Implement sophia variant type ( #567 ) ( 8505dcf ) Contract: add ability to use call-static/dry-run without keyPair ( #577 ) ( c38edd9 ) NodePool: Implement NodePool stamp ( #574 ) ( 674166c ) State Channel: make state channel compatible with aeternity@4.0.0 ( #568 ) ( 0d0e09b ) TxBuilder: Add helper for producing tx hash ( #579 ) ( e1b405e ) AE Make all AE stamps composed with Accounts ( #581 ) Docs ACI Add some additional clarification to getContractInstance 4.2.0 (2019-07-15) Bug Fixes package: update libsodium-wrappers-sumo to version 0.7.5 ( #541 ) ( 956ed75 ) rpc-server: Fix type 'object' check ( #526 ) ( 48c42e4 ) Code Refactoring swagger: Speedup initialisation AENS: Remove unused param from claim method AENS: Fix exception if not waiting for mining(claim) Test: Add test for contract namespaces Features Node: Add 4.0.0 node compatibility Compiler: Add compatibility with compiler 3.2.0 Channel: Implement GA awareness of State Channels 4.1.0 (2019-06-22) Bug Fixes Node: Do not throw error if internalUrl not provided. Instead use url ( #503 ) ( 053faae ) TXBuilder: Fix payload serialization if you try to unpack and pack tx. ( #498 ) ( 73552e5 ) TxValidator: Fix validation of state channel open transaction ( #496 ) ( 325cc90 ) Features ACI: Refactor ACI module. Split to separated files. ( #505 ) ( fb7bc00 ) Selector: If default account address not provided use the first ACI: Handle ACI without init function ACI: Automatically decide to send transaction on-chai or call-static. Add options object like last arguments of generate fn under instance.methods const instance = await client.getContractInstance(source) // Deploy contract await.contract.init(100, 'test', options) //or await.contract.deploy([100, 'test'], options) // Call function const result = await instance.call('sum', [2, 5], options) // // Automatically decide to send tx on-chain or call-static(dry-run) base on if function stateful or not const result = await instance.methods.sum(2, 5, options) // Manually make on-chain const result = await instance.methods.sum.send(2, 5, options) // Manually make call-static const result = await instance.methods.sum.get(2, 5, options) // Docs Usage: : Add instructions about how to include directly the SDK in a html page 4.0.1 (2019-06-13) Bug Fixes RPC: Add contract contractDecodeCallResultAPI to RPC ( #482 ) ( 7eb6bd8 ) README: Fix flavor link ( #480 ) Code Refactoring Compiler: Fix compiler compatibility mechanism ( #479 ) ( 78cc990 ) Utils: Move json-bigint implementation to utils ( #486 ) ( 1538867 ) Build webpack: Add another bundle( dist/aepp-sdk.browser-script.js ) for using in <script> tag ( #485 ) 4.0.0 (2019-06-12) Bug Fixes Ae: Fix exception when it used without Contract stamp Code Refactoring SCM: Update compatibility range for node: 3.0.1 - 4 and compiler 3.1.0 - 4 ( #474 ) ( a1494fd ) Test: Simplify client creation Features Docs chore(Docs): new docs ( #370 ) Compiler: Add getCompilerVersion to compiler stamp ACI: Make compatible with compiler 3.1.0 ( #457 ) ( d92f2c7 ), closes #458 ACI: Generate JS function proto for each of contract function ( #439 ) ( 2f47b4d ) Compiler/ACI: Make ACI compatible with compiler 3.0.0 ( #441 ) ( 2a8eb1a ) Node: Avoid usage of \"universal-url\" package ( #434 ) ( a8268d5 ) TX: encode payload as base64 ( #460 ) ( ad490af ) TX_BUILDER: Fix bug related to contract fee calculation. ( #472 ) ( 7214cfb ) BREAKING CHANGES DOCS Restructure and rework sdk documentation SCM: This change will make the release not compatible with older version of the node and compiler ACI: Change Contract low lvl API: change contractDecodeData interface from: (type:String, data: String) => Any to (source: String, fn: String, callValue: String, callResult:String) => Any . ( callResult is callType from call result, can be ok , revert , ...) 3.4.1 (2019-06-05) Bug Fixes Deps: Update axios lib to 0.19.0 due to security issue ( f951765 ) 3.4.0 (2019-05-22) Bug Fixes State Channels: Remove automatic pinging to fix browser compatibility ( #432 ) ( 0700f3a ) Features Transaction Builder: Improve min fee calculation(Reduce the fee) ( #424 ) AXIOS: Add ability to intercept error from axios ( #431 ) Added additional param to sdk initialization axiosConfig Example: Universal({ axiosConfig: { config: { // axios config object }, errorHandler: (err) => throw err }}) * Transaction Builder: Implement vm/abi validation for contract/oracle tx based on consensus protocol version. Add custom verification based on transaction type ( #425 ) ( #426 ) 3.3.0 (2019-05-17) Bug Fixes AEP exampe: Fix contract in AEPP example ( e2fec19 ) fix(AEP exampe): Fix contract in AEPP example Features Consensus: Add function to get consensus version. ( #413 ) ( 46027cd ) State Channels: Make state channels compatible with aeternity 3.0.0 ( #415 ) ( 668e7f1 ) Transaction Builder: Add serializations for transactions introd\u2026 ( #416 ) ( fd7b8ce ) BREAKING CHANGES NODE Change compatibility from 2.3.0 to 3.0.0 3.2.1 (2019-05-16) Bug Fixes Joi: Add JOI browser comparability 3.2.0 (2019-05-16) Bug Fixes ACI: Add ability to pass zero address as number. ( #396 ) ( b5b5c61 ) ACI: Fix address type transformation when decoding data ( #335 ) ( e37cdfc ) Contract: Add error handling(decoding) in low lvl contract API ( #386 ) ( e1fdce0 ) Dependencies: Use URL class instead of \"url\" package Dependencies: Use custom version of json-bigint Dependencies: Avoid usage of semver package and cleanup deps RPC: rpc client: Handle case if aepp opened without wallet Channels: Fix state channel test's Features KEYSTORE: Add browser compatibility TX: Handle VM/ABI fields serialization and validation basaed on tx type and node version ACI: Add contract , address , record types argument/result transformation ( #349 ) ( 0599d7d ) WEBPACK: webpack configs: Mark all dependencies as external WEBPACK: Setup webpack-bundle-analyzer plugin ACI: Add Option sophia type to ACI ( #390 ) ( 83f5279 ) ACI: Implement arguments validation for generic sophia types(list, map, tuple, record) ( #384 ) ( 956e59e ) ACI: Update due to compiler API changes ( #331 ) ( e047f3b ) AE: Allow to spend % of balance. ( #371 ) ( f97a2ae ), closes #336 Aepp: Add Compiler to Aepp rpc methods. Update example app ( #312 ) ( 9c72521 ) Aepp: Refactor Aepp example app. Allow to spend with payload and add reverse iframe approach. Compiler: Add decode CallData by source/bytecode ( #354 ) ( 761f36b ) Fortuna: Node 3.0.0 compatibility ( #397 ) ( 17b78d5 ) RPC: Add getNodeInfo to AEPP stamp through RPC ( #359 ) ( 2ddeea8 ) State Channels: Add cleanContractCalls method ( #338 ) ( 778159a ) State Channels: Ping every 10 seconds to persist connection ( #324 ) ( 6d0e156 ), closes #276 #299 #300 #303 #302 #279 #275 #276 #299 #300 State Channels: Remove endpoint param ( #391 ) ( 8d9ea7e ) BREAKING CHANGES State Channels: Endpoint param is removed and no longer defaults to \"/channel\". This means that \"/channel\" (or other path) must be appendend to url para 3.1.0 (2019-04-24) Bug Fixes ACI: Fix address type transformation when decoding data ( #335 ) ( e37cdfc ) Features ACI: Add contract , address , record types argument/result transformation ( #349 ) ( 0599d7d ) ACI: Update due to compiler API changes ( #331 ) ( e047f3b ) Aepp: Add Compiler to Aepp rpc methods. Update example app ( #312 ) ( 9c72521 ) Compiler: Add decode CallData by source/bytecode ( #354 ) ( 761f36b ) RPC: Add getNodeInfo and getNetworkId to AEPP stamp through RPC ( #359 ) ( 2ddeea8 ) State Channels: Add cleanContractCalls method ( #338 ) ( 778159a ) State Channels: Ping every 10 seconds to persist connection ( #324 ) ( 6d0e156 ) 3.0.0 (2019-04-17) Bug Fixes ACI: Fix address type transformation when decoding data ( #335 ) ( e37cdfc ) Features TX_BUILDER: Channel tx serializations TxValidator: Add minGasPrice validation to contract transactions ACI: Update due to compiler API changes ( #331 ) ( e047f3b ) Aepp: Add Compiler to Aepp rpc methods. Update example app ( #312 ) ( 9c72521 ) State Channels: Add cleanContractCalls method ( #338 ) ( 778159a ) BREAKING CHANGES ACI Remove 2.0.0 compiler compatibility 2.4.1 (2019-04-17) Features ACI: Add transform decoded data for 'address' type AEPP: Add Compiler to Aepp rpc methods. Update example app Channel: Add call contract static support Channel: Add get contract state support Channel: Get full channel state support DOCS: Adjust ACI, Contract and Usage Bug Fixes HTTP: Handle no response in http stamp error handler Crypto: Fix crypto formatAddress Crypto: Move ADDRESS_FORMAT to crypto BREAKING CHANGES Channels: channel.state() now returns offchain state instead of last co-signed offchain transaction channel.update(...).state has been renamed to signedTx channel.withdraw(...).state has been renamed to signedTx channel.deposit(...).state has been renamed to signedTx channel.leave().state has been renamed to signedTx channel.createContract(...).state has been renamed to signedTx channel.callContract(...).state has been renamed to signedTx 2.4.0 (2019-04-17) Features Chore: Install and configure commitizen Crypto: Add formatAddress function to Crypto Contract: Add Contract Compiler API stamp to es/contract (now using instead contract node API) Utils: Add basic http client stamp ( es/utils/http ) Contract: ACI stamp (New Contract interface base on contract ACI schema) const contractIns = await client.getContractInstance(contractSourceCode) console.log(contract) { interface: String, // Contract interface source code aci: String, // Contract interface json schema source: String, // Contract source code compiled: String, // Compiled contract code deployInfo: { address: contractAddress } // Object with deploy transaction, // Function compile: () => this, // Compile contract, deploy: (init = [], options = { skipArgsConvert: false }) => this, // Deploy contract (compile before if needed) call: (fn, params = [], options = { skipArgsConvert: false, skipTransformDecoded: false, callStatic: false } => CallRersult: Object // Call contract function } Account: Extend Account.address() with accountFormatter now you can do export const ADDRESS_FORMAT = { sophia: 1, // return address like `0xHEX_ADDRESS` api: 2, // return address like `ak_9LJ8ne9tks78hTD2Tp571f7w2MJmzQMRsiZxKCkMA2d2Sbrc4` } // export { ADDRESS_FORMAT } from 'es/account' await account.address(format: ADDRESS_FORMAT) // default ADDRESS_FORMAT.api Channel: Improve channel rpc usage Channel: Improve channel tests and error handling Channel: Improve state channel params handling Chain: Add ability to get account/balance on specific block hash/height Universal: Add { compilerUrl } to Universal, Contract, Wallet stamp initialization Bug Fixes Contract: decode node error coming from contract call and callStatic Chain: Throw native error instead of object in chain chain.sendTransaction Crypto: fix arguments parsing in Crypto.sing Crypto: Fix name hash function arguments parsing in Crypto BREAKING CHANGES Contract: Remove ContractNodeAPI stamp Contract: Change Contract stamp API 1) Use Compiler instead of node API for encode/decode call-data and compile. 2) Change Contract interface: - contractCallStatic (address, abi = 'sophia-address', name, { top, args = '()', call, options = {} } = {}) -> (source, address, name, args = [], { top, options = {} } = {})) - contractCall (code, abi, address, name, { args = '()', options = {}, call } = {}) -> (source, address, name, args = [], options = {}) - contractDeploy (code, abi, { initState = '()', options = {} } = {}) -> (code, source, initState = [], options = {}) - contractEncodeCall (code, abi, name, args, call) -> (source, name, args) // 'source' is -> Contract source code or ACI interface source 2.3.2 (2019-03-04) Features Contract: Change default gasPrice from 1e6 to `1e9z AEPP: Fix AEPP example app Build: Force image pull before builds 2.3.1 (2019-02-22) Features Oracle: Oracle fee calculation Tx: getAccountNonce function to tx stamp TX_BUILDER: Change FEE_BYTE_SIZE from 1 to 8 bytes in fee calculation TX_BUILDER: Improve error handling in tx builder 2.3.0 (2019-02-22) Features Node: Minerva comparability Utils: Mnemonic wallet implementation es/utils/hd-wallet Oracle: Change Channel legacy API to JSON RPC Oracle: Change default gasPrice to 1e6 Oracle: Change minFee calculation, multiply min fee by 1e9 BREAKING CHANGES Node: Change supported node version range to 1.4.0 <= version < 3.0.0 This release contain changes from: 2.3.0-next , 2.2.1-next , 2.1.1-0.1.0-next , 2.1.0 2.3.0-next (2019-02-21) Features Channel: channel withdraw and deposit methods TX_BUILDER: Change default gasPrice in Contract stamp and Tx stamp to 1e9 TX: Fix contract tx fee calculation Chain: Refactor error handling in sendTransaction function Contract: Change default gasPrice to 1e9 TX_BUILDER: Change Fee byte_size to 1 2.2.1-next (2019-02-21) Feature TX_BUILDER: Add deserialization schema for Channel transactions( channelCreate , channelCloseMutual , channelDeposit , channelWithdraw , channelSettle ) Chain: Add rawTx and verifyTx to error from poll function(when you wait for transaction will mined) Chore: Depend on bip39 from npm instead of git repo Channel: Change Channel legacy API to JSON RPC TX_BUILDER: Change minFee calculation, multiply min fee by 10^9 2.1.1-0.1.0-next (2019-02-21) Bug Fixes Chore: Fix linter errors 2.1.0 (2019-02-21) Features Node: Minerva comparability Utils: Add Mnemonic wallet implementation es/utils/hd-wallet BREAKING CHANGES Node: Change supported node version range to 1.4.0 <= version < 3.0.0 2.0.0 (2019-02-21) Features TX_BUILDER: Add unpackedTx , txType and signature to validate transaction function Contract: Add top param to contract static call(dry-run) Contract: Add errors handling for dry-run Docs: Add keystore docs Ae: Add verify options to send function which verify tx before broadcasting and throw error if tx is invalid Rpc: Add dryRun to RPC methods Rpc: Add Oracle transaction creation to Aepp rpc Docs: Add tx builder docs Docs: Add doc's for utils/bytes and tx builder schema TX_BUILDER: refactor calculateFee function in TxBuilder (use BigNumber) TX_BUILDER: Extend response of Oracle , Aens , Contrat with rawTx Ae: Change response of send function now it's and object with transaction data(hash, rawTxHash, ...) Chain: Move Contract and Oracle API wrapper's to Chain stamp Chore: Rename epoch in CHANGELOG , README , HACKING Bug Fixes Rpc: RpcServer : Avoid storing of window in instance properties Chain: Disable balance formatting by default Chain: Move verification of transaction to chain stamp Node: Retrieve node version from /api Chore: Fix unpack tx example in bin/aecrypto.js Chore: Remove unused function's from crypto.js BREAKING CHANGES TX: Remove old transaction builder es/tx/js.js (Please use es/tx/builder instead) Chore: Rename es/epoch.js to es/node.js Chore: Rename Oracle , Contract , Chain API wrapper files from epoch to node Chore: Rename Contract api wrapper method's 1.3.2 (2019-02-01) Features Ae: Add destroyInstance function to Ae stamp which remove all listeners for RPC event's Docs: Add docs for TransactionValidator and TxBuilder stamp's Build: Add TxBuilderHelper to bundle Chore: Contract call static now using dry-run API Test: Improve test's for Transaction verification Changed Docs: Adjust doc's for Contract and Aens stamp's Chore: Fix decoding of address from contract call 1.3.1 (2019-01-29) Features Build: Remove KeyStore from bundle due to build issue(for now you can export it only using tree-shaking import * as Keystore from '@aeternity/aepp-sdk/utils/keystore' ) 1.3.0 (2019-01-29) Features Channel: Add support for State Channels TX_BUILDER: New transaction builder going through schema(build, unpack) TX_VALIDATOR: Add new stamp TransactionValidator which can verify your transaction Chore: Rename epoch to aeternity node(docker configs, some docs) Tx: Use new tx builder in TX stamp Contract: Set default values for amount and deposit to 0 for contract transaction Rpc: Improve RPC server Notes and known Issues Old transaction builder es/tx/js.js will be removed in next major release. 1.2.1 (2018-12-21) Features Chain: amount formatter Chain: amount format balance client.balance('AK_PUBLICKEY', { format: true }) Aepp: Oracle and Contracts API to Aepp stamp Chore: Use prepare instead of postinstall-build (thanks @davidyuk) Docs: Refreshed Docs: README.md + docs/usage.md Bug Fixes Chr: Fix Import RLP package (thanks @davidyuk) Rpc: Fix for NetworkId propagation and override Tx: TxJS is not a stamp anymore, and instead: it exports helper functions BREAKING CHANGES Tx: TxJs stamp (not a stamp anymore) Chain: balance now answer a formatted string composed of AMOUNT + ' ' + unit (eg. 10 exa for 10 AE) Notes and known Issues Chore: 10 exa should be 10 ae Chain: format shouldn't be a flag, but a request for unit eg. { format: ae } 1.1.2 (2018-12-15) Feature Chore: isAddressValid check Tx: Tx Fee formulas Bug Fixes Rpc: Fixed networkId propagation (and overriding on init of Flavors) Crypto: Fixed encodeBase58Check by feeding Buffered input BREAKING CHANGES Chore: Compatibility with Node >= 1.0.0 and <= 1.1.0 1.1.1 (2018-12-11) Features Rpc: Added a command to remove images after CI testing Bug Fixes Rpc: Fix Testing Rpc: Fixed Oracle error for Wallet flavor 1.1.0 (2018-12-11) Features Oracle: Oracles functionality and flavor Aepp: Simple example of aepp-in-aepp (see /examples folder) Bug Fixes Tx: Fixed issue with big numbers and TX 1.0.1 (2018-11-30) Features Node: ability to support Node range(s) using semver package (see https://www.npmjs.com/package/semver#ranges) BREAKING CHANGES Node: Support for Node >= 1.0.0 and < 2.0.0 1.0.0 (2018-11-30) Features Contract: Contract native Transactions Bug Fixes BigNumber: Rolled back to bignumbers.js for easier fix with axios.get/post BREAKING CHANGES Node: Support for Node < 1.0.0 Build: New NETWORK_ID (also used in docker/sdk.env for CI tests) Protocol: Encoding of transaction (and other objects) changed from base58check to base64check Notes and known Issues Channel: State Channels have been excluded for problems with CI, will be included in next release 0.25.0-0.1.1 (2018-11-30) Notes and known Issues Chore: See [0.25.0-0.1.0] 0.25.0-0.1.0 (2018-11-30) Features Utils Parsing of fee using bignum.js Account Add networkId as param to Account flavor(default: ae_mainnet ) Tx Implement native build of AENS transaction. Keystore Update keystore for new requirements BREAKING CHANGES CLI AE CLI and AE PROJECT CLI moved to separate repos and packages Node Support for < 0.25.0 0.25.0-0.1.0-next (2018-11-30) Features Contract Contract type checked call (Ability to call contract using contract address) Contract Use ES methods instead of Ramda, where possible Bug Fixes Contract Fixed keystore by adding a salt param for derivedKey function Breaking Changes Contract Support for < 0.25.0 Contract Aens use domain .test instead of .aet (see here ) Contract Use NETWORK_ID for signing (see here ) 0.24.0-0.2.0 (2018-10-30) Features Rpc RPC Client improvements Rpc onContract Guard CLI born CLI Host parameter became Url . ( -u for hostname, -U for internal) CLI New keystore following these specifications: https://www.pivotaltracker.com/n/projects/2124891/stories/155155204 BREAKING CHANGES Chore The Cli flavor is now Universal Chore the keypair keys changed from { pub, priv } to { publicKey, secretKey } for consistency with other systems using them (eg. AirGap and HD Wallet ) Notes and known Issues Chore CLI and AE PROJECT CLI will move to a separate package 0.24.0-0.1.0 (2018-10-23) Features Node Full support of Node-0.24.0 CLI Develop decode base58 address command in crypto module CLI Add nonce param to all tx command's CLI Add gas param to deploy and call commands Tx Add ability to create spend transaction natively Keystore Implement ethereum keystore using AES-126-CTR and SCRYPT as key derivation function CLI Change --privateKey to flag on ACCOUNT ADDRESS command Build Change node version in Dockerfile Node API endpoints to meet new Node specifications Chore Update docco config and change rename package to recursive-rename Docs Improved documentation BREAKING CHANGES Node Support for < 0.24.0 Keystore ethereum keystore usage will be removed in the next release CLI CLI will move to a separate package 0.22.0-0.1.0-beta.1 (2018-10-02) Features CLI Add CLI implementation Crypto nameId function for commitment hash calculations Node API endpoints to meet new Node specifications Tx Add Nonce calculation on SDK side Contract Add check for MAX_GAS in call and deploy contract Chore change hash prefix separator from $ to _ Chore Add keywords ('SDK', 'CLI') to package.json CLI Link aecli to ./bin/aecli.js in package.json (After \"npm link\" you can use CLI globally) Aens Wait until pre-claim transaction block was mined before send claim transaction Build Updated webpack , webpack-cli and added new dev deps accordingly Node Add Node Compatibility Check Bug Fixes Crypto Fixes commitment hash calculations in naming system, to be Hash(nameId(name) + name_salt) instead of Hash(Hash(name + name_salt)) . BREAKING CHANGES Node Support for < 0.22.0 0.18.0-0.1.1 (2018-07-31) Features Docs Lots of new documentation (prose and API) Docs Fancy badges to README Build Transitive dev dependencies for standard-loader not covered by pnpm Build CI Dockerfile to include pnpm Docs Fancy-shmancy diagram in README Docs Generated documentation files since they are linked in static docs Build Switch from Yarn to pnpm for building Docs Structure of documentation Docs Generate Markdown from Docco 0.18.0-0.1.0 (2018-07-24) Features Node Support for Node 0.18.0 (changed endpoints) RPC Wallet/Aepp RPC support Contract Contract call result decoding support Docs Per-module API documentation (Markdown based on JSDoc) Docs More API documentation (still incomplete) Build SDK entrypoint factories (in /es/ae/universal.js ) Build Module load path (src -> es) Chore Lower mining rate (5s) in docker-compose Bug Fixes Crypto Symmetric key encryption/decryption BREAKING CHANGES Node Support for < 0.18.0 (changed endpoints) 0.15.0-0.1.0 (2018-06-12) Features Node Legacy Swagger file loading Node Compatibility with < 0.15.0 Bug Fixes Contract Contract unit state initialization Node Missing required parameter for name transfers (workaround for Swagger file bug ) 0.14.0-0.1.0 (2018-06-11) Features API New, opinionated top-level API API Rest of legacy API now uses new API as well API Generated API now encapsulated in api object API Automatic case conversion for remote parameter names API Remaining tests to use new API API Adapted new method of obtaining transaction hash, breaks compatibility (see below) Bug Fixes API [GH-49]: Handle existing path components correctly BREAKING CHANGES API Remove Oracle API (for the time being) API Remove Legacy API and tests API Remove Compatibility with older versions of Node which provide the transaction hash the old way 0.13.0-0.1.1 (2018-05-24) Features Node Switch to curve ed25519 (from secp256k1) to align with Node protocol changes Node Generate basic API directly from Swagger files, also validate input data Build Compiled library now self-contained with all dependencies Build Use Webpack 4 based cross-platform (Node/Web) compilation Docs Package description now reads SDK for the \u00e6ternity blockchain Chore Authors are now taken from AUTHORS instead of package.json Docs Moved code examples from README to separate file in docs BREAKING CHANGES Node Defunct scripts; will be brought back later Bug Fixes Chore More consistent code examples","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"All notable changes to this project will be documented in this file. See standard-version for commit guidelines.","title":"Changelog"},{"location":"CHANGELOG/#1101-2022-04-07","text":"","title":"11.0.1 (2022-04-07)"},{"location":"CHANGELOG/#bug-fixes","text":"contract: do not check payable if contract call is init ( c09fc0c ) importing in mjs ( 01d493b ) oracle: do not include address for oracle respond signature ( ad4bddc )","title":"Bug Fixes"},{"location":"CHANGELOG/#1100-2022-03-18","text":"","title":"11.0.0 (2022-03-18)"},{"location":"CHANGELOG/#request-batching-sdk-now-supports-batching-transactions","text":"","title":"Request batching: SDK now supports batching transactions"},{"location":"CHANGELOG/#custom-error-types-introduced-error-types","text":"","title":"Custom error types: Introduced error types"},{"location":"CHANGELOG/#naming-convention-instances-of-the-sdk-in-the-examples-and-tests-are-now-called-as-aesdk","text":"","title":"Naming convention: Instances of the SDK in the examples and tests are now called as aeSdk."},{"location":"CHANGELOG/#breaking-changes","text":"return empty array instead of throwing UnsignedTxError rpc: remove forceValidation flag hd-wallet: expect that bip39 used externally hd-wallet: remove default export crypto: make (encode/decode)Base(58/64)Check private use bs58 instead of bs58check update rlp to 3.0.0 tx builder: throw exception if deposit is not zero tx schema: remove default NAME_FEE equal to 0 tx builder: accept unencoded name in nameClaimTx spelling of GeneralizedAccount aci: remove call/callStatic from deployInfo aci: remove createdAt property generated at client contract: remove deprecated contractCallStatic contract: remove deprecated contractDeploy contract: remove contractCompile contract: remove deprecated contractCall remove deprecated topBlock remove unused functions contract events: remote contract support contract instance: store aci as it is wallet-rpc: inline resolveOnAccount helper aepp-wallet schema: convert to TS aepp-wallet schema: rearrange METHODS enum aepp-wallet schema: remove unused enums contractCompile: remove encodeCall compiler: remove contractEncodeCallDataAPI compiler: remove getCompilerVersion contract: remove compileContractAPI contract: remove contractGetACI contract: remove contractDecodeCallDataByCodeAPI contract: remove contractDecodeCallDataBySourceAPI contract: remove contractDecodeCallResultAPI compiler: remove validateByteCodeAPI compiler: remove getFateAssembler compiler: remove getBytecodeCompilerVersion poll: avoid extra transaction info request to node drop https scheme workaround for hosted compiler node: don't wrap internal endpoints if internalUrl missed tx builder: inline VALIDATION_MESSAGE decodeEvents: accept event schemas as it is in ACI contract: remove already processed fields from decoded events aci: drop redundant per-method event decoding","title":"\u26a0 BREAKING CHANGES"},{"location":"CHANGELOG/#features","text":"aci: use dry-run to estimate gas and get rich errors ( bb6977d ) calculate default polling intervals depending on node settings ( d9c6cf9 ) chain: combine multiple dry-run requests at one ( ddcdaef ) contract events: ability to resolve multiple definitions of event ( c5b77fa ) contract events: remote contract support ( c7599c7 ) createGeneralizeAccount: estimate gas limit instead of using const ( da88852 ) decode encode: validate base58 prefix and payload length ( e836260 ) error: introduce error types ( #1345 ) ( 444bb33 ) package: build es version compatible with node ( 480c747 ) poll: use getCheckTxInPool if available ( 690db5b ) swagger: converts operationId in snake case to pascal ( e52b739 ) swagger: split transactions by queues to post batch of txs from one account ( 0023fc7 ) tx builder: accept unencoded name in nameClaimTx ( eea92be ) tx builder: don't require produceNameId to create AENS txs ( 57ef9c7 ) tx builder: provide default name fee ( 18e4bab ) validator: check contractId ( 5e667a5 ) wallet: add switch for aepp wallet node sharing ( b5640d6 ) wallet: enable aepp to wallet node connection ( d87e1fa ) wallet: provide switch for aepp wallet node connection ( dfbab59 )","title":"Features"},{"location":"CHANGELOG/#bug-fixes_1","text":"aens helpers: improve naming, add additional validations ( d2a10e1 ) babel: compatibility with create-react-app ( e4b56fe ) babel: depend on buffer package in es build ( 0ba51e9 ) babel: don't rewrite import of rlp package for @vue/cli@4.5.15 ( 0fdd296 ) chain: don't require address function to post transaction ( 07bc105 ) channel force progress: add missed binary prefixes ( 78660d2 ) channel: ignore messages that can't be handled, print to console ( aaad8e3 ) compatibility: update argon2-browser to version with default export ( 0e69d8b ) compatibility: use blakejs that doesn't refer to Buffer ( 94f1879 ) contract events: don't throw error if events emitted by remote ( fa1c569 ) delegate signature: don't encode address depending on onAccount ( 563a972 ) dry-run: don't combine requests by default ( 0f36efc ) error: remove duplicate error message ( 8b4df9a ) es: babel build on windows ( 30f5213 ) keystore: encoding of hex privateKey, simplify tests ( 9f3ad6b ) spelling of GeneralizedAccount ( 21c1dd3 ) tx builder: reject more than 32 pointers ( 9c06dab ) tx builder: throw exception if deposit is not zero ( 7b3d0e3 ) aci: drop redundant per-method event decoding ( a84d781 ) aci: remove call/callStatic from deployInfo ( 84d082d ) aci: remove createdAt property generated at client ( 406684c ) aepp-wallet schema: convert to TS ( 1775e91 ) aepp-wallet schema: rearrange METHODS enum ( 8a40105 ) aepp-wallet schema: remove unused enums ( 95bf0e9 ) compiler: remove contractEncodeCallDataAPI ( 7d02317 ) compiler: remove getBytecodeCompilerVersion ( 13283be ) compiler: remove getCompilerVersion ( fb929f8 ) compiler: remove getFateAssembler ( 165d492 ) compiler: remove validateByteCodeAPI ( 90ba164 ) contract instance: store aci as it is ( 978225e ) contractCompile: remove encodeCall ( 6d0ade5 ) contract: remove already processed fields from decoded events ( 45bae5f ) contract: remove compileContractAPI ( 5ae9c62 ) contract: remove contractCompile ( 7390629 ) contract: remove contractDecodeCallDataByCodeAPI ( 2fe798a ) contract: remove contractDecodeCallDataBySourceAPI ( 8b13f70 ) contract: remove contractDecodeCallResultAPI ( b9fbfa6 ) contract: remove contractGetACI ( 23ada71 ) contract: remove deprecated contractCall ( c079e6e ) contract: remove deprecated contractCallStatic ( 1e3ac6d ) contract: remove deprecated contractDeploy ( 08e423e ) crypto: make (encode/decode)Base(58/64)Check private ( c151183 ) decodeEvents: accept event schemas as it is in ACI ( 17b9cc4 ) drop https scheme workaround for hosted compiler ( 9fc0a02 ) hd-wallet: expect that bip39 used externally ( f6243ad ) hd-wallet: remove default export ( 951ebb2 ) node: don't wrap internal endpoints if internalUrl missed ( 50d7bba ) poll: avoid extra transaction info request to node ( 22c4838 ) remove deprecated topBlock ( 4535c07 ) remove unused functions ( 8c00de5 ) return empty array instead of throwing UnsignedTxError ( c6bacdf ) rpc: remove forceValidation flag ( 9f958c3 ) tx builder: inline VALIDATION_MESSAGE ( defb7e1 ) tx schema: remove default NAME_FEE equal to 0 ( 9d8339a ) update rlp to 3.0.0 ( bb32b77 ) use bs58 instead of bs58check ( 32e836b ) wallet-rpc: inline resolveOnAccount helper ( 1277b5b )","title":"Bug Fixes"},{"location":"CHANGELOG/#1000-2021-12-07","text":"","title":"10.0.0 (2021-12-07)"},{"location":"CHANGELOG/#breaking-changes_1","text":"crypto: remove unused asymmetric encode/decode functions aens: don't limit pointer keys specify browserlist to better choice of features to transpile aci: don't require source code make contractDeploy a wrapper, remove unused code inline getConsensusProtocolVersion function invert and rename forceCodeCheck option to validateByteCode require compiler 6 and above make contractCall/Static a wrapper around getContractInstance contract instance: thread all extra options as contract's contract instance: remove unnecessary setOptions function remove contractDecodeData as extra wrapper remove contractEncodeCall as extra wrapper don't accept ak_ addresses as hash, bytes and signature transformation: drop extra wrapper around bindings transformation: don't export extra functions drop unnecessary skipTransformDecoded option drop unnecessary skipArgsConvert option","title":"\u26a0 BREAKING CHANGES"},{"location":"CHANGELOG/#features_1","text":"aci: don't require source code ( 5c690d2 ) aens: don't limit pointer keys ( f6b8999 ) aens: enable commitmentHash preclaim in tests ( 5de05e5 ) decode using calldata package ( 2bb494d ) encode using calldata package ( eeebbd5 ) poll-interval: reduce poll interval to be a more sensible default ( 9e55b2b ) support for new node feature next-nonce of release 6.2.0 ( #1299 ) ( e40b046 )","title":"Features"},{"location":"CHANGELOG/#bug-fixes_2","text":"commitlint issue ( 2c1cf54 ) compiler errors: construct error message by server response ( 8621352 ) don't accept ak_ addresses as hash, bytes and signature ( cbaac62 ) events: don't require function name for events decoding ( f963bdb ) events: fix event decoding order and address prefix ( faad530 ) events: fix test for incorrect address return type ( 31aaeec ) events: ignore unknown events in decoding ( 45795fa ) node errors: construct error message by server response ( d556936 ) semverSatisfies: ignore build number ( c3cce0a ) swagger: detection of empty response ( 9bfab02 ) contract instance: remove unnecessary setOptions function ( b88e767 ) contract instance: thread all extra options as contract's ( 10fb7ba ) crypto: remove unused asymmetric encode/decode functions ( 51def34 ) drop unnecessary skipArgsConvert option ( 6d4a599 ) drop unnecessary skipTransformDecoded option ( bb49239 ) inline getConsensusProtocolVersion function ( 75f0447 ) invert and rename forceCodeCheck option to validateByteCode ( 72122fa ) make contractCall/Static a wrapper around getContractInstance ( c4ec019 ) make contractDeploy a wrapper, remove unused code ( 48d36f9 ) remove contractDecodeData as extra wrapper ( 5df2285 ) remove contractEncodeCall as extra wrapper ( a4b303f ) require compiler 6 and above ( f9cef12 ) specify browserlist to better choice of features to transpile ( c2ec71a ) transformation: don't export extra functions ( fa38b40 ) transformation: drop extra wrapper around bindings ( 9b70f8e )","title":"Bug Fixes"},{"location":"CHANGELOG/#1000-beta1-2021-11-24","text":"","title":"10.0.0-beta.1 (2021-11-24)"},{"location":"CHANGELOG/#breaking-changes_2","text":"specify browserlist to better choice of features to transpile aci: don't require source code make contractDeploy a wrapper, remove unused code inline getConsensusProtocolVersion function invert and rename forceCodeCheck option to validateByteCode require compiler 6 and above make contractCall/Static a wrapper around getContractInstance contract instance: thread all extra options as contract's contract instance: remove unnecessary setOptions function remove contractDecodeData as extra wrapper remove contractEncodeCall as extra wrapper don't accept ak_ addresses as hash, bytes and signature transformation: drop extra wrapper around bindings transformation: don't export extra functions drop unnecessary skipTransformDecoded option drop unnecessary skipArgsConvert option","title":"\u26a0 BREAKING CHANGES"},{"location":"CHANGELOG/#features_2","text":"aci: don't require source code ( 5c690d2 ) decode using calldata package ( 2bb494d ) encode using calldata package ( eeebbd5 ) poll-interval: reduce poll interval to be a more sensible default ( 9e55b2b ) support for new node feature next-nonce of release 6.2.0 ( #1299 ) ( e40b046 ) aens: enable commitmentHash preclaim in tests ( 5de05e5 )","title":"Features"},{"location":"CHANGELOG/#bug-fixes_3","text":"compiler errors: construct error message by server response ( 8621352 ) events: fix event decoding order and address prefix ( faad530 ) events: fix test for incorrect address return type ( 31aaeec ) node errors: construct error message by server response ( d556936 ) semverSatisfies: ignore build number ( c3cce0a ) commitlint issue ( 2c1cf54 ) don't accept ak_ addresses as hash, bytes and signature ( cbaac62 ) drop unnecessary skipArgsConvert option ( 6d4a599 ) drop unnecessary skipTransformDecoded option ( bb49239 ) inline getConsensusProtocolVersion function ( 75f0447 ) invert and rename forceCodeCheck option to validateByteCode ( 72122fa ) make contractCall/Static a wrapper around getContractInstance ( c4ec019 ) make contractDeploy a wrapper, remove unused code ( 48d36f9 ) remove contractDecodeData as extra wrapper ( 5df2285 ) require compiler 6 and above ( f9cef12 ) specify browserlist to better choice of features to transpile ( c2ec71a ) contract instance: remove unnecessary setOptions function ( b88e767 ) contract instance: thread all extra options as contract's ( 10fb7ba ) remove contractEncodeCall as extra wrapper ( a4b303f ) transformation: don't export extra functions ( fa38b40 ) transformation: drop extra wrapper around bindings ( 9b70f8e )","title":"Bug Fixes"},{"location":"CHANGELOG/#901-2021-10-04","text":"","title":"9.0.1 (2021-10-04)"},{"location":"CHANGELOG/#refactoring","text":"Remove channel from universal stamp ( 63e88ce74 )","title":"Refactoring"},{"location":"CHANGELOG/#900-2021-09-30","text":"","title":"9.0.0 (2021-09-30)"},{"location":"CHANGELOG/#breaking-changes_3","text":"drop following AENS delegation signature methods over the new common createAensDelegationSignature implementation which accepts an object as param ( 456fe00 ) delegateNamePreclaimSignature delegateNameClaimSignature delegateNameTransferSignature delegateNameRevokeSignature drop following oracle delegation signature methods over the new common createOracleDelegationSignature implementation accepts an object param ( 88b7bf3 ) delegateOracleRegisterSignature delegateOracleExtendSignature delegateOracleRespondSignature drop assertedType , use decode instead ( 00d563f ) drop waitMined static method ( 2f299de ) tx-validator now gives different, more meaningful, errors ( 95a2a23 ) no longer exports buildHash function, use hash or buildTxHash ( 9e1fde7 ) tx-verification is now done by default ( 989b36f )","title":"\u26a0 BREAKING CHANGES"},{"location":"CHANGELOG/#features_3","text":"payForTransaction method ( fbf204d ) don't check is GA if innerTx ( 0ee9db4 ) don't sent to blockchain if innerTx ( 523e9bb ) deposit-trap: enforce zero value for deposit during contract deploy ( cfb5f22 )","title":"Features"},{"location":"CHANGELOG/#maintenance","text":"change default gas limit to 25000 ( 831e4dd )","title":"Maintenance"},{"location":"CHANGELOG/#bug-fixes_4","text":"AENS: name length minimum bid fee ( db6ca4c ) delegate-signature: stop using the default account in the context of signing ( 29d760e ) mustAccountStamp: process accounts only if supplied ( 10ec2c3 ) swagger https issue ( 3a876bb ) tx serialisation: accept unpackTx output produced by deserialisator ( ff0b3f5 )","title":"Bug Fixes"},{"location":"CHANGELOG/#821-2021-06-21","text":"","title":"8.2.1 (2021-06-21)"},{"location":"CHANGELOG/#bug-fixes_5","text":"swagger file of aeternity's compiler ( 4001e64 ) swagger file of aeternity's latest compiler ( a1caa03 )","title":"Bug Fixes"},{"location":"CHANGELOG/#820-2021-06-17","text":"","title":"8.2.0 (2021-06-17)"},{"location":"CHANGELOG/#breaking-changes_4","text":"crypto: remove outdated generateSaveWallet function crypto: remove unused prepareTx, encodeTx, decodeTx functions crypto: remove unused hexStringToByte function crypto: rename messageToBinary to messageToHash adding hashing crypto: drop extra \"personal\" from message functions crypto: remove unused formatAddress function crypto: remove unused addressToHex function node-pool: inline helpers, export by default string: use isAddressValid instead of isAeAddress string: remove unused snakeOrKebabToPascal function drop outdated protocols and transactions schemas drop compatibility with node@5","title":"\u26a0 BREAKING CHANGES"},{"location":"CHANGELOG/#bug-fixes_6","text":"export aepp-wallet-communication ( d5d741c ) ponyfill Buffer in browser ( 953bf08 ) ponyfill process in browser ( 798ab63 ) rlp: import as it is ( 736b0f5 ) typo name of broadcast failed error generator ( ae7e823 ) examlple-aepp: open only when ready to accept connection ( 4872eb9 ) crypto: drop extra \"personal\" from message functions ( 34288cb ) crypto: remove outdated generateSaveWallet function ( 37298be ) crypto: remove unused addressToHex function ( 93f9def ) crypto: remove unused formatAddress function ( a5d4b62 ) crypto: remove unused hexStringToByte function ( ed39a76 ) crypto: remove unused prepareTx, encodeTx, decodeTx functions ( 64d15eb ) crypto: rename messageToBinary to messageToHash adding hashing ( df37004 ) node-pool: inline helpers, export by default ( ed1cfb5 ) string: remove unused snakeOrKebabToPascal function ( 79bdc04 ) string: use isAddressValid instead of isAeAddress ( ac7d827 ) drop compatibility with node@5 ( f5e2fdb ) drop outdated protocols and transactions schemas ( f18d305 )","title":"Bug Fixes"},{"location":"CHANGELOG/#810-2021-05-31","text":"","title":"8.1.0 (2021-05-31)"},{"location":"CHANGELOG/#bug-fixes_7","text":"poi-tx schema: use proper type name ( 9e7c7b2 ) wait-for-tx-confirm: validate transaction height after awaitHeight ( 95e0d93 )","title":"Bug Fixes"},{"location":"CHANGELOG/#features_4","text":"support compiler@6.0.0 and above ( 3cdc7f9 )","title":"Features"},{"location":"CHANGELOG/#800-2021-05-18","text":"","title":"8.0.0 (2021-05-18)"},{"location":"CHANGELOG/#bug-fixes_8","text":"avoid instanceof between possible not/polyfilled objects ( 906ee0e )","title":"Bug Fixes"},{"location":"CHANGELOG/#800-beta2-2021-05-12","text":"","title":"8.0.0-beta.2 (2021-05-12)"},{"location":"CHANGELOG/#bug-fixes_9","text":"revert conversion of case in calls to compiler ( 0a69e49 )","title":"Bug Fixes"},{"location":"CHANGELOG/#maintenance_1","text":"avoid ts definitions based on broken JsDoc ( 572d19f )","title":"Maintenance"},{"location":"CHANGELOG/#800-beta1-2021-05-6","text":"","title":"8.0.0-beta.1 (2021-05-6)"},{"location":"CHANGELOG/#important-changes","text":"Iris compatibility (compatible with nodes >= 5.2.0 < 7.0.0) initial TypeScript support (not enough type definitions yet) documentation is generated using MkDocs on Travis","title":"Important changes"},{"location":"CHANGELOG/#breaking-changes_5","text":"Drop old aepp-wallet RPC interface ( 254f5a93 ) refactor: don't retrieve account from process.env ( 59e5c9b5 ) refactor(crypto): don't reexport RLP methods ( c6004bc7 ) refactoring: remove legacy contractDecodeDataAPI compiler method ( dfadac8d ) refactor: rename forceCompatibility to more clear ignoreVersion ( 72f1d326 ) refactoring: require compiler above or equal to 4.1.0 ( c9f48f91 ) RpcClient: Drop unnecessary action stuff ( 84545fd7 ) Combine RpcWallet and RpcClients ( 12892002 ) Drop old names support, split ensureNameValid and isNameValid ( 315a78a9 ) refactor(contract-aci): export single function instead of stamp ( 091b3282 ) Combine Accounts and Selector into AccountMultiple ( 0cacd3b3 ) Use swagger-client instead of a custom implementation ( 4b3260d5 ) Remove OracleNodeAPI wrapper ( c6f9a76d ) Flatten options of contractCallStatic, remove extra dryRunContractTx ( f3ffb664 ) txDryRun: Simplify arguments, support txEvents option ( 401c53da ) contracts: Mark handleCallError as private, simplify arguments ( bdf76e24 ) import/no-named-as-default linter error ( d63e1511 ) oracle: make pollForQueries a sync function ( dc955e14 ) chore: drop aevm support and backend (compiler) option ( 6eb702dd ) refactor(schema): export enum with consensus protocol versions ( e92f187d )","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#features_5","text":"swagger: allow to provide external specification ( 683082b3 ) swagger: make compatible with OpenAPI 3 ( 1d83f1a4 ) switch to v3 endpoints on Iris ( eca6697b ) traverse-keys: add keysOfValuesToIgnore option as a workaround ( 8ff5afe4 ) Use es modules version in browser if supported ( b49c38f0 ) Add typescript support ( abde033a )","title":"Features"},{"location":"CHANGELOG/#docs","text":"contract: fix default backend value ( 9fcbeb32 ) wallet-iframe: fix disconnect button ( 59014bd0 ) examples-browser: rearrange files and docs ( 985e3b96 ) use relative links between docs pages ( d34d8181 ) remove outdated aecrypto example ( 7df05bfe ) refactor node examples ( e8c443cf ) changelog: add missed single quote in example ( 45fd0002 ) resolveName: Document verify option ( ca865596 ) Remove outdated docs ( cf9c166f ) decodeTx: Fix arg naming and annotation ( 883819c0 ) contract-events: Remove outdated contract, update links and markup ( 37d39d61 ) Update docs/guides/import-nodejs.md ( 9dc274ed ) Update docs/guides/import-nodejs.md ( 93bfce11 ) break down json obj keys necessary for account initialization in nodejs docs ( af5ee41d ) Ignore pycache in the docs folder ( 9989e8e7 ) Specify the python version more precisely ( d6204523 ) Add pycache to .gitignore ( f0b7e1f1 ) Add navigation and update some titles ( 8ad15ced ) docco template: Remove extra new lines around code, skip extra blocks ( 65ce3cf1 ) aecontract: Make a list out of a long sentence ( 8ff7839c ) aens-usage: Use more semantic markup, compatible with mkdocs ( de3d3cd5 ) docs readme: Fix typos and formatting ( 5b0c790d ) Add initial mkdocs and readthedocs configuration ( b688a96b ) Extract quick-start to guides ( 28f7e6f7 ) Update testnet URL ( 7bb823f8 ) assertedType: Make the last parameter more obvious ( 50094d3a ) travis: Build docs to gh-pages ( 7c935a2b ) Docs root: Add link to API reference ( 4a36102d ) Move outdated disclaimer to the root readme ( 80a6a663 ) Remove generated docs ( fd802b00 ) Fix api docs generation ( 56e3aa9d )","title":"Docs"},{"location":"CHANGELOG/#code-refactoring","text":"use BigNumber constructor instead of custom wrapper ( 4488b4d7 ) avoid extra object nesting ( f99d3045 ) compiler: use swagger file ( 0d821614 ) semver-satisfies: remove extra splitting by dash ( 35d5c11a ) remove extra char in regex ( 37eeefae ) refactor wallet detector ( 1bc8d027 ) shareWalletInfo: Don't create unnecessary copy of info ( 3a4e50b9 ) Inline receive helper that is used once ( a4a13889 ) rpc: Inline helpers used once ( 21903f4d ) rpc: Prefer default export ( 70fc3f0f ) rpc helpers: Remove unused getWindow function ( c12b528f ) don't use AsyncInit where it is not necessary ( 84373697 ) contract-aci: reuse defaults from Contract stamp ( 47013962 ) cleanup MIN_GAS_PRICE ( a5b28842 ) remove unused option string ( 0e28af23 ) remove unused dryRunAccount default option ( 8c42b706 ) Consistent new on Error creation ( 39f93d3f ) height: Use a shorter syntax ( b013bf9d ) height: Improve naming of internal promise ( 7915119a ) Move source code to \"src\" folder ( ddbce389 ) sign-using-ga: don't pass extra options ( 44bab6d0 )","title":"Code Refactoring"},{"location":"CHANGELOG/#bug-fixes_10","text":"traverse-keys: add missed null check ( 7b724b86 ) swagger: add workaround to get transaction details of GAAttachTx ( bb7ec479 ) top-block: use getTopHeader on Iris, mark deprecated ( 2b410257 ) nonce-verification: add missed space ( 3f244dfb ) missed aepp id in wallet connect handler ( 1ed9284a ) get-node-info: bring url and internalUrl back ( e984f3b3 ) contract error decoding ( d56931ac ) contract-aci: don't proxy prepareArgsForEncode from helpers ( 7e40eda0 ) Improve handling of call error ( 584eb5e4 )","title":"Bug Fixes"},{"location":"CHANGELOG/#maintenance_2","text":"Use ts-standard instead of standard ( be5aece7 ) tsconfig: Set target version to es5 ( ed131b1b ) Fix eslint errors manually ( dfe3a05e ) require node below 7.0.0 ( ae1a5ef5 ) require node above or equal to 5.2.0 ( ebb36f06 ) update dependencies ( d876cff7 ) deps: bump ssri from 6.0.1 to 6.0.2 ( e0dfb8c9 ) deps: bump y18n from 4.0.0 to 4.0.1 ( 9e4acd61 ) deps: bump elliptic from 6.5.3 to 6.5.4 ( feb3aa68 ) deps: bump axios from 0.19.2 to 0.21.1 ( 0f619f27 ) deps: bump ini from 1.3.5 to 1.3.7 ( 95580324 ) deps: bump highlight.js from 10.4.0 to 10.4.1 ( 9fcfadfe ) deps: bump highlight.js from 10.1.1 to 10.4.0 ( 43aff25f ) deps: bump node-fetch from 2.6.0 to 2.6.1 ( 80ed6d70 ) Update node to 5.8.0 ( b6ff3422 ) Update .gitignore ( 1f1563dc ) add vscode .history folder to gitignore ( f4d61df4 ) Update testnet URL in JS files ( dc1b807a ) add Iris consensus protocol ( 41fd4a13 ) add vsn 2 version of GA_META transaction ( b5abe098 ) add new versions of CHANNEL, CHANNEL_CREATE transactions ( 366981a3 ) support compilers below 6.0.0 ( 876e5164 )","title":"Maintenance"},{"location":"CHANGELOG/#performance","text":"Optimize height queries ( f74ca4cb )","title":"Performance"},{"location":"CHANGELOG/#tests","text":"simplify GA tests ( 7b9628c2 ) oracle: avoid explicit waiting for 1 second ( f81cd3a1 ) passing of forceCompatibility flag ( 6f900b98 ) contract: remove extra backend option ( 184566f9 ) update channel tests to fate ( 35a996d8 ) Faster tests ( 5d629103 ) Extract strings tests into separate file ( f3c7d3fa ) ga: Remove extra await ( 72bfc746 ) Make tests more precise ( fe7a8567 )","title":"Tests"},{"location":"CHANGELOG/#770-2020-08-18","text":"","title":"7.7.0 (2020-08-18)"},{"location":"CHANGELOG/#features_6","text":"transferFunds: Accept onAccount option ( #1060 ) bigNumberToByteArray: Avoid unexpected behaviour by throwing exception ( #1066 ) example: Add disconnect button on wallet side ( #1056 )","title":"Features"},{"location":"CHANGELOG/#code-refactoring_1","text":"Use external version of json-bigint ( #1033 ) Make tests configuration more flexible ( #1037 ) test-else: Exclude aens tests and speedup jobs ( #1040 ) Avoid unnecessary eslint-disable ( #1043 ) Add lint script ( #1045 ) Refactor tests ( #1039 ) Refactor bytes unit tests ( #1050 ) travis: Run linter and unit tests firstly ( #1051 ) Disable Travis on all branches except master, develop ( #1054 ) Refactor contract, oracle, chain ( #1048 ) Refactor state channels ( #1047 )","title":"Code Refactoring"},{"location":"CHANGELOG/#docs_1","text":"Fix typo in Readme.md ( #1053 )","title":"Docs"},{"location":"CHANGELOG/#760-2020-07-22","text":"","title":"7.6.0 (2020-07-22)"},{"location":"CHANGELOG/#features_7","text":"wallet-detector: allow to connect wallet to aepp between iframes ( 3f74a05 )","title":"Features"},{"location":"CHANGELOG/#750-2020-06-18","text":"","title":"7.5.0 (2020-06-18)"},{"location":"CHANGELOG/#features_8","text":"Account: Build signature from transaction hash ( #1025 ) ( 2cb8cc2 ) ACI: External contract integration ( #1027 ) ( a14d13a )","title":"Features"},{"location":"CHANGELOG/#refactor","text":"Deps: Clean up repository ( #1029 ) Env: Simplify Travis and docker-compose ( #1031 ) Env: Remove unused packages ( #1032 )","title":"Refactor"},{"location":"CHANGELOG/#742-2020-06-10","text":"","title":"7.4.2 (2020-06-10)"},{"location":"CHANGELOG/#bug-fixes_11","text":"AEX-2: Handler always as Promise ( #1018 ) ( a8b0aab )","title":"Bug Fixes"},{"location":"CHANGELOG/#refactor_1","text":"AEX-2: Add debug option for getHandler . Hide unknown message logs ( #1021 ) ( 22c452c ) Contract Add AENS name resolver for Contract API","title":"Refactor"},{"location":"CHANGELOG/#741-2020-05-30","text":"","title":"7.4.1 (2020-05-30)"},{"location":"CHANGELOG/#bug-fixes_12","text":"AEX-2: Fix isExtensionContext check ( #1011 ) ( 814f99b )","title":"Bug Fixes"},{"location":"CHANGELOG/#740-2020-05-29","text":"","title":"7.4.0 (2020-05-29)"},{"location":"CHANGELOG/#bug-fixes_13","text":"AEX-2: Fix getBrowserAPI helper for cross-browser compatibility ( #1007 ) ( 98b0e29 )","title":"Bug Fixes"},{"location":"CHANGELOG/#features_9","text":"ACI: Event decoding ( #1006 ) ( 6b8e6fe )","title":"Features"},{"location":"CHANGELOG/#731-2020-05-25","text":"","title":"7.3.1 (2020-05-25)"},{"location":"CHANGELOG/#improvements","text":"AEX_2: Handle network switch and update state on both sides. Adjust networkId check for signing request. Add node switcher for example apps ( #996 )","title":"Improvements"},{"location":"CHANGELOG/#730-2020-05-20","text":"","title":"7.3.0 (2020-05-20)"},{"location":"CHANGELOG/#bug-fixes_14","text":"example: Regenerate lock ( #960 ) ( 5b6a30e )","title":"Bug Fixes"},{"location":"CHANGELOG/#features_10","text":"ACI: expose events decoding through Contract ACI stamp ( #971 ) ( 4930635 ) AEX_2: Allow to connect without node ( #991 ) ( 87b9ef9 ) AEX_2: Connect to extension from iframe ( #992 ) ( 47179f7 ) Build: Expose ACIHelpers and ACITransformation to bundle ( #970 ) ( 8b475e0 ) Chain: Add option allowUnsynced for poll method which allow to depend on get tx/info API ( 9c80ce0 ) Channel: add timeout message handler ( #983 ) ( 1940a15 ) Channel: Channel force progress ( #964 ) ( 8f15bef ) Contract: Add unpacked transaction to contract call with error ( #981 ) ( 4efd341 ) Node: Add debug option to Channel stamp ( #967 ) ( 68fcba5 )","title":"Features"},{"location":"CHANGELOG/#721-2020-03-25","text":"","title":"7.2.1 (2020-03-25)"},{"location":"CHANGELOG/#fix","text":"build Remove resolving of minimist using npx","title":"Fix"},{"location":"CHANGELOG/#720-2020-03-24","text":"","title":"7.2.0 (2020-03-24)"},{"location":"CHANGELOG/#docs_2","text":"Guide: Adjust guide for RPC Wallet/Aepp usage","title":"Docs"},{"location":"CHANGELOG/#code-refactoring_2","text":"RPC: Refactor rpc-related stuff ( #921 ) Build: Include amountFormatter and SCHEMA in bundle( #936 ) Examples Update examples apps","title":"Code Refactoring"},{"location":"CHANGELOG/#features_11","text":"TX: Introduce new stamp TxObject ( #933 ) This stamp give more flexibility on transaction serialization/deserialization process Keystore: Allow to store secret as hex or buffer ( #939 ) AEX-2: Add permission layer for account management ( #937 )","title":"Features"},{"location":"CHANGELOG/#711-2020-02-27","text":"","title":"7.1.1 (2020-02-27)"},{"location":"CHANGELOG/#bug-fixes_15","text":"TxBuilder: Fix fee calculation for Oracles ( #924 ) ( a9d784f ) AEX-2: Broken wallet detection ( #926 )","title":"Bug Fixes"},{"location":"CHANGELOG/#710-2020-02-25","text":"","title":"7.1.0 (2020-02-25)"},{"location":"CHANGELOG/#refactor_2","text":"AEX: Simplify message id processing ( #916 ). Pass AEEP origin to Wallet callback ( #918 ) Node: Move getNetworkId to helpers ( #910 ) ACI: Minor ACI validation improvement. Move decoding of events to builder. Add ability to decode events without ACI","title":"Refactor"},{"location":"CHANGELOG/#features_12","text":"ACI: Implement Contract Events for ACI( Contract Event Guide ) Contract: Helpers for Oracle and AENS signature delegation( Signature delegation guide ) AmountFormatter: Rework amount formatter. Change formatter units naming. Add more units ( #909 ) ( 6970efe ) TxBuilder: Integrate amount formatter to transaction builder ( #897 ) Account: Implement Message Signing ( singMessage , verifyMessage ) ( #903 ) AEX-2: Add removeRpcClient method to RpcClient/RpcWallet stamp's( #912 )","title":"Features"},{"location":"CHANGELOG/#700-2020-01-31","text":"","title":"7.0.0 (2020-01-31)"},{"location":"CHANGELOG/#bug-fixes_16","text":"AEX-2: Fix firefox compatibility issue ( #882 ) ( 2e16e10 )","title":"Bug Fixes"},{"location":"CHANGELOG/#features_13","text":"Chain: add new method waitFOrTxConfirm . Add new option { confirm: 3 } to all of high lvl SDK API. Add tests. Adjust docs ( #874 ) ( 43528f9 ) Compiler: Add new compiler methods API ( #875 ) ( a939395 ) network: Throw error when can not get networkId ( #863 ) ( 41b7bd1 )","title":"Features"},{"location":"CHANGELOG/#docs_3","text":"Guide Add 7.0.0 migration guide Guide: Add Oracle , AENS and Contract guides","title":"Docs"},{"location":"CHANGELOG/#breaking-changes_6","text":"Please check out 7.0.0 migration guide This release include all changes from 7.0.0-next.1 , 7.0.0-next.2 , 7.0.0-next.3","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#700-next3-2020-01-22","text":"","title":"7.0.0-next.3 (2020-01-22)"},{"location":"CHANGELOG/#features_14","text":"aens: implement aensExtendTtl function. Refactor aensUpdate ( #866 ) ( 72b073a ), closes #865 aensUpdate now accept array of pointers aensUpdate have new option extendPointers=false which retrieve pointers from the node and merge with provided Build: update node to 5.4.0 and compiler to 4.2.0 Guide Add guide for AENS usage","title":"Features"},{"location":"CHANGELOG/#breaking-changes_7","text":"AENS: Change AENS methods arguments Now all of AENS module methods accept name as a first argument instead of nameId","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#700-next2-2020-01-10","text":"","title":"7.0.0-next.2 (2020-01-10)"},{"location":"CHANGELOG/#bug-fixes_17","text":"codecov: Adjust codecov badge. Move @babel/runtime to dev-deps ( #848 ) ( 109b851 ) AEX-2: Fix getBrowserAPI function for firefox ( #853 )","title":"Bug Fixes"},{"location":"CHANGELOG/#features_15","text":"Account: Add ability to pass keypair or MemoryAccount as nAccount` option ( #847 ) ( 75d8ad8 ) Test: Increase code coverage ( #830 ) ( 6f760fb ) Chain: Extend transaction verification error ( #849 ) Aepp<->Wallet: Add tests for Aepp<->Wallet communication ( #834 )","title":"Features"},{"location":"CHANGELOG/#documentation","text":"Guide: Add guide for Contract ACI usage ( #852 )","title":"Documentation"},{"location":"CHANGELOG/#700-next1-2019-12-18","text":"","title":"7.0.0-next.1 (2019-12-18)"},{"location":"CHANGELOG/#bug-fixes_18","text":"Contract/Chain: Using { waitMined: false } with Contract high lvl API ( #828 ) ( 475c2aa ) HdWallet: Fix derive function ( #801 ) ( 6c6177d ) Compiler: Filter compiler options","title":"Bug Fixes"},{"location":"CHANGELOG/#code-refactoring_3","text":"Cross-Node: Remove cross-node compatibility code ( #829 ) ( b29a162 ) Chain: Handle time until tx is not added to mempool ( #816 ) Git: Update issue template( #806 ) Flavors: Remove deprecated code ( #697 ) Test: Increase code covarage ( #830 ) ( 6f760fb )","title":"Code Refactoring"},{"location":"CHANGELOG/#features_16","text":"Wallet<->AEPP: Add new Wallet<->Aepp communication API Add two new stamps RpcWallet and RpcAepp Example of usage you can find heere: Aepp example and Wallet example Wallet: Use postMessage for communication with extension wall\u2026 ( #815 ) ( dc7b4c2 ) CI: Move to Travis CI ( #809 ) ( 2d77f20 ) CI: enable daily builds on latest node and compiler and enable codecov ( #820 ) ( 3c52a1e ) ACI: Add check for contract address validity and existence. Add forceCodeCheck option for bytecode verification skip ( #788 ) ( c0cccc9 ) Contract: Add ability to pass arguments or callData for contract deploy/call/callStatic API ( #768 ) ( a828076 ) Contract: Adjust fee calculation for contractCall tx using FATE backend ( #793 ) ( 7254ac1 ) Compiler: Add new API validateByteCodeAPI available on compiler >= 4.1.0 ( #788 ) ( c0cccc9 ) Tx: Always verify transaction before send it to the node ( #798 ) ( 170f479 )","title":"Features"},{"location":"CHANGELOG/#breaking-changes_8","text":"Tx: By default sdk make a transaction verification Node: Change node compatibility range to node >= 5.0.0 && node < 6.0.0 Compiler: Drop compiler version to version >= 4.0.0 && version < 5.0.0 ACI: Add additional method to RPC communication. Required sdk update on wallet side Add getContractByteCode API Flavor: Remove deprecated params: remove url and internalUrl instead use nodes: [ { name: 'NODE_NAME', instance: await Node({ url, internalUrl }) } ] remove keypair params instead use accounts: [MemmoryAccount({ keypair })] remove setKeypair function from Account stamps","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#613-2019-12-11","text":"","title":"6.1.3 (2019-12-11)"},{"location":"CHANGELOG/#bug-fixes_19","text":"Channel: 5.2.0 compatibility ( 4be8eb8 )","title":"Bug Fixes"},{"location":"CHANGELOG/#612-2019-11-12","text":"","title":"6.1.2 (2019-11-12)"},{"location":"CHANGELOG/#bug-fixes_20","text":"Composition: Chain composition ( 9ac705f )","title":"Bug Fixes"},{"location":"CHANGELOG/#611-2019-11-12","text":"","title":"6.1.1 (2019-11-12)"},{"location":"CHANGELOG/#bug-fixes_21","text":"ACI: Disable bytecode check for source and code on-chain. This changes will be included in next major release ( #783 ) ( fe6021b )","title":"Bug Fixes"},{"location":"CHANGELOG/#features_17","text":"KeyStore: Remove argon2 package, use libsodium for both browser and node ( #782 ) ( c18047e )","title":"Features"},{"location":"CHANGELOG/#610-2019-11-11","text":"","title":"6.1.0 (2019-11-11)"},{"location":"CHANGELOG/#bug-fixes_22","text":"AENS: auction end block calculation ( #746 ) ( 4c1f5e4 ) AENS: Fix produceNameId function(Make name lowercase). Enable \u2026 ( #750 ) ( fd14225 ) state channels: wait for connection to be established before sending generic message ( #723 ) ( c5f35d1 ) TxHelpers: Use BigNumber in auction end block calculation ( 777c012 )","title":"Bug Fixes"},{"location":"CHANGELOG/#features_18","text":"ACI: Add validation for contractAddress ( #764 ) ( 07cb0e7 ) AENS: Add nameFee validation to TxValidator ( #765 ) ( 5250e75 ) AENS: Increase default nameTtl ( #775 ) ( c5f2582 ) Contract: Add ability to pass arguments or callData for contract deploy/call/callStatic API ( #768 ) ( 12aaca3 ) Http: Assign error object to http error ( #770 ) ( 87062ea ) state channels: add round method ( #763 ) ( c950937 ) state channels: allow off chain updates to be cancelled with custom error code ( #753 ) ( ae4426e ) state channels: allow to pass metadata to transfer update ( #755 ) ( ddc6611 ) state channels: make state channels compatible with node v5.0.0\u2026 ( #688 ) ( deed7fc ), closes #632 #653 #658 #660 #680 #693 #687 state channels: make state channels compatible with node v5.1.0\u2026 ( #776 ) ( 74952aa )","title":"Features"},{"location":"CHANGELOG/#602-2019-10-31","text":"","title":"6.0.2 (2019-10-31)"},{"location":"CHANGELOG/#bug-fixes_23","text":"name claim: Revert ignoring waitMined from user passed options (#727)","title":"Bug Fixes"},{"location":"CHANGELOG/#601-2019-10-29","text":"","title":"6.0.1 (2019-10-29)"},{"location":"CHANGELOG/#bug-fixes_24","text":"aens: added lower case transformation for aens names ( #730 ) ( f7f9f17 ), closes #728","title":"Bug Fixes"},{"location":"CHANGELOG/#600-2019-10-16","text":"","title":"6.0.0 (2019-10-16)"},{"location":"CHANGELOG/#code-refactoring_4","text":"SPEND: Add additional validation for recipient ( #715 ) ( c1854bf )","title":"Code Refactoring"},{"location":"CHANGELOG/#features_19","text":"State Channels: make state channels compatible with node v5.0.0\u2026 ( #688 ) ( 23936f5 ), closes #632 #653 #658 #660 #680 #693 #687 AENS: Change tld for Lima from aet to chain ( #714 ) ( 323ef6a ) AENS: Implement name bid function ( #706 )) AENS: auction name fee calculation. Name fee validation and calculation in claim/bid ( #706 ) AENS: Add nameId computation function (#709) ( #706 )","title":"Features"},{"location":"CHANGELOG/#breaking-changes_9","text":"AENS: Change tld for Lima from .aet to .chain","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#500-2019-10-04","text":"","title":"5.0.0 (2019-10-04)"},{"location":"CHANGELOG/#bug-fixes_25","text":"rpc: fix resolution rpc ops ( #669 ) ( abd7c56 )","title":"Bug Fixes"},{"location":"CHANGELOG/#code-refactoring_5","text":"ACI: rework Sophia Option type representation ( #691 ) ( 0dbb2fe )","title":"Code Refactoring"},{"location":"CHANGELOG/#features_20","text":"AENS: Add ability to spend by name ( #682 ) ( 0d43804 ) AENS: Add ability to claim contract, oracle, SC ( #671 ) ( 49fd0fd ) GA: enbale GA ( #692 ) ( eded912 ) Lima: Lima compatibility ( #683 ) ( a88042e ), closes #632 #653 #658 #660 #680 #693 #687 AENS auction support compiler 4.0.0 support node 5.0.0 support SDK use FATE for contract by default AE : Add pointers verification for spend by name","title":"Features"},{"location":"CHANGELOG/#breaking-changes_10","text":"aci: Change Sophia option type representation in ACI // from await contract . methods . optionFn ( Promise . resolve ( 1 ) || Promise . reject ()) // to await contract . methods . optionFn ( 1 || undefined )","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#500-next1-2019-09-10","text":"","title":"5.0.0-next.1 (2019-09-10)"},{"location":"CHANGELOG/#bug-fixes_26","text":"package: update serialize-javascript to version 2.0.0 ( #647 ) ( 1ddb392 )","title":"Bug Fixes"},{"location":"CHANGELOG/#features_21","text":"Contract/ACI Add payable feature Compiler: Compiler 4.0.0 compatibility ( #632 ) ( d5f1632 ) Contract/ACI: Add ability to use contract with external namespaces( include \"someLib\" ) ( #653 ) ( 9708b43 )","title":"Features"},{"location":"CHANGELOG/#470-2019-09-11","text":"","title":"4.7.0 (2019-09-11)"},{"location":"CHANGELOG/#features_22","text":"Oracle: Add methods for polling queries #637 Chain: Add getBalance method ( #655 ) ( 15147af ) state channels: add reconnect method ( #662 ) ( 9d8d1e8 ) state channels: add backchannel updates test #664","title":"Features"},{"location":"CHANGELOG/#460-2019-08-28","text":"","title":"4.6.0 (2019-08-28)"},{"location":"CHANGELOG/#bug-fixes_27","text":"Compiler: Fix forceCompatibility option ( 26beba8 )","title":"Bug Fixes"},{"location":"CHANGELOG/#features_23","text":"Lima : add preliminary support for lima ACI/Contract: Implement static-call for deploy transaction for ACI methods/Contract low lvl API ( #630 ) ( 5b7eeb4 )","title":"Features"},{"location":"CHANGELOG/#notes","text":"GA support has been disabled until further notice due to node compatibility issues This version support aeternity node up to 5.0.0-rc.1","title":"Notes"},{"location":"CHANGELOG/#451-2019-08-22","text":"","title":"4.5.1 (2019-08-22)"},{"location":"CHANGELOG/#refactor_3","text":"Example Add node info to AEPP ( #620 )","title":"Refactor"},{"location":"CHANGELOG/#bug-fixes_28","text":"GA Fix GA account composition ( 211e409 )","title":"Bug Fixes"},{"location":"CHANGELOG/#450-2019-08-20","text":"","title":"4.5.0 (2019-08-20)"},{"location":"CHANGELOG/#bug-fixes_29","text":"Crypto: Fix keypair verification ( #605 ) ( 83a52fb ) RPC: Remove NodePool stamp from AE composition ( #612 ) ( 21af2eb ) state channels: add missing argument in onOnChainTx callback ( #604 ) ( 165cfe8 ) state channels: fix awaitingOnChainTx state handler ( #608 ) ( 8b7b65a ) Swagger: Always throw error from axios error handler ( #607 ) ( 0e5cf61 )","title":"Bug Fixes"},{"location":"CHANGELOG/#features_24","text":"MemoryAccount: Add validation of keypair ( #594 ) ( b8c2b20 ) state channels: handle BigNumbers with json-bigint ( #596 ) ( 14eaa3d ) state channels: send generic messages immediately ( #600 ) ( 8ad7583 ) Generalize Account Implement Generalized account support ( #449 ) const authContract = `YOUR_AUTH_CONTRACT` // Make current account Generalized await client . createGeneralizeAccount ( authFnName , authContract , [... authFnArguments ] // Make spend transaction using GA // One Way // encoded call data for auth contract const callData = 'cb_...' await client . spend ( 10000 , receiverPub , { authData : { callData } }) // or // sdk will prepare callData itself await client . spend ( 10000 , receiverPub , { authData : { source : authContract , args : [... authContractArgs ] } })","title":"Features"},{"location":"CHANGELOG/#440-2019-08-09","text":"","title":"4.4.0 (2019-08-09)"},{"location":"CHANGELOG/#bug-fixes_30","text":"Package: update commander to version 3.0.0 ( #597 ) ( 9aaa05c ) Contract: Fix dry-run without account ( 227fc5c )","title":"Bug Fixes"},{"location":"CHANGELOG/#features_25","text":"Contract: add ability to use call-static/dry-run without keyPair ( #577 ) ( c38edd9 ) AE: Add ability to make operation on specific account using onAccount option. Exm: await client.spend(1, receiver, { onAccount: 'PUBLIC_KEY' }) Add `onAccount` to `AENS`, `Contract`, `Oracle`. Add tests for using specific account to Contract, ACI, Account. JSON: : Add serialization to JSON for bigNumbers MemoryAccount: Add validation of keypair ( #594 ) ( b8c2b20 ) State Channels: persist connection by pinging every 10 seconds ( #571 ) ( a70f919 )","title":"Features"},{"location":"CHANGELOG/#430-2019-08-05","text":"","title":"4.3.0 (2019-08-05)"},{"location":"CHANGELOG/#bug-fixes_31","text":"State Channels: Fix onChainTx event params ( #566 ) ( 11c85eb ) State Channels: Fix websocket url ( #558 ) ( 33c1fd8 ) Swagger: Pass query params in case of get request ( #570 )","title":"Bug Fixes"},{"location":"CHANGELOG/#code-refactoring_6","text":"State Channel: Do not include white space for outgoing websocket messages ( #559 )","title":"Code Refactoring"},{"location":"CHANGELOG/#features_26","text":"ACI: Implement sophia variant type ( #567 ) ( 8505dcf ) Contract: add ability to use call-static/dry-run without keyPair ( #577 ) ( c38edd9 ) NodePool: Implement NodePool stamp ( #574 ) ( 674166c ) State Channel: make state channel compatible with aeternity@4.0.0 ( #568 ) ( 0d0e09b ) TxBuilder: Add helper for producing tx hash ( #579 ) ( e1b405e ) AE Make all AE stamps composed with Accounts ( #581 )","title":"Features"},{"location":"CHANGELOG/#docs_4","text":"ACI Add some additional clarification to getContractInstance","title":"Docs"},{"location":"CHANGELOG/#420-2019-07-15","text":"","title":"4.2.0 (2019-07-15)"},{"location":"CHANGELOG/#bug-fixes_32","text":"package: update libsodium-wrappers-sumo to version 0.7.5 ( #541 ) ( 956ed75 ) rpc-server: Fix type 'object' check ( #526 ) ( 48c42e4 )","title":"Bug Fixes"},{"location":"CHANGELOG/#code-refactoring_7","text":"swagger: Speedup initialisation AENS: Remove unused param from claim method AENS: Fix exception if not waiting for mining(claim) Test: Add test for contract namespaces","title":"Code Refactoring"},{"location":"CHANGELOG/#features_27","text":"Node: Add 4.0.0 node compatibility Compiler: Add compatibility with compiler 3.2.0 Channel: Implement GA awareness of State Channels","title":"Features"},{"location":"CHANGELOG/#410-2019-06-22","text":"","title":"4.1.0 (2019-06-22)"},{"location":"CHANGELOG/#bug-fixes_33","text":"Node: Do not throw error if internalUrl not provided. Instead use url ( #503 ) ( 053faae ) TXBuilder: Fix payload serialization if you try to unpack and pack tx. ( #498 ) ( 73552e5 ) TxValidator: Fix validation of state channel open transaction ( #496 ) ( 325cc90 )","title":"Bug Fixes"},{"location":"CHANGELOG/#features_28","text":"ACI: Refactor ACI module. Split to separated files. ( #505 ) ( fb7bc00 ) Selector: If default account address not provided use the first ACI: Handle ACI without init function ACI: Automatically decide to send transaction on-chai or call-static. Add options object like last arguments of generate fn under instance.methods const instance = await client.getContractInstance(source) // Deploy contract await.contract.init(100, 'test', options) //or await.contract.deploy([100, 'test'], options) // Call function const result = await instance.call('sum', [2, 5], options) // // Automatically decide to send tx on-chain or call-static(dry-run) base on if function stateful or not const result = await instance.methods.sum(2, 5, options) // Manually make on-chain const result = await instance.methods.sum.send(2, 5, options) // Manually make call-static const result = await instance.methods.sum.get(2, 5, options) //","title":"Features"},{"location":"CHANGELOG/#docs_5","text":"Usage: : Add instructions about how to include directly the SDK in a html page","title":"Docs"},{"location":"CHANGELOG/#401-2019-06-13","text":"","title":"4.0.1 (2019-06-13)"},{"location":"CHANGELOG/#bug-fixes_34","text":"RPC: Add contract contractDecodeCallResultAPI to RPC ( #482 ) ( 7eb6bd8 ) README: Fix flavor link ( #480 )","title":"Bug Fixes"},{"location":"CHANGELOG/#code-refactoring_8","text":"Compiler: Fix compiler compatibility mechanism ( #479 ) ( 78cc990 ) Utils: Move json-bigint implementation to utils ( #486 ) ( 1538867 )","title":"Code Refactoring"},{"location":"CHANGELOG/#build","text":"webpack: Add another bundle( dist/aepp-sdk.browser-script.js ) for using in <script> tag ( #485 )","title":"Build"},{"location":"CHANGELOG/#400-2019-06-12","text":"","title":"4.0.0 (2019-06-12)"},{"location":"CHANGELOG/#bug-fixes_35","text":"Ae: Fix exception when it used without Contract stamp","title":"Bug Fixes"},{"location":"CHANGELOG/#code-refactoring_9","text":"SCM: Update compatibility range for node: 3.0.1 - 4 and compiler 3.1.0 - 4 ( #474 ) ( a1494fd ) Test: Simplify client creation","title":"Code Refactoring"},{"location":"CHANGELOG/#features_29","text":"Docs chore(Docs): new docs ( #370 ) Compiler: Add getCompilerVersion to compiler stamp ACI: Make compatible with compiler 3.1.0 ( #457 ) ( d92f2c7 ), closes #458 ACI: Generate JS function proto for each of contract function ( #439 ) ( 2f47b4d ) Compiler/ACI: Make ACI compatible with compiler 3.0.0 ( #441 ) ( 2a8eb1a ) Node: Avoid usage of \"universal-url\" package ( #434 ) ( a8268d5 ) TX: encode payload as base64 ( #460 ) ( ad490af ) TX_BUILDER: Fix bug related to contract fee calculation. ( #472 ) ( 7214cfb )","title":"Features"},{"location":"CHANGELOG/#breaking-changes_11","text":"DOCS Restructure and rework sdk documentation SCM: This change will make the release not compatible with older version of the node and compiler ACI: Change Contract low lvl API: change contractDecodeData interface from: (type:String, data: String) => Any to (source: String, fn: String, callValue: String, callResult:String) => Any . ( callResult is callType from call result, can be ok , revert , ...)","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#341-2019-06-05","text":"","title":"3.4.1 (2019-06-05)"},{"location":"CHANGELOG/#bug-fixes_36","text":"Deps: Update axios lib to 0.19.0 due to security issue ( f951765 )","title":"Bug Fixes"},{"location":"CHANGELOG/#340-2019-05-22","text":"","title":"3.4.0 (2019-05-22)"},{"location":"CHANGELOG/#bug-fixes_37","text":"State Channels: Remove automatic pinging to fix browser compatibility ( #432 ) ( 0700f3a )","title":"Bug Fixes"},{"location":"CHANGELOG/#features_30","text":"Transaction Builder: Improve min fee calculation(Reduce the fee) ( #424 ) AXIOS: Add ability to intercept error from axios ( #431 ) Added additional param to sdk initialization axiosConfig Example: Universal({ axiosConfig: { config: { // axios config object }, errorHandler: (err) => throw err }}) * Transaction Builder: Implement vm/abi validation for contract/oracle tx based on consensus protocol version. Add custom verification based on transaction type ( #425 ) ( #426 )","title":"Features"},{"location":"CHANGELOG/#330-2019-05-17","text":"","title":"3.3.0 (2019-05-17)"},{"location":"CHANGELOG/#bug-fixes_38","text":"AEP exampe: Fix contract in AEPP example ( e2fec19 ) fix(AEP exampe): Fix contract in AEPP example","title":"Bug Fixes"},{"location":"CHANGELOG/#features_31","text":"Consensus: Add function to get consensus version. ( #413 ) ( 46027cd ) State Channels: Make state channels compatible with aeternity 3.0.0 ( #415 ) ( 668e7f1 ) Transaction Builder: Add serializations for transactions introd\u2026 ( #416 ) ( fd7b8ce )","title":"Features"},{"location":"CHANGELOG/#breaking-changes_12","text":"NODE Change compatibility from 2.3.0 to 3.0.0","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#321-2019-05-16","text":"","title":"3.2.1 (2019-05-16)"},{"location":"CHANGELOG/#bug-fixes_39","text":"Joi: Add JOI browser comparability","title":"Bug Fixes"},{"location":"CHANGELOG/#320-2019-05-16","text":"","title":"3.2.0 (2019-05-16)"},{"location":"CHANGELOG/#bug-fixes_40","text":"ACI: Add ability to pass zero address as number. ( #396 ) ( b5b5c61 ) ACI: Fix address type transformation when decoding data ( #335 ) ( e37cdfc ) Contract: Add error handling(decoding) in low lvl contract API ( #386 ) ( e1fdce0 ) Dependencies: Use URL class instead of \"url\" package Dependencies: Use custom version of json-bigint Dependencies: Avoid usage of semver package and cleanup deps RPC: rpc client: Handle case if aepp opened without wallet Channels: Fix state channel test's","title":"Bug Fixes"},{"location":"CHANGELOG/#features_32","text":"KEYSTORE: Add browser compatibility TX: Handle VM/ABI fields serialization and validation basaed on tx type and node version ACI: Add contract , address , record types argument/result transformation ( #349 ) ( 0599d7d ) WEBPACK: webpack configs: Mark all dependencies as external WEBPACK: Setup webpack-bundle-analyzer plugin ACI: Add Option sophia type to ACI ( #390 ) ( 83f5279 ) ACI: Implement arguments validation for generic sophia types(list, map, tuple, record) ( #384 ) ( 956e59e ) ACI: Update due to compiler API changes ( #331 ) ( e047f3b ) AE: Allow to spend % of balance. ( #371 ) ( f97a2ae ), closes #336 Aepp: Add Compiler to Aepp rpc methods. Update example app ( #312 ) ( 9c72521 ) Aepp: Refactor Aepp example app. Allow to spend with payload and add reverse iframe approach. Compiler: Add decode CallData by source/bytecode ( #354 ) ( 761f36b ) Fortuna: Node 3.0.0 compatibility ( #397 ) ( 17b78d5 ) RPC: Add getNodeInfo to AEPP stamp through RPC ( #359 ) ( 2ddeea8 ) State Channels: Add cleanContractCalls method ( #338 ) ( 778159a ) State Channels: Ping every 10 seconds to persist connection ( #324 ) ( 6d0e156 ), closes #276 #299 #300 #303 #302 #279 #275 #276 #299 #300 State Channels: Remove endpoint param ( #391 ) ( 8d9ea7e )","title":"Features"},{"location":"CHANGELOG/#breaking-changes_13","text":"State Channels: Endpoint param is removed and no longer defaults to \"/channel\". This means that \"/channel\" (or other path) must be appendend to url para","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#310-2019-04-24","text":"","title":"3.1.0 (2019-04-24)"},{"location":"CHANGELOG/#bug-fixes_41","text":"ACI: Fix address type transformation when decoding data ( #335 ) ( e37cdfc )","title":"Bug Fixes"},{"location":"CHANGELOG/#features_33","text":"ACI: Add contract , address , record types argument/result transformation ( #349 ) ( 0599d7d ) ACI: Update due to compiler API changes ( #331 ) ( e047f3b ) Aepp: Add Compiler to Aepp rpc methods. Update example app ( #312 ) ( 9c72521 ) Compiler: Add decode CallData by source/bytecode ( #354 ) ( 761f36b ) RPC: Add getNodeInfo and getNetworkId to AEPP stamp through RPC ( #359 ) ( 2ddeea8 ) State Channels: Add cleanContractCalls method ( #338 ) ( 778159a ) State Channels: Ping every 10 seconds to persist connection ( #324 ) ( 6d0e156 )","title":"Features"},{"location":"CHANGELOG/#300-2019-04-17","text":"","title":"3.0.0 (2019-04-17)"},{"location":"CHANGELOG/#bug-fixes_42","text":"ACI: Fix address type transformation when decoding data ( #335 ) ( e37cdfc )","title":"Bug Fixes"},{"location":"CHANGELOG/#features_34","text":"TX_BUILDER: Channel tx serializations TxValidator: Add minGasPrice validation to contract transactions ACI: Update due to compiler API changes ( #331 ) ( e047f3b ) Aepp: Add Compiler to Aepp rpc methods. Update example app ( #312 ) ( 9c72521 ) State Channels: Add cleanContractCalls method ( #338 ) ( 778159a )","title":"Features"},{"location":"CHANGELOG/#breaking-changes_14","text":"ACI Remove 2.0.0 compiler compatibility","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#241-2019-04-17","text":"","title":"2.4.1 (2019-04-17)"},{"location":"CHANGELOG/#features_35","text":"ACI: Add transform decoded data for 'address' type AEPP: Add Compiler to Aepp rpc methods. Update example app Channel: Add call contract static support Channel: Add get contract state support Channel: Get full channel state support DOCS: Adjust ACI, Contract and Usage","title":"Features"},{"location":"CHANGELOG/#bug-fixes_43","text":"HTTP: Handle no response in http stamp error handler Crypto: Fix crypto formatAddress Crypto: Move ADDRESS_FORMAT to crypto","title":"Bug Fixes"},{"location":"CHANGELOG/#breaking-changes_15","text":"Channels: channel.state() now returns offchain state instead of last co-signed offchain transaction channel.update(...).state has been renamed to signedTx channel.withdraw(...).state has been renamed to signedTx channel.deposit(...).state has been renamed to signedTx channel.leave().state has been renamed to signedTx channel.createContract(...).state has been renamed to signedTx channel.callContract(...).state has been renamed to signedTx","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#240-2019-04-17","text":"","title":"2.4.0 (2019-04-17)"},{"location":"CHANGELOG/#features_36","text":"Chore: Install and configure commitizen Crypto: Add formatAddress function to Crypto Contract: Add Contract Compiler API stamp to es/contract (now using instead contract node API) Utils: Add basic http client stamp ( es/utils/http ) Contract: ACI stamp (New Contract interface base on contract ACI schema) const contractIns = await client.getContractInstance(contractSourceCode) console.log(contract) { interface: String, // Contract interface source code aci: String, // Contract interface json schema source: String, // Contract source code compiled: String, // Compiled contract code deployInfo: { address: contractAddress } // Object with deploy transaction, // Function compile: () => this, // Compile contract, deploy: (init = [], options = { skipArgsConvert: false }) => this, // Deploy contract (compile before if needed) call: (fn, params = [], options = { skipArgsConvert: false, skipTransformDecoded: false, callStatic: false } => CallRersult: Object // Call contract function } Account: Extend Account.address() with accountFormatter now you can do export const ADDRESS_FORMAT = { sophia: 1, // return address like `0xHEX_ADDRESS` api: 2, // return address like `ak_9LJ8ne9tks78hTD2Tp571f7w2MJmzQMRsiZxKCkMA2d2Sbrc4` } // export { ADDRESS_FORMAT } from 'es/account' await account.address(format: ADDRESS_FORMAT) // default ADDRESS_FORMAT.api Channel: Improve channel rpc usage Channel: Improve channel tests and error handling Channel: Improve state channel params handling Chain: Add ability to get account/balance on specific block hash/height Universal: Add { compilerUrl } to Universal, Contract, Wallet stamp initialization","title":"Features"},{"location":"CHANGELOG/#bug-fixes_44","text":"Contract: decode node error coming from contract call and callStatic Chain: Throw native error instead of object in chain chain.sendTransaction Crypto: fix arguments parsing in Crypto.sing Crypto: Fix name hash function arguments parsing in Crypto","title":"Bug Fixes"},{"location":"CHANGELOG/#breaking-changes_16","text":"Contract: Remove ContractNodeAPI stamp Contract: Change Contract stamp API 1) Use Compiler instead of node API for encode/decode call-data and compile. 2) Change Contract interface: - contractCallStatic (address, abi = 'sophia-address', name, { top, args = '()', call, options = {} } = {}) -> (source, address, name, args = [], { top, options = {} } = {})) - contractCall (code, abi, address, name, { args = '()', options = {}, call } = {}) -> (source, address, name, args = [], options = {}) - contractDeploy (code, abi, { initState = '()', options = {} } = {}) -> (code, source, initState = [], options = {}) - contractEncodeCall (code, abi, name, args, call) -> (source, name, args) // 'source' is -> Contract source code or ACI interface source","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#232-2019-03-04","text":"","title":"2.3.2 (2019-03-04)"},{"location":"CHANGELOG/#features_37","text":"Contract: Change default gasPrice from 1e6 to `1e9z AEPP: Fix AEPP example app Build: Force image pull before builds","title":"Features"},{"location":"CHANGELOG/#231-2019-02-22","text":"","title":"2.3.1 (2019-02-22)"},{"location":"CHANGELOG/#features_38","text":"Oracle: Oracle fee calculation Tx: getAccountNonce function to tx stamp TX_BUILDER: Change FEE_BYTE_SIZE from 1 to 8 bytes in fee calculation TX_BUILDER: Improve error handling in tx builder","title":"Features"},{"location":"CHANGELOG/#230-2019-02-22","text":"","title":"2.3.0 (2019-02-22)"},{"location":"CHANGELOG/#features_39","text":"Node: Minerva comparability Utils: Mnemonic wallet implementation es/utils/hd-wallet Oracle: Change Channel legacy API to JSON RPC Oracle: Change default gasPrice to 1e6 Oracle: Change minFee calculation, multiply min fee by 1e9","title":"Features"},{"location":"CHANGELOG/#breaking-changes_17","text":"Node: Change supported node version range to 1.4.0 <= version < 3.0.0 This release contain changes from: 2.3.0-next , 2.2.1-next , 2.1.1-0.1.0-next , 2.1.0","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#230-next-2019-02-21","text":"","title":"2.3.0-next (2019-02-21)"},{"location":"CHANGELOG/#features_40","text":"Channel: channel withdraw and deposit methods TX_BUILDER: Change default gasPrice in Contract stamp and Tx stamp to 1e9 TX: Fix contract tx fee calculation Chain: Refactor error handling in sendTransaction function Contract: Change default gasPrice to 1e9 TX_BUILDER: Change Fee byte_size to 1","title":"Features"},{"location":"CHANGELOG/#221-next-2019-02-21","text":"","title":"2.2.1-next (2019-02-21)"},{"location":"CHANGELOG/#feature","text":"TX_BUILDER: Add deserialization schema for Channel transactions( channelCreate , channelCloseMutual , channelDeposit , channelWithdraw , channelSettle ) Chain: Add rawTx and verifyTx to error from poll function(when you wait for transaction will mined) Chore: Depend on bip39 from npm instead of git repo Channel: Change Channel legacy API to JSON RPC TX_BUILDER: Change minFee calculation, multiply min fee by 10^9","title":"Feature"},{"location":"CHANGELOG/#211-010-next-2019-02-21","text":"","title":"2.1.1-0.1.0-next (2019-02-21)"},{"location":"CHANGELOG/#bug-fixes_45","text":"Chore: Fix linter errors","title":"Bug Fixes"},{"location":"CHANGELOG/#210-2019-02-21","text":"","title":"2.1.0 (2019-02-21)"},{"location":"CHANGELOG/#features_41","text":"Node: Minerva comparability Utils: Add Mnemonic wallet implementation es/utils/hd-wallet","title":"Features"},{"location":"CHANGELOG/#breaking-changes_18","text":"Node: Change supported node version range to 1.4.0 <= version < 3.0.0","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#200-2019-02-21","text":"","title":"2.0.0 (2019-02-21)"},{"location":"CHANGELOG/#features_42","text":"TX_BUILDER: Add unpackedTx , txType and signature to validate transaction function Contract: Add top param to contract static call(dry-run) Contract: Add errors handling for dry-run Docs: Add keystore docs Ae: Add verify options to send function which verify tx before broadcasting and throw error if tx is invalid Rpc: Add dryRun to RPC methods Rpc: Add Oracle transaction creation to Aepp rpc Docs: Add tx builder docs Docs: Add doc's for utils/bytes and tx builder schema TX_BUILDER: refactor calculateFee function in TxBuilder (use BigNumber) TX_BUILDER: Extend response of Oracle , Aens , Contrat with rawTx Ae: Change response of send function now it's and object with transaction data(hash, rawTxHash, ...) Chain: Move Contract and Oracle API wrapper's to Chain stamp Chore: Rename epoch in CHANGELOG , README , HACKING","title":"Features"},{"location":"CHANGELOG/#bug-fixes_46","text":"Rpc: RpcServer : Avoid storing of window in instance properties Chain: Disable balance formatting by default Chain: Move verification of transaction to chain stamp Node: Retrieve node version from /api Chore: Fix unpack tx example in bin/aecrypto.js Chore: Remove unused function's from crypto.js","title":"Bug Fixes"},{"location":"CHANGELOG/#breaking-changes_19","text":"TX: Remove old transaction builder es/tx/js.js (Please use es/tx/builder instead) Chore: Rename es/epoch.js to es/node.js Chore: Rename Oracle , Contract , Chain API wrapper files from epoch to node Chore: Rename Contract api wrapper method's","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#132-2019-02-01","text":"","title":"1.3.2 (2019-02-01)"},{"location":"CHANGELOG/#features_43","text":"Ae: Add destroyInstance function to Ae stamp which remove all listeners for RPC event's Docs: Add docs for TransactionValidator and TxBuilder stamp's Build: Add TxBuilderHelper to bundle Chore: Contract call static now using dry-run API Test: Improve test's for Transaction verification","title":"Features"},{"location":"CHANGELOG/#changed","text":"Docs: Adjust doc's for Contract and Aens stamp's Chore: Fix decoding of address from contract call","title":"Changed"},{"location":"CHANGELOG/#131-2019-01-29","text":"","title":"1.3.1 (2019-01-29)"},{"location":"CHANGELOG/#features_44","text":"Build: Remove KeyStore from bundle due to build issue(for now you can export it only using tree-shaking import * as Keystore from '@aeternity/aepp-sdk/utils/keystore' )","title":"Features"},{"location":"CHANGELOG/#130-2019-01-29","text":"","title":"1.3.0 (2019-01-29)"},{"location":"CHANGELOG/#features_45","text":"Channel: Add support for State Channels TX_BUILDER: New transaction builder going through schema(build, unpack) TX_VALIDATOR: Add new stamp TransactionValidator which can verify your transaction Chore: Rename epoch to aeternity node(docker configs, some docs) Tx: Use new tx builder in TX stamp Contract: Set default values for amount and deposit to 0 for contract transaction Rpc: Improve RPC server","title":"Features"},{"location":"CHANGELOG/#notes-and-known-issues","text":"Old transaction builder es/tx/js.js will be removed in next major release.","title":"Notes and known Issues"},{"location":"CHANGELOG/#121-2018-12-21","text":"","title":"1.2.1 (2018-12-21)"},{"location":"CHANGELOG/#features_46","text":"Chain: amount formatter Chain: amount format balance client.balance('AK_PUBLICKEY', { format: true }) Aepp: Oracle and Contracts API to Aepp stamp Chore: Use prepare instead of postinstall-build (thanks @davidyuk) Docs: Refreshed Docs: README.md + docs/usage.md","title":"Features"},{"location":"CHANGELOG/#bug-fixes_47","text":"Chr: Fix Import RLP package (thanks @davidyuk) Rpc: Fix for NetworkId propagation and override Tx: TxJS is not a stamp anymore, and instead: it exports helper functions","title":"Bug Fixes"},{"location":"CHANGELOG/#breaking-changes_20","text":"Tx: TxJs stamp (not a stamp anymore) Chain: balance now answer a formatted string composed of AMOUNT + ' ' + unit (eg. 10 exa for 10 AE)","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#notes-and-known-issues_1","text":"Chore: 10 exa should be 10 ae Chain: format shouldn't be a flag, but a request for unit eg. { format: ae }","title":"Notes and known Issues"},{"location":"CHANGELOG/#112-2018-12-15","text":"","title":"1.1.2 (2018-12-15)"},{"location":"CHANGELOG/#feature_1","text":"Chore: isAddressValid check Tx: Tx Fee formulas","title":"Feature"},{"location":"CHANGELOG/#bug-fixes_48","text":"Rpc: Fixed networkId propagation (and overriding on init of Flavors) Crypto: Fixed encodeBase58Check by feeding Buffered input","title":"Bug Fixes"},{"location":"CHANGELOG/#breaking-changes_21","text":"Chore: Compatibility with Node >= 1.0.0 and <= 1.1.0","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#111-2018-12-11","text":"","title":"1.1.1 (2018-12-11)"},{"location":"CHANGELOG/#features_47","text":"Rpc: Added a command to remove images after CI testing","title":"Features"},{"location":"CHANGELOG/#bug-fixes_49","text":"Rpc: Fix Testing Rpc: Fixed Oracle error for Wallet flavor","title":"Bug Fixes"},{"location":"CHANGELOG/#110-2018-12-11","text":"","title":"1.1.0 (2018-12-11)"},{"location":"CHANGELOG/#features_48","text":"Oracle: Oracles functionality and flavor Aepp: Simple example of aepp-in-aepp (see /examples folder)","title":"Features"},{"location":"CHANGELOG/#bug-fixes_50","text":"Tx: Fixed issue with big numbers and TX","title":"Bug Fixes"},{"location":"CHANGELOG/#101-2018-11-30","text":"","title":"1.0.1 (2018-11-30)"},{"location":"CHANGELOG/#features_49","text":"Node: ability to support Node range(s) using semver package (see https://www.npmjs.com/package/semver#ranges)","title":"Features"},{"location":"CHANGELOG/#breaking-changes_22","text":"Node: Support for Node >= 1.0.0 and < 2.0.0","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#100-2018-11-30","text":"","title":"1.0.0 (2018-11-30)"},{"location":"CHANGELOG/#features_50","text":"Contract: Contract native Transactions","title":"Features"},{"location":"CHANGELOG/#bug-fixes_51","text":"BigNumber: Rolled back to bignumbers.js for easier fix with axios.get/post","title":"Bug Fixes"},{"location":"CHANGELOG/#breaking-changes_23","text":"Node: Support for Node < 1.0.0 Build: New NETWORK_ID (also used in docker/sdk.env for CI tests) Protocol: Encoding of transaction (and other objects) changed from base58check to base64check","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#notes-and-known-issues_2","text":"Channel: State Channels have been excluded for problems with CI, will be included in next release","title":"Notes and known Issues"},{"location":"CHANGELOG/#0250-011-2018-11-30","text":"","title":"0.25.0-0.1.1 (2018-11-30)"},{"location":"CHANGELOG/#notes-and-known-issues_3","text":"Chore: See [0.25.0-0.1.0]","title":"Notes and known Issues"},{"location":"CHANGELOG/#0250-010-2018-11-30","text":"","title":"0.25.0-0.1.0 (2018-11-30)"},{"location":"CHANGELOG/#features_51","text":"Utils Parsing of fee using bignum.js Account Add networkId as param to Account flavor(default: ae_mainnet ) Tx Implement native build of AENS transaction. Keystore Update keystore for new requirements","title":"Features"},{"location":"CHANGELOG/#breaking-changes_24","text":"CLI AE CLI and AE PROJECT CLI moved to separate repos and packages Node Support for < 0.25.0","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#0250-010-next-2018-11-30","text":"","title":"0.25.0-0.1.0-next (2018-11-30)"},{"location":"CHANGELOG/#features_52","text":"Contract Contract type checked call (Ability to call contract using contract address) Contract Use ES methods instead of Ramda, where possible","title":"Features"},{"location":"CHANGELOG/#bug-fixes_52","text":"Contract Fixed keystore by adding a salt param for derivedKey function","title":"Bug Fixes"},{"location":"CHANGELOG/#breaking-changes_25","text":"Contract Support for < 0.25.0 Contract Aens use domain .test instead of .aet (see here ) Contract Use NETWORK_ID for signing (see here )","title":"Breaking Changes"},{"location":"CHANGELOG/#0240-020-2018-10-30","text":"","title":"0.24.0-0.2.0 (2018-10-30)"},{"location":"CHANGELOG/#features_53","text":"Rpc RPC Client improvements Rpc onContract Guard CLI born CLI Host parameter became Url . ( -u for hostname, -U for internal) CLI New keystore following these specifications: https://www.pivotaltracker.com/n/projects/2124891/stories/155155204","title":"Features"},{"location":"CHANGELOG/#breaking-changes_26","text":"Chore The Cli flavor is now Universal Chore the keypair keys changed from { pub, priv } to { publicKey, secretKey } for consistency with other systems using them (eg. AirGap and HD Wallet )","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#notes-and-known-issues_4","text":"Chore CLI and AE PROJECT CLI will move to a separate package","title":"Notes and known Issues"},{"location":"CHANGELOG/#0240-010-2018-10-23","text":"","title":"0.24.0-0.1.0 (2018-10-23)"},{"location":"CHANGELOG/#features_54","text":"Node Full support of Node-0.24.0 CLI Develop decode base58 address command in crypto module CLI Add nonce param to all tx command's CLI Add gas param to deploy and call commands Tx Add ability to create spend transaction natively Keystore Implement ethereum keystore using AES-126-CTR and SCRYPT as key derivation function CLI Change --privateKey to flag on ACCOUNT ADDRESS command Build Change node version in Dockerfile Node API endpoints to meet new Node specifications Chore Update docco config and change rename package to recursive-rename Docs Improved documentation","title":"Features"},{"location":"CHANGELOG/#breaking-changes_27","text":"Node Support for < 0.24.0 Keystore ethereum keystore usage will be removed in the next release CLI CLI will move to a separate package","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#0220-010-beta1-2018-10-02","text":"","title":"0.22.0-0.1.0-beta.1 (2018-10-02)"},{"location":"CHANGELOG/#features_55","text":"CLI Add CLI implementation Crypto nameId function for commitment hash calculations Node API endpoints to meet new Node specifications Tx Add Nonce calculation on SDK side Contract Add check for MAX_GAS in call and deploy contract Chore change hash prefix separator from $ to _ Chore Add keywords ('SDK', 'CLI') to package.json CLI Link aecli to ./bin/aecli.js in package.json (After \"npm link\" you can use CLI globally) Aens Wait until pre-claim transaction block was mined before send claim transaction Build Updated webpack , webpack-cli and added new dev deps accordingly Node Add Node Compatibility Check","title":"Features"},{"location":"CHANGELOG/#bug-fixes_53","text":"Crypto Fixes commitment hash calculations in naming system, to be Hash(nameId(name) + name_salt) instead of Hash(Hash(name + name_salt)) .","title":"Bug Fixes"},{"location":"CHANGELOG/#breaking-changes_28","text":"Node Support for < 0.22.0","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#0180-011-2018-07-31","text":"","title":"0.18.0-0.1.1 (2018-07-31)"},{"location":"CHANGELOG/#features_56","text":"Docs Lots of new documentation (prose and API) Docs Fancy badges to README Build Transitive dev dependencies for standard-loader not covered by pnpm Build CI Dockerfile to include pnpm Docs Fancy-shmancy diagram in README Docs Generated documentation files since they are linked in static docs Build Switch from Yarn to pnpm for building Docs Structure of documentation Docs Generate Markdown from Docco","title":"Features"},{"location":"CHANGELOG/#0180-010-2018-07-24","text":"","title":"0.18.0-0.1.0 (2018-07-24)"},{"location":"CHANGELOG/#features_57","text":"Node Support for Node 0.18.0 (changed endpoints) RPC Wallet/Aepp RPC support Contract Contract call result decoding support Docs Per-module API documentation (Markdown based on JSDoc) Docs More API documentation (still incomplete) Build SDK entrypoint factories (in /es/ae/universal.js ) Build Module load path (src -> es) Chore Lower mining rate (5s) in docker-compose","title":"Features"},{"location":"CHANGELOG/#bug-fixes_54","text":"Crypto Symmetric key encryption/decryption","title":"Bug Fixes"},{"location":"CHANGELOG/#breaking-changes_29","text":"Node Support for < 0.18.0 (changed endpoints)","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#0150-010-2018-06-12","text":"","title":"0.15.0-0.1.0 (2018-06-12)"},{"location":"CHANGELOG/#features_58","text":"Node Legacy Swagger file loading Node Compatibility with < 0.15.0","title":"Features"},{"location":"CHANGELOG/#bug-fixes_55","text":"Contract Contract unit state initialization Node Missing required parameter for name transfers (workaround for Swagger file bug )","title":"Bug Fixes"},{"location":"CHANGELOG/#0140-010-2018-06-11","text":"","title":"0.14.0-0.1.0 (2018-06-11)"},{"location":"CHANGELOG/#features_59","text":"API New, opinionated top-level API API Rest of legacy API now uses new API as well API Generated API now encapsulated in api object API Automatic case conversion for remote parameter names API Remaining tests to use new API API Adapted new method of obtaining transaction hash, breaks compatibility (see below)","title":"Features"},{"location":"CHANGELOG/#bug-fixes_56","text":"API [GH-49]: Handle existing path components correctly","title":"Bug Fixes"},{"location":"CHANGELOG/#breaking-changes_30","text":"API Remove Oracle API (for the time being) API Remove Legacy API and tests API Remove Compatibility with older versions of Node which provide the transaction hash the old way","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#0130-011-2018-05-24","text":"","title":"0.13.0-0.1.1 (2018-05-24)"},{"location":"CHANGELOG/#features_60","text":"Node Switch to curve ed25519 (from secp256k1) to align with Node protocol changes Node Generate basic API directly from Swagger files, also validate input data Build Compiled library now self-contained with all dependencies Build Use Webpack 4 based cross-platform (Node/Web) compilation Docs Package description now reads SDK for the \u00e6ternity blockchain Chore Authors are now taken from AUTHORS instead of package.json Docs Moved code examples from README to separate file in docs","title":"Features"},{"location":"CHANGELOG/#breaking-changes_31","text":"Node Defunct scripts; will be brought back later","title":"BREAKING CHANGES"},{"location":"CHANGELOG/#bug-fixes_57","text":"Chore More consistent code examples","title":"Bug Fixes"},{"location":"api-reference/","text":"API Reference We currently don't provide the API reference in this documentation anymore as it confused many people more than it helped them. The main reason for that is that the SDK is making heavy use of Stamps and there is just no proper way to document this in e.g. JSDoc right now. However, there is a plan to get rid of Stamps and introduce TypeScript. Once the foundation is laid and it makes sense to publish the API reference this will be done. Until then you are better off taking a look into the sourcecode directly in case you face any uncertainties how to use functions! If you want to help with the transition to TypeScript let us know! :-)","title":"API Reference"},{"location":"api-reference/#api-reference","text":"We currently don't provide the API reference in this documentation anymore as it confused many people more than it helped them. The main reason for that is that the SDK is making heavy use of Stamps and there is just no proper way to document this in e.g. JSDoc right now. However, there is a plan to get rid of Stamps and introduce TypeScript. Once the foundation is laid and it makes sense to publish the API reference this will be done. Until then you are better off taking a look into the sourcecode directly in case you face any uncertainties how to use functions! If you want to help with the transition to TypeScript let us know! :-)","title":"API Reference"},{"location":"compatibility/","text":"Compatibility Table This package is expected to work in these environments: Environment Comment nodejs>=12, common js nodejs>=12, mjs Browser using script tag, umd webpack@4 webpack@5 @vue/cli@4 (webpack@4) @vue/cli@5 (webpack@5) create-react-app@4 (webpack@4) create-react-app@5 (webpack@5) create-react-native-app@3 (webpack@4) Requires URLSearchParams polyfill https://github.com/swagger-api/swagger-js/issues/2457 meteor@2","title":"Compatibility Table"},{"location":"compatibility/#compatibility-table","text":"This package is expected to work in these environments: Environment Comment nodejs>=12, common js nodejs>=12, mjs Browser using script tag, umd webpack@4 webpack@5 @vue/cli@4 (webpack@4) @vue/cli@5 (webpack@5) create-react-app@4 (webpack@4) create-react-app@5 (webpack@5) create-react-native-app@3 (webpack@4) Requires URLSearchParams polyfill https://github.com/swagger-api/swagger-js/issues/2457 meteor@2","title":"Compatibility Table"},{"location":"quick-start/","text":"Quick Start In this example we will send 1 AE coin from one account to another 1. Specify imports For the following snippets in the guide you need to specify multiple imports. Most imports like Universal , MemoryAccount & Node are Stamps that compose certain functionalities. Others utility functions like generateKeyPair also can be imported. const { Universal , MemoryAccount , Node , AE_AMOUNT_FORMATS , generateKeyPair } = require ( '@aeternity/aepp-sdk' ) 2. Create a Keypair for sender const keypair = generateKeyPair () console . log ( `Secret key: ${ keypair . secretKey } ` ) console . log ( `Public key: ${ keypair . publicKey } ` ) 3. Get some AE using the Faucet To receive some AE you can use the Faucet . Just paste sender's publicKey, hit Top UP and you'll immediately get some test coins. 4. Interact with the \u00e6ternity blockchain This example shows: how to create an instance of the SDK using the Universal Stamp how to spend (send) 1 AE from the account the SDK instance was initialized with to some other AE address const NODE_URL = 'https://testnet.aeternity.io' const COMPILER_URL = 'https://compiler.aepps.com' // required for contract interactions const senderAccount = MemoryAccount ({ // replace <SENDER_SECRET> and <SENDER_PUBLIC_KEY> with the generated keypair from step 2 keypair : { secretKey : '<SENDER_SECRET>' , publicKey : '<SENDER_PUBLIC_KEY>' } }); ( async function () { const node = await Node ({ url : NODE_URL }) const aeSdk = await Universal ({ compilerUrl : COMPILER_URL , nodes : [{ name : 'testnet' , instance : node }], accounts : [ senderAccount ] }) // spend one AE await aeSdk . spend ( 1 , '<RECIPIENT_PUBLIC_KEY>' , { // replace <RECIPIENT_PUBLIC_KEY>, Ideally you use public key from Superhero Wallet you have created before denomination : AE_AMOUNT_FORMATS . AE }) })() Note: You may remove code from Step 2 as this serves only for one-time creation By default the spend function expects the amount to be spent in aettos (the smallest possible unit) Following the example snippet you would specify AE as denomination See Testnet Explorer and track your transactions","title":"Quick Start"},{"location":"quick-start/#quick-start","text":"In this example we will send 1 AE coin from one account to another","title":"Quick Start"},{"location":"quick-start/#1-specify-imports","text":"For the following snippets in the guide you need to specify multiple imports. Most imports like Universal , MemoryAccount & Node are Stamps that compose certain functionalities. Others utility functions like generateKeyPair also can be imported. const { Universal , MemoryAccount , Node , AE_AMOUNT_FORMATS , generateKeyPair } = require ( '@aeternity/aepp-sdk' )","title":"1. Specify imports"},{"location":"quick-start/#2-create-a-keypair-for-sender","text":"const keypair = generateKeyPair () console . log ( `Secret key: ${ keypair . secretKey } ` ) console . log ( `Public key: ${ keypair . publicKey } ` )","title":"2. Create a Keypair for sender"},{"location":"quick-start/#3-get-some-ae-using-the-faucet","text":"To receive some AE you can use the Faucet . Just paste sender's publicKey, hit Top UP and you'll immediately get some test coins.","title":"3. Get some AE using the Faucet"},{"location":"quick-start/#4-interact-with-the-ternity-blockchain","text":"This example shows: how to create an instance of the SDK using the Universal Stamp how to spend (send) 1 AE from the account the SDK instance was initialized with to some other AE address const NODE_URL = 'https://testnet.aeternity.io' const COMPILER_URL = 'https://compiler.aepps.com' // required for contract interactions const senderAccount = MemoryAccount ({ // replace <SENDER_SECRET> and <SENDER_PUBLIC_KEY> with the generated keypair from step 2 keypair : { secretKey : '<SENDER_SECRET>' , publicKey : '<SENDER_PUBLIC_KEY>' } }); ( async function () { const node = await Node ({ url : NODE_URL }) const aeSdk = await Universal ({ compilerUrl : COMPILER_URL , nodes : [{ name : 'testnet' , instance : node }], accounts : [ senderAccount ] }) // spend one AE await aeSdk . spend ( 1 , '<RECIPIENT_PUBLIC_KEY>' , { // replace <RECIPIENT_PUBLIC_KEY>, Ideally you use public key from Superhero Wallet you have created before denomination : AE_AMOUNT_FORMATS . AE }) })() Note: You may remove code from Step 2 as this serves only for one-time creation By default the spend function expects the amount to be spent in aettos (the smallest possible unit) Following the example snippet you would specify AE as denomination See Testnet Explorer and track your transactions","title":"4. Interact with the \u00e6ternity blockchain"},{"location":"transaction-options/","text":"Transaction options For every transaction it is possible to provide an options object with one or multiple of the following attributes to the respective function that builds and broadcasts the transaction. Some of these are common and can be provided for each transaction type. Others are transaction specific and only relevant for a specific tx-type. The options object can be optionally passed to the respective function behind the last parameter, example: const sender = 'ak_...' const recipient = 'ak_...' const options = { onAccount : sender , denomination : 'ae' } // optional options object // aeSdk is an instance of the Universal Stamp await aeSdk . spend ( 1 , recipient , options ) // amount, recipient and (optional) options Note: Without the options object the sender would be the first account defined in the accounts array that is used to initialize the Universal Stamp and the recipient would receive 1 aetto instead of 1 AE . Common options These options are common and can be provided to every tx-type: onAccount (default: the first account defined in the account array of the SDK instance) You can specify the account that should be used to sign a transaction. Note: The account needs to be provided to the SDK instance in order to be used for signing. nonce (default: obtain nonce of the account via node API) The default behavior might cause problems if you perform many transactions in a short period of time. You might want to implement your own nonce management and provide the nonce \"manually\". 2 different strategies to use in order to determine the next nonce, See option strategy to learn more. strategy (default: max ) The strategy to obtain next nonce for an account via node API If set to max , then the greatest nonce seen in the account or currently in the transaction pool is incremented with 1 and returned. If the strategy is set to continuity , then transactions in the mempool are checked if there are gaps - missing nonces that prevent transactions with greater nonces to get included ttl (default: 0 ) Should be set if you want the transaction to be only valid until a certain block height is reached. fee (default: calculated for each tx-type) The minimum fee is dependent on the tx-type. You can provide a higher fee to additionally reward the miners. innerTx (default: false ) Should be used for signing an inner transaction that will be wrapped in a PayingForTx . verify (default: false ) If set to true the transaction will be verified prior to broadcasting it. waitMined (default: true ) Wait for transactions to be mined. You can get the tx object that contains the tx-hash immediately by setting to false and should implement your own logic to watch for mined transactions. Tx-type specific options The following options are sepcific for each tx-type. ContractCreateTx & ContractCallTx amount (default: 0 ) To be used for providing aettos (or AE with respective denomination) to a contract related transaction. denomination (default: aettos ) You can specify the denomination of the amount that will be provided to the contract related transaction. gasLimit Maximum amount of gas to be consumed by the transaction. Learn more on How to estimate gas? gasPrice (default: 1e9 ) To increase chances to get your transaction included quickly you can use a higher gasPrice. NameClaimTx nameFee (default: calculated based on the length of the name) The fee in aettos that will be payed to claim the name. For bids in an auction you need to explicitely calculate the required nameFee based on the last bid NameUpdateTx clientTtl (default: 84600 ) This option is an indicator for indexing tools to know how long (in seconds) they could or should cache the name information. nameTtl (default: 180000 ) This option tells the protocol the relative TTL based on the current block height. 180000 is the maximum possible value OracleRegisterTx queryFee (default: 30000 ) The fee in aettos that the oracle requests in order to provide a response. oracleTtl (default: { type: 'delta', value: 500 } ) The TTL of the oracle that defines its expiration. Format: {type: 'delta|block', value: 'number'} OracleQueryTx queryFee (default: 30000 ) The fee in aettos that will be payed to the oracle. queryTtl (default: { type: 'delta', value: 10 } ) The TTL of the query that defines its expiration. The oracle needs to respond before the queryTtl expires. Format: {type: 'delta|block', value: 'number'} responseTtl (default { type: 'delta', value: 10 } ) The TTL of the response that defines its expiration. The response of the oracle will be garbage collected after its expiration. Format: {type: 'delta|block', value: 'number'} SpendTx denomination (default: aettos ) You can specify the denomination of the amount that will be provided to the contract related transaction. How to estimate gas? As \u00e6pp developer, it is reasonable to estimate the gas consumption for a contract call using the dry-run feature of the node once and provide a specific offset (e.g. multiplied by 1.5 or 2) as default in the \u00e6pp to ensure that contract calls are mined. Depending on the logic of the contract the gas consumption of a specific contract call can vary and therefore you should monitor the gas consumption and increase the default for the respective contract call accordingly over time. By default, SDK estimates gasLimit using dry-run endpoint. This means an extra request that makes contract iterations slower, but it is more developer friendly (support of heavy requests without adjustments, and verbose error messages).","title":"Transaction options"},{"location":"transaction-options/#transaction-options","text":"For every transaction it is possible to provide an options object with one or multiple of the following attributes to the respective function that builds and broadcasts the transaction. Some of these are common and can be provided for each transaction type. Others are transaction specific and only relevant for a specific tx-type. The options object can be optionally passed to the respective function behind the last parameter, example: const sender = 'ak_...' const recipient = 'ak_...' const options = { onAccount : sender , denomination : 'ae' } // optional options object // aeSdk is an instance of the Universal Stamp await aeSdk . spend ( 1 , recipient , options ) // amount, recipient and (optional) options Note: Without the options object the sender would be the first account defined in the accounts array that is used to initialize the Universal Stamp and the recipient would receive 1 aetto instead of 1 AE .","title":"Transaction options"},{"location":"transaction-options/#common-options","text":"These options are common and can be provided to every tx-type: onAccount (default: the first account defined in the account array of the SDK instance) You can specify the account that should be used to sign a transaction. Note: The account needs to be provided to the SDK instance in order to be used for signing. nonce (default: obtain nonce of the account via node API) The default behavior might cause problems if you perform many transactions in a short period of time. You might want to implement your own nonce management and provide the nonce \"manually\". 2 different strategies to use in order to determine the next nonce, See option strategy to learn more. strategy (default: max ) The strategy to obtain next nonce for an account via node API If set to max , then the greatest nonce seen in the account or currently in the transaction pool is incremented with 1 and returned. If the strategy is set to continuity , then transactions in the mempool are checked if there are gaps - missing nonces that prevent transactions with greater nonces to get included ttl (default: 0 ) Should be set if you want the transaction to be only valid until a certain block height is reached. fee (default: calculated for each tx-type) The minimum fee is dependent on the tx-type. You can provide a higher fee to additionally reward the miners. innerTx (default: false ) Should be used for signing an inner transaction that will be wrapped in a PayingForTx . verify (default: false ) If set to true the transaction will be verified prior to broadcasting it. waitMined (default: true ) Wait for transactions to be mined. You can get the tx object that contains the tx-hash immediately by setting to false and should implement your own logic to watch for mined transactions.","title":"Common options"},{"location":"transaction-options/#tx-type-specific-options","text":"The following options are sepcific for each tx-type.","title":"Tx-type specific options"},{"location":"transaction-options/#contractcreatetx-contractcalltx","text":"amount (default: 0 ) To be used for providing aettos (or AE with respective denomination) to a contract related transaction. denomination (default: aettos ) You can specify the denomination of the amount that will be provided to the contract related transaction. gasLimit Maximum amount of gas to be consumed by the transaction. Learn more on How to estimate gas? gasPrice (default: 1e9 ) To increase chances to get your transaction included quickly you can use a higher gasPrice.","title":"ContractCreateTx &amp; ContractCallTx"},{"location":"transaction-options/#nameclaimtx","text":"nameFee (default: calculated based on the length of the name) The fee in aettos that will be payed to claim the name. For bids in an auction you need to explicitely calculate the required nameFee based on the last bid","title":"NameClaimTx"},{"location":"transaction-options/#nameupdatetx","text":"clientTtl (default: 84600 ) This option is an indicator for indexing tools to know how long (in seconds) they could or should cache the name information. nameTtl (default: 180000 ) This option tells the protocol the relative TTL based on the current block height. 180000 is the maximum possible value","title":"NameUpdateTx"},{"location":"transaction-options/#oracleregistertx","text":"queryFee (default: 30000 ) The fee in aettos that the oracle requests in order to provide a response. oracleTtl (default: { type: 'delta', value: 500 } ) The TTL of the oracle that defines its expiration. Format: {type: 'delta|block', value: 'number'}","title":"OracleRegisterTx"},{"location":"transaction-options/#oraclequerytx","text":"queryFee (default: 30000 ) The fee in aettos that will be payed to the oracle. queryTtl (default: { type: 'delta', value: 10 } ) The TTL of the query that defines its expiration. The oracle needs to respond before the queryTtl expires. Format: {type: 'delta|block', value: 'number'} responseTtl (default { type: 'delta', value: 10 } ) The TTL of the response that defines its expiration. The response of the oracle will be garbage collected after its expiration. Format: {type: 'delta|block', value: 'number'}","title":"OracleQueryTx"},{"location":"transaction-options/#spendtx","text":"denomination (default: aettos ) You can specify the denomination of the amount that will be provided to the contract related transaction.","title":"SpendTx"},{"location":"transaction-options/#how-to-estimate-gas","text":"As \u00e6pp developer, it is reasonable to estimate the gas consumption for a contract call using the dry-run feature of the node once and provide a specific offset (e.g. multiplied by 1.5 or 2) as default in the \u00e6pp to ensure that contract calls are mined. Depending on the logic of the contract the gas consumption of a specific contract call can vary and therefore you should monitor the gas consumption and increase the default for the respective contract call accordingly over time. By default, SDK estimates gasLimit using dry-run endpoint. This means an extra request that makes contract iterations slower, but it is more developer friendly (support of heavy requests without adjustments, and verbose error messages).","title":"How to estimate gas?"},{"location":"contrib/","text":"Development Principles The Javascript SDK wraps the \u00e6ternity API explosed by Node's Swagger file . It aims to abstract the API, while still providing low-level access to it's endpoints, when necessary. It uses the following Javascript technologies and principles: stampit provides composable Factories based on the Stamp Specification . This is how aepp-sdk approached the composition over inheritance principle. JavaScript the Good Parts (because Crockford is always right) ES6 modules , using export and import Promises using ES7 async/await syntax, where applicable Functional Programming using Ramda Statelessness wherever possible webpack 4 and the Babel Strictly enforced StandardJS Loose coupling of modules to enable tree-shaking Convention over configuration \"Easy things should be easy, and hard things should be possible.\" source -- Larry Wall Support for module access, enabling tree-shaking direct use in node scripts through bundling direct use in browser <script> tags through bundling bundling through webpack Requirements aepp-sdk is transpiled to EcmaScript 5 through WebPack , using Babel and is expected to work in any sufficiently new version of Node.js ( >= v12.17 ) or modern web browser. Contributing Clone the application Make sure your editor/IDE can read and use the .editorconfig file Start hacking (and dont forget to add test for whatever you'll be building). Documenting Apart from documenting features and code, there is also documentation automatically generated using jsdoc for documenting JS files (later transformed in to .md files (to have them readable in platforms like GitHub) and a script for documenting examples and code partials. #generate examples and api documentation npm run docs:examples && npm run docs:api Building aepp-sdk is built using pnpm . In order to build a development version, launch the build:dev command. pnpm install pnpm run build:dev Testing To test, launch the test command. This will run mocha 's tests locally. pnpm run test This repository also includes a docker-compose file, to allow you to run your own \u00e6ternity node locally . If you want to do so, from the root of the project : Create a docker-compose.override.yml file with this content: version : \"3\" services : node : ports : - 3013:3013 - 3113:3113 - 3014:3014 - 3001:3001 Run docker-compose up node Congrats! you're now running your own \u00e6ternity node locally. Composing new Flavors You can also \"compose\" your own flavor by mixing 2 or more flavors likes so: import { Wallet , Contract , MemoryAccount } from '@aeternity/aepp-sdk' // make a \"mixed flavor\" containing Wallet and Contracts flavors Wallet . compose ( Contract )({ url : 'https://testnet.aeternity.io' , accounts : [ MemoryAccount ({ keypair : { secretKey : account . priv , publicKey : account . pub }})], address : account . pub , onTx : true , // or a function to Guard the Rpc client onChain : true , // or a function to Guard the Rpc client onAccount : true , // or a function to Guard the Rpc client networkId : 'ae_uat' }). then ( ae => { // ae is your initialised client now! :) // ... The WebPack compilation provides two different build artifacts in dist/ , one for Node.js and one for browsers. When referencing aepp-sdk through any modern build tooling, it should pick the right one automatically through the entry points defined in package.json . Installation / Linking In order to add a local development version of aepp-sdk to a project, npm link 1 can be used. Releasing How to release a new version","title":"Development"},{"location":"contrib/#development","text":"","title":"Development"},{"location":"contrib/#principles","text":"The Javascript SDK wraps the \u00e6ternity API explosed by Node's Swagger file . It aims to abstract the API, while still providing low-level access to it's endpoints, when necessary. It uses the following Javascript technologies and principles: stampit provides composable Factories based on the Stamp Specification . This is how aepp-sdk approached the composition over inheritance principle. JavaScript the Good Parts (because Crockford is always right) ES6 modules , using export and import Promises using ES7 async/await syntax, where applicable Functional Programming using Ramda Statelessness wherever possible webpack 4 and the Babel Strictly enforced StandardJS Loose coupling of modules to enable tree-shaking Convention over configuration \"Easy things should be easy, and hard things should be possible.\" source -- Larry Wall Support for module access, enabling tree-shaking direct use in node scripts through bundling direct use in browser <script> tags through bundling bundling through webpack","title":"Principles"},{"location":"contrib/#requirements","text":"aepp-sdk is transpiled to EcmaScript 5 through WebPack , using Babel and is expected to work in any sufficiently new version of Node.js ( >= v12.17 ) or modern web browser.","title":"Requirements"},{"location":"contrib/#contributing","text":"Clone the application Make sure your editor/IDE can read and use the .editorconfig file Start hacking (and dont forget to add test for whatever you'll be building).","title":"Contributing"},{"location":"contrib/#documenting","text":"Apart from documenting features and code, there is also documentation automatically generated using jsdoc for documenting JS files (later transformed in to .md files (to have them readable in platforms like GitHub) and a script for documenting examples and code partials. #generate examples and api documentation npm run docs:examples && npm run docs:api","title":"Documenting"},{"location":"contrib/#building","text":"aepp-sdk is built using pnpm . In order to build a development version, launch the build:dev command. pnpm install pnpm run build:dev","title":"Building"},{"location":"contrib/#testing","text":"To test, launch the test command. This will run mocha 's tests locally. pnpm run test This repository also includes a docker-compose file, to allow you to run your own \u00e6ternity node locally . If you want to do so, from the root of the project : Create a docker-compose.override.yml file with this content: version : \"3\" services : node : ports : - 3013:3013 - 3113:3113 - 3014:3014 - 3001:3001 Run docker-compose up node Congrats! you're now running your own \u00e6ternity node locally.","title":"Testing"},{"location":"contrib/#composing-new-flavors","text":"You can also \"compose\" your own flavor by mixing 2 or more flavors likes so: import { Wallet , Contract , MemoryAccount } from '@aeternity/aepp-sdk' // make a \"mixed flavor\" containing Wallet and Contracts flavors Wallet . compose ( Contract )({ url : 'https://testnet.aeternity.io' , accounts : [ MemoryAccount ({ keypair : { secretKey : account . priv , publicKey : account . pub }})], address : account . pub , onTx : true , // or a function to Guard the Rpc client onChain : true , // or a function to Guard the Rpc client onAccount : true , // or a function to Guard the Rpc client networkId : 'ae_uat' }). then ( ae => { // ae is your initialised client now! :) // ... The WebPack compilation provides two different build artifacts in dist/ , one for Node.js and one for browsers. When referencing aepp-sdk through any modern build tooling, it should pick the right one automatically through the entry points defined in package.json .","title":"Composing new Flavors"},{"location":"contrib/#installation-linking","text":"In order to add a local development version of aepp-sdk to a project, npm link 1 can be used.","title":"Installation / Linking"},{"location":"contrib/#releasing","text":"How to release a new version","title":"Releasing"},{"location":"contrib/releases/","text":"Releases This document describes the requirements and the process of creating releases of aepp-sdk to npmjs.com. Prerequisites A user wanting to release a new version needs to be a member of the @aeternity organization on npmjs.com. An existing member with write access needs to invite them in order to achieve this. In addition, the user needs to activate any means of 2-factor authentication because the aepp-sdk package is set up to only accept new versions if a second factor for authentication is in use. As new releases should only happen from release branch merges to the master branch of the repository on GitHub followed by a signed tag push, the user also needs direct write access to the repository on GitHub. Normally, this can be achieved by first adding them to the \u00e6ternity organization and then to the sdk team , which gives automatic write access. Branching Out As aepp-sdk follows the git-flow strategy for development, the release process is modelled after that strategy accordingly, with a few additions. Branch out from develop to a dedicated release branch denoting the target version number, e.g. release/v2.3.4 . Preparing a Pre-Release If Testnet is not yet targeting the latest Node version, but you're \"ready to release\", you can do a pre-release for the latest version, tagging the release as @next on npmjs. To do this, You can follow the steps listed below, while keeping the next portion in both CHANGELOG.md and package.json files. Preparing a Release On the release branch, remove the next portion of the version string in package.json . Execute npm run release to automatically bump version number in package.json and package-lock.json (according to Semantic Versioning ) output changes to CHANGELOG.md commit package-lock.json and package.json and CHANGELOG.md Next, git diff the release, branch a release/vX.X.X (where vX.X.X is your latest release) against master and validate that all changes are covered in the changelog. You can find more instructions on how to maintain a CHANGELOG here: https://keepachangelog.com PR against master Create a pull request against master and have it peer reviewed thoroughly. As all changes should've been reviewed before when they were merged to develop , emphasize on security-related changes and small changes pushed to develop separately. Merging Once the integration build has successfully completed (with or without additional fixes), merge (without squash) the branch into master . This allows master to be comprised of release commits exclusively, so every commit on master corresponds to exactly one released (or at least, tagged) version of aepp-sdk, respectively. Build, Release and Tag Update the local working copy to a local tracking branch of master and update. Optionally, wait for the CI build to finish and execute a last npm run test locally. Important: Because npm publish will use the local files on disk for releasing, perform a full clean and build in order to release to npmjs.com! Cleanup - run git clean -ffdx to completely wipe out your workspace of files not in the repository. This might wipe out files you still need, so consider a separate clone of the project! Execute npm run prepublishOnly to generate Documentation for the API and the SDK codebase, optionally followed by npm pack and investigate the resulting tarball's contents. This tarball resembles what users will actually download from npmjs.com once the release is completed! Execute npm publish and follow the on-screen instructions Important: If you are releasing a Pre-Release (AKA next ), make sure to tag the release as next using the command npm publish --tag next . At this point, the release should already be in npmjs.com. The final step is to also tag the release on GitHub and push the tag, which requires direct write access . git tag vX.X.X git push tag vX.X.X Recommendation: Use signed tags using the -s option to increase community's trust in the project! Merging Back into develop At this point, it is important to synchronize develop with any changes that have happened after branching out to the release branch. Create a new branch called realign/vX.X.X from master (where vX.X.X is your latest release) and open a Pull Request towards develop and resolve conflicts, if needed. This concludes the release process and the development cycle.","title":"Releases"},{"location":"contrib/releases/#releases","text":"This document describes the requirements and the process of creating releases of aepp-sdk to npmjs.com.","title":"Releases"},{"location":"contrib/releases/#prerequisites","text":"A user wanting to release a new version needs to be a member of the @aeternity organization on npmjs.com. An existing member with write access needs to invite them in order to achieve this. In addition, the user needs to activate any means of 2-factor authentication because the aepp-sdk package is set up to only accept new versions if a second factor for authentication is in use. As new releases should only happen from release branch merges to the master branch of the repository on GitHub followed by a signed tag push, the user also needs direct write access to the repository on GitHub. Normally, this can be achieved by first adding them to the \u00e6ternity organization and then to the sdk team , which gives automatic write access.","title":"Prerequisites"},{"location":"contrib/releases/#branching-out","text":"As aepp-sdk follows the git-flow strategy for development, the release process is modelled after that strategy accordingly, with a few additions. Branch out from develop to a dedicated release branch denoting the target version number, e.g. release/v2.3.4 .","title":"Branching Out"},{"location":"contrib/releases/#preparing-a-pre-release","text":"If Testnet is not yet targeting the latest Node version, but you're \"ready to release\", you can do a pre-release for the latest version, tagging the release as @next on npmjs. To do this, You can follow the steps listed below, while keeping the next portion in both CHANGELOG.md and package.json files.","title":"Preparing a Pre-Release"},{"location":"contrib/releases/#preparing-a-release","text":"On the release branch, remove the next portion of the version string in package.json . Execute npm run release to automatically bump version number in package.json and package-lock.json (according to Semantic Versioning ) output changes to CHANGELOG.md commit package-lock.json and package.json and CHANGELOG.md Next, git diff the release, branch a release/vX.X.X (where vX.X.X is your latest release) against master and validate that all changes are covered in the changelog. You can find more instructions on how to maintain a CHANGELOG here: https://keepachangelog.com","title":"Preparing a Release"},{"location":"contrib/releases/#pr-against-master","text":"Create a pull request against master and have it peer reviewed thoroughly. As all changes should've been reviewed before when they were merged to develop , emphasize on security-related changes and small changes pushed to develop separately.","title":"PR against master"},{"location":"contrib/releases/#merging","text":"Once the integration build has successfully completed (with or without additional fixes), merge (without squash) the branch into master . This allows master to be comprised of release commits exclusively, so every commit on master corresponds to exactly one released (or at least, tagged) version of aepp-sdk, respectively.","title":"Merging"},{"location":"contrib/releases/#build-release-and-tag","text":"Update the local working copy to a local tracking branch of master and update. Optionally, wait for the CI build to finish and execute a last npm run test locally. Important: Because npm publish will use the local files on disk for releasing, perform a full clean and build in order to release to npmjs.com! Cleanup - run git clean -ffdx to completely wipe out your workspace of files not in the repository. This might wipe out files you still need, so consider a separate clone of the project! Execute npm run prepublishOnly to generate Documentation for the API and the SDK codebase, optionally followed by npm pack and investigate the resulting tarball's contents. This tarball resembles what users will actually download from npmjs.com once the release is completed! Execute npm publish and follow the on-screen instructions Important: If you are releasing a Pre-Release (AKA next ), make sure to tag the release as next using the command npm publish --tag next . At this point, the release should already be in npmjs.com. The final step is to also tag the release on GitHub and push the tag, which requires direct write access . git tag vX.X.X git push tag vX.X.X Recommendation: Use signed tags using the -s option to increase community's trust in the project!","title":"Build, Release and Tag"},{"location":"contrib/releases/#merging-back-into-develop","text":"At this point, it is important to synchronize develop with any changes that have happened after branching out to the release branch. Create a new branch called realign/vX.X.X from master (where vX.X.X is your latest release) and open a Pull Request towards develop and resolve conflicts, if needed. This concludes the release process and the development cycle.","title":"Merging Back into develop"},{"location":"examples/node/contract-interaction/","text":"Compile & Deploy a Sophia Smart Contract Introduction The whole script is located in the repository and this page explains in detail how to: deal with the different phases of compiling Sophia contracts to bytecode deploy the bytecode to get a callable contract address invoke the deployed contract on the \u00e6ternity blockchain 1. Specify imports You need to import Universal , Node and MemoryAccount Stamps from the SDK. const { Universal , Node , MemoryAccount } = require ( '@aeternity/aepp-sdk' ) Note : You need to have the SDK installed via npm i @aetenity/aepp-sdk -g to run that example code. 2. Define constants The following constants are used in the subsequent code snippets. const CONTRACT_SOURCE = // typically you read the source code from a separate .aes file ` contract Multiplier = record state = { factor: int } entrypoint init(f : int) : state = { factor = f } stateful entrypoint setFactor(f : int): int = put(state{ factor = f }) f * 10 entrypoint multiplyBy(x : int) = x * state.factor ` const ACCOUNT_KEYPAIR = { publicKey : 'ak_2dATVcZ9KJU5a8hdsVtTv21pYiGWiPbmVcU1Pz72FFqpk9pSRR' , secretKey : 'bf66e1c256931870908a649572ed0257876bb84e3cdf71efb12f56c7335fad54d5cf08400e988222f26eb4b02c8f89077457467211a6e6d955edb70749c6a33b' } const NODE_URL = 'https://testnet.aeternity.io' const COMPILER_URL = 'https://compiler.aepps.com' ; Note: The keypair of the account is pre-funded and only used for demonstration purpose You should replace it with your own keypair (see Create a Keypair ) In case the account runs out of funds you can always request AE using the Faucet 3. Open async codeblock Most functions of the SDK return Promises , so the recommended way of dealing with subsequent actions is running them one by one using await . Therefore you need to put the logic into an async code block ( async () => { 4. Create object instances const account = MemoryAccount ({ keypair : ACCOUNT_KEYPAIR }) const node = await Node ({ url : NODE_URL }) const aeSdk = await Universal ({ nodes : [{ name : 'testnet' , instance : node }], compilerUrl : COMPILER_URL , accounts : [ account ] }) The Universal Stamp itself is asynchronous as it determines the node's version and rest interface automatically. Only once the Promise is fulfilled, you know you have a working object instance which is assigned to the aeSdk constant in this case. Note: Universal is not a constructor but a factory, which means it's not invoked with new . 5. Get contract instance Knowing the source code allows you to initialize a contract instance and interact with the contract in a convenient way. console . log ( CONTRACT_SOURCE ) const contract = await aeSdk . getContractInstance ({ source : CONTRACT_SOURCE }) 6. Compile the contract The compile function sends a raw Sophia contract as string to the HTTP compiler for bytecode compilation. In the future this will be done without talking to the node, but requiring a bytecode compiler implementation directly in the SDK. const bytecode = await contract . compile () console . log ( `Obtained bytecode ${ bytecode } ` ) 7. Deploy the contract Invoking deploy on the contract instance will result in the CreateContractTx being created, signed (using the secretKey of the previously defined MemoryAccount ) and broadcasted to the network. It will be picked up by the miners and written to the chain. const deployInfo = await contract . deploy ([ 5 ]) console . log ( `Contract deployed at ${ deployInfo . address } ` ) Note: Sophia contracts always have an init function which needs to be invoked. The SDK generates the required calldata for the provided arguments by @aeternity/aepp-calldata package. 8. Call a contract function Once the ContractCreateTx has been successfully mined, you can attempt to invoke any public function (aka entrypoint in Sophia) defined within it. await contract . methods . setFactor ( 6 ) Note : setFactor is a stateful entrypoint that changes to the contract's state so contract broadcasting the transaction to be mined 9. Call a contract function via dry-run You can use callStatic option which performs a dry-run of the transaction which allows you to get the result without having to mine a transaction. let call = await contract . methods . setFactor ( 7 , { callStatic : true }) 10. Decode the call result The execution result, if successful, will be an FATE-encoded result value. The decodedResult property will contain the result value decoded using calldata package. console . log ( `setFactor execution result: ${ call . decodedResult } ` ) 11. Call a contract non-stateful entrypoint via dry-run call = await contract . methods . multiplyBy ( 8 ) console . log ( `multiplyBy execution result: ${ call . decodedResult } ` ) Note : The contract automatically chooses to perform a dry-run call as multiplyBy is a non-stateful entrypoint if multiplyBy would be a stateful entrypoint the transaction would be broadcasted to the network and picked up by miners 12. Close and run async codeblock Now you can close the async codeblock and execute it at the same time. })()","title":"Compile & Deploy a Sophia Smart Contract"},{"location":"examples/node/contract-interaction/#compile-deploy-a-sophia-smart-contract","text":"","title":"Compile &amp; Deploy a Sophia Smart Contract"},{"location":"examples/node/contract-interaction/#introduction","text":"The whole script is located in the repository and this page explains in detail how to: deal with the different phases of compiling Sophia contracts to bytecode deploy the bytecode to get a callable contract address invoke the deployed contract on the \u00e6ternity blockchain","title":"Introduction"},{"location":"examples/node/contract-interaction/#1-specify-imports","text":"You need to import Universal , Node and MemoryAccount Stamps from the SDK. const { Universal , Node , MemoryAccount } = require ( '@aeternity/aepp-sdk' ) Note : You need to have the SDK installed via npm i @aetenity/aepp-sdk -g to run that example code.","title":"1. Specify imports"},{"location":"examples/node/contract-interaction/#2-define-constants","text":"The following constants are used in the subsequent code snippets. const CONTRACT_SOURCE = // typically you read the source code from a separate .aes file ` contract Multiplier = record state = { factor: int } entrypoint init(f : int) : state = { factor = f } stateful entrypoint setFactor(f : int): int = put(state{ factor = f }) f * 10 entrypoint multiplyBy(x : int) = x * state.factor ` const ACCOUNT_KEYPAIR = { publicKey : 'ak_2dATVcZ9KJU5a8hdsVtTv21pYiGWiPbmVcU1Pz72FFqpk9pSRR' , secretKey : 'bf66e1c256931870908a649572ed0257876bb84e3cdf71efb12f56c7335fad54d5cf08400e988222f26eb4b02c8f89077457467211a6e6d955edb70749c6a33b' } const NODE_URL = 'https://testnet.aeternity.io' const COMPILER_URL = 'https://compiler.aepps.com' ; Note: The keypair of the account is pre-funded and only used for demonstration purpose You should replace it with your own keypair (see Create a Keypair ) In case the account runs out of funds you can always request AE using the Faucet","title":"2. Define constants"},{"location":"examples/node/contract-interaction/#3-open-async-codeblock","text":"Most functions of the SDK return Promises , so the recommended way of dealing with subsequent actions is running them one by one using await . Therefore you need to put the logic into an async code block ( async () => {","title":"3. Open async codeblock"},{"location":"examples/node/contract-interaction/#4-create-object-instances","text":"const account = MemoryAccount ({ keypair : ACCOUNT_KEYPAIR }) const node = await Node ({ url : NODE_URL }) const aeSdk = await Universal ({ nodes : [{ name : 'testnet' , instance : node }], compilerUrl : COMPILER_URL , accounts : [ account ] }) The Universal Stamp itself is asynchronous as it determines the node's version and rest interface automatically. Only once the Promise is fulfilled, you know you have a working object instance which is assigned to the aeSdk constant in this case. Note: Universal is not a constructor but a factory, which means it's not invoked with new .","title":"4. Create object instances"},{"location":"examples/node/contract-interaction/#5-get-contract-instance","text":"Knowing the source code allows you to initialize a contract instance and interact with the contract in a convenient way. console . log ( CONTRACT_SOURCE ) const contract = await aeSdk . getContractInstance ({ source : CONTRACT_SOURCE })","title":"5. Get contract instance"},{"location":"examples/node/contract-interaction/#6-compile-the-contract","text":"The compile function sends a raw Sophia contract as string to the HTTP compiler for bytecode compilation. In the future this will be done without talking to the node, but requiring a bytecode compiler implementation directly in the SDK. const bytecode = await contract . compile () console . log ( `Obtained bytecode ${ bytecode } ` )","title":"6. Compile the contract"},{"location":"examples/node/contract-interaction/#7-deploy-the-contract","text":"Invoking deploy on the contract instance will result in the CreateContractTx being created, signed (using the secretKey of the previously defined MemoryAccount ) and broadcasted to the network. It will be picked up by the miners and written to the chain. const deployInfo = await contract . deploy ([ 5 ]) console . log ( `Contract deployed at ${ deployInfo . address } ` ) Note: Sophia contracts always have an init function which needs to be invoked. The SDK generates the required calldata for the provided arguments by @aeternity/aepp-calldata package.","title":"7. Deploy the contract"},{"location":"examples/node/contract-interaction/#8-call-a-contract-function","text":"Once the ContractCreateTx has been successfully mined, you can attempt to invoke any public function (aka entrypoint in Sophia) defined within it. await contract . methods . setFactor ( 6 ) Note : setFactor is a stateful entrypoint that changes to the contract's state so contract broadcasting the transaction to be mined","title":"8. Call a contract function"},{"location":"examples/node/contract-interaction/#9-call-a-contract-function-via-dry-run","text":"You can use callStatic option which performs a dry-run of the transaction which allows you to get the result without having to mine a transaction. let call = await contract . methods . setFactor ( 7 , { callStatic : true })","title":"9. Call a contract function via dry-run"},{"location":"examples/node/contract-interaction/#10-decode-the-call-result","text":"The execution result, if successful, will be an FATE-encoded result value. The decodedResult property will contain the result value decoded using calldata package. console . log ( `setFactor execution result: ${ call . decodedResult } ` )","title":"10. Decode the call result"},{"location":"examples/node/contract-interaction/#11-call-a-contract-non-stateful-entrypoint-via-dry-run","text":"call = await contract . methods . multiplyBy ( 8 ) console . log ( `multiplyBy execution result: ${ call . decodedResult } ` ) Note : The contract automatically chooses to perform a dry-run call as multiplyBy is a non-stateful entrypoint if multiplyBy would be a stateful entrypoint the transaction would be broadcasted to the network and picked up by miners","title":"11. Call a contract non-stateful entrypoint via dry-run"},{"location":"examples/node/contract-interaction/#12-close-and-run-async-codeblock","text":"Now you can close the async codeblock and execute it at the same time. })()","title":"12. Close and run async codeblock"},{"location":"examples/node/paying-for-tx-contract-call-tx/","text":"InnerTx: ContractCallTx Introduction The whole script is located in the repository and this page explains in detail how to: Create and sign a ContractCallTx with the innerTx option for an account that has no balance. Wrap the signed ContractCallTx in a PayingForTx using an account with balance to pay the fees of the inner transaction. Note: This can be done for any transaction type! UseCases This functionality allows every service to let their users interact with their decentralized aepp without having them to buy AE by covering their fees. Examples: Game developers that want to quickly onboard new users. Governance \u00e6pps that want people to vote on important proposals without having them to pay anything. Custodians that want to offer an additional services to cover the transaction fees of their clients. ... many more! 1. Specify imports You need to import Universal , Node and MemoryAccount Stamps from the SDK. Additionally you import the generateKeyPair utility function to generate a new keypair. const { Universal , Node , MemoryAccount , generateKeyPair , TX_TYPE } = require ( '@aeternity/aepp-sdk' ) Note : You need to have the SDK installed via npm i @aetenity/aepp-sdk -g to run that example code. 2. Define constants The following constants are used in the subsequent code snippets. const PAYER_ACCOUNT_KEYPAIR = { publicKey : 'ak_2dATVcZ9KJU5a8hdsVtTv21pYiGWiPbmVcU1Pz72FFqpk9pSRR' , secretKey : 'bf66e1c256931870908a649572ed0257876bb84e3cdf71efb12f56c7335fad54d5cf08400e988222f26eb4b02c8f89077457467211a6e6d955edb70749c6a33b' } const NODE_URL = 'https://testnet.aeternity.io' const COMPILER_URL = 'https://compiler.aepps.com' const CONTRACT_ADDRESS = 'ct_iy86kak8GGt4U5VjDFNQf1a9qjbyxKpmGVNe3UuKwnmcM6LW8' const CONTRACT_SOURCE = ` @compiler >= 6 contract PayingForTxExample = record state = { last_caller: option(address) } entrypoint init() = { last_caller = None } stateful entrypoint set_last_caller() = put(state{last_caller = Some(Call.caller)}) entrypoint get_last_caller() : option(address) = state.last_caller ` const NEW_USER_KEYPAIR = generateKeyPair (); Note: The keypair of the account is pre-funded and only used for demonstration purpose You can replace it with your own keypair (see Create a Keypair ) In case the account runs out of funds you can always request AE using the Faucet The contract is already deployed at the defined address. The NEW_USER_KEYPAIR is used to call the contract. The PayingForTx allows the new user to perform a contract call without having any funds. 3. Open async codeblock Most functions of the SDK return Promises , so the recommended way of dealing with subsequent actions is running them one by one using await . Therefore we are putting our logic into an async code block ( async () => { 4. Create object instances const payerAccount = MemoryAccount ({ keypair : PAYER_ACCOUNT_KEYPAIR }) const newUserAccount = MemoryAccount ({ keypair : NEW_USER_KEYPAIR }) const node = await Node ({ url : NODE_URL }) const aeSdk = await Universal ({ nodes : [{ name : 'testnet' , instance : node }], compilerUrl : COMPILER_URL , accounts : [ payerAccount , newUserAccount ] }) The Universal Stamp itself is asynchronous as it determines the node's version and rest interface automatically. Only once the Promise is fulfilled, you know you have a working object instance which is assigned to the aeSdk constant in this case. Note: Universal is not a constructor but a factory, which means it's not invoked with new . 5. Create and sign ContractCallTx on behalf of new user Currently there is no high-level API available that allows you to create and sign the ContractCallTx by invoking the generated contract method on the contract instance that you typically use for contract calls. Following 4 steps need to be done: Initialize a contract instance by the source code and the contract address. Create calldata by calling the encode function providing the contract name, the name of the entrypoint to call as well as the required params. The entrypoint with the name set_latest_caller doesn't require any params so you can provide an empty array Create the ContractCreateTx by providing all required params. You could omit amount , gasLimit and gasPrice if you choose to stick to the default values (see transaction options ) Sign the transaction by providing innerTx: true as transaction option. The transaction will be signed in a special way that is required for inner transactions. const contract = await aeSdk . getContractInstance ( { source : CONTRACT_SOURCE , contractAddress : CONTRACT_ADDRESS } ) const calldata = contract . calldata . encode ( 'PayingForTxExample' , 'set_last_caller' , []) const contractCallTx = await aeSdk . buildTx ( TX_TYPE . contractCall , { callerId : await newUserAccount . address (), contractId : CONTRACT_ADDRESS , amount : 0 , gasLimit : 1000000 , gasPrice : 1500000000 , callData : calldata }) const signedContractCallTx = await aeSdk . signTransaction ( contractCallTx , { onAccount : newUserAccount , innerTx : true } ) 6. Create, sign & broadcast the PayingForTx as payer const payForTx = await aeSdk . payForTransaction ( signedContractCallTx , { onAccount : payerAccount }) console . log ( payForTx ) 7. Check that last caller is the new user Contract instance allows interacting with the contract in a convenient way. const dryRunTx = await contract . methods . get_last_caller () console . log ( `New user: ${ await newUserAccount . address () } ` ) console . log ( 'Last caller:' , dryRunTx . decodedResult ) Note: Last caller should now be the address of the new user. For regular (non-stateful) entrypoints the SDK automatically performs a dry-run which allows to perform read-only calls for free, see Contract guide . 8. Close and run async codeblock Now you can close the async codeblock and execute it at the same time. })()","title":"InnerTx: ContractCallTx"},{"location":"examples/node/paying-for-tx-contract-call-tx/#innertx-contractcalltx","text":"","title":"InnerTx: ContractCallTx"},{"location":"examples/node/paying-for-tx-contract-call-tx/#introduction","text":"The whole script is located in the repository and this page explains in detail how to: Create and sign a ContractCallTx with the innerTx option for an account that has no balance. Wrap the signed ContractCallTx in a PayingForTx using an account with balance to pay the fees of the inner transaction. Note: This can be done for any transaction type!","title":"Introduction"},{"location":"examples/node/paying-for-tx-contract-call-tx/#usecases","text":"This functionality allows every service to let their users interact with their decentralized aepp without having them to buy AE by covering their fees. Examples: Game developers that want to quickly onboard new users. Governance \u00e6pps that want people to vote on important proposals without having them to pay anything. Custodians that want to offer an additional services to cover the transaction fees of their clients. ... many more!","title":"UseCases"},{"location":"examples/node/paying-for-tx-contract-call-tx/#1-specify-imports","text":"You need to import Universal , Node and MemoryAccount Stamps from the SDK. Additionally you import the generateKeyPair utility function to generate a new keypair. const { Universal , Node , MemoryAccount , generateKeyPair , TX_TYPE } = require ( '@aeternity/aepp-sdk' ) Note : You need to have the SDK installed via npm i @aetenity/aepp-sdk -g to run that example code.","title":"1. Specify imports"},{"location":"examples/node/paying-for-tx-contract-call-tx/#2-define-constants","text":"The following constants are used in the subsequent code snippets. const PAYER_ACCOUNT_KEYPAIR = { publicKey : 'ak_2dATVcZ9KJU5a8hdsVtTv21pYiGWiPbmVcU1Pz72FFqpk9pSRR' , secretKey : 'bf66e1c256931870908a649572ed0257876bb84e3cdf71efb12f56c7335fad54d5cf08400e988222f26eb4b02c8f89077457467211a6e6d955edb70749c6a33b' } const NODE_URL = 'https://testnet.aeternity.io' const COMPILER_URL = 'https://compiler.aepps.com' const CONTRACT_ADDRESS = 'ct_iy86kak8GGt4U5VjDFNQf1a9qjbyxKpmGVNe3UuKwnmcM6LW8' const CONTRACT_SOURCE = ` @compiler >= 6 contract PayingForTxExample = record state = { last_caller: option(address) } entrypoint init() = { last_caller = None } stateful entrypoint set_last_caller() = put(state{last_caller = Some(Call.caller)}) entrypoint get_last_caller() : option(address) = state.last_caller ` const NEW_USER_KEYPAIR = generateKeyPair (); Note: The keypair of the account is pre-funded and only used for demonstration purpose You can replace it with your own keypair (see Create a Keypair ) In case the account runs out of funds you can always request AE using the Faucet The contract is already deployed at the defined address. The NEW_USER_KEYPAIR is used to call the contract. The PayingForTx allows the new user to perform a contract call without having any funds.","title":"2. Define constants"},{"location":"examples/node/paying-for-tx-contract-call-tx/#3-open-async-codeblock","text":"Most functions of the SDK return Promises , so the recommended way of dealing with subsequent actions is running them one by one using await . Therefore we are putting our logic into an async code block ( async () => {","title":"3. Open async codeblock"},{"location":"examples/node/paying-for-tx-contract-call-tx/#4-create-object-instances","text":"const payerAccount = MemoryAccount ({ keypair : PAYER_ACCOUNT_KEYPAIR }) const newUserAccount = MemoryAccount ({ keypair : NEW_USER_KEYPAIR }) const node = await Node ({ url : NODE_URL }) const aeSdk = await Universal ({ nodes : [{ name : 'testnet' , instance : node }], compilerUrl : COMPILER_URL , accounts : [ payerAccount , newUserAccount ] }) The Universal Stamp itself is asynchronous as it determines the node's version and rest interface automatically. Only once the Promise is fulfilled, you know you have a working object instance which is assigned to the aeSdk constant in this case. Note: Universal is not a constructor but a factory, which means it's not invoked with new .","title":"4. Create object instances"},{"location":"examples/node/paying-for-tx-contract-call-tx/#5-create-and-sign-contractcalltx-on-behalf-of-new-user","text":"Currently there is no high-level API available that allows you to create and sign the ContractCallTx by invoking the generated contract method on the contract instance that you typically use for contract calls. Following 4 steps need to be done: Initialize a contract instance by the source code and the contract address. Create calldata by calling the encode function providing the contract name, the name of the entrypoint to call as well as the required params. The entrypoint with the name set_latest_caller doesn't require any params so you can provide an empty array Create the ContractCreateTx by providing all required params. You could omit amount , gasLimit and gasPrice if you choose to stick to the default values (see transaction options ) Sign the transaction by providing innerTx: true as transaction option. The transaction will be signed in a special way that is required for inner transactions. const contract = await aeSdk . getContractInstance ( { source : CONTRACT_SOURCE , contractAddress : CONTRACT_ADDRESS } ) const calldata = contract . calldata . encode ( 'PayingForTxExample' , 'set_last_caller' , []) const contractCallTx = await aeSdk . buildTx ( TX_TYPE . contractCall , { callerId : await newUserAccount . address (), contractId : CONTRACT_ADDRESS , amount : 0 , gasLimit : 1000000 , gasPrice : 1500000000 , callData : calldata }) const signedContractCallTx = await aeSdk . signTransaction ( contractCallTx , { onAccount : newUserAccount , innerTx : true } )","title":"5. Create and sign ContractCallTx on behalf of new user"},{"location":"examples/node/paying-for-tx-contract-call-tx/#6-create-sign-broadcast-the-payingfortx-as-payer","text":"const payForTx = await aeSdk . payForTransaction ( signedContractCallTx , { onAccount : payerAccount }) console . log ( payForTx )","title":"6. Create, sign &amp; broadcast the PayingForTx as payer"},{"location":"examples/node/paying-for-tx-contract-call-tx/#7-check-that-last-caller-is-the-new-user","text":"Contract instance allows interacting with the contract in a convenient way. const dryRunTx = await contract . methods . get_last_caller () console . log ( `New user: ${ await newUserAccount . address () } ` ) console . log ( 'Last caller:' , dryRunTx . decodedResult ) Note: Last caller should now be the address of the new user. For regular (non-stateful) entrypoints the SDK automatically performs a dry-run which allows to perform read-only calls for free, see Contract guide .","title":"7. Check that last caller is the new user"},{"location":"examples/node/paying-for-tx-contract-call-tx/#8-close-and-run-async-codeblock","text":"Now you can close the async codeblock and execute it at the same time. })()","title":"8. Close and run async codeblock"},{"location":"examples/node/paying-for-tx-spend-tx/","text":"InnerTx: SpendTx Introduction The whole script is located in the repository and this page explains in detail how to: Create and sign a SpendTx for an account with the innerTx option. Wrap the signed SpendTx in a PayingForTx , signing it using an account that pays the fees of the inner SpendTx and broadcasts it to the network. Note: This can be done for any transaction type! 1. Specify imports You need to import Universal , Node and MemoryAccount Stamps from the SDK. Additionally you import the generateKeyPair utility function to generate a new keypair. const { Universal , Node , MemoryAccount , generateKeyPair , TX_TYPE } = require ( '@aeternity/aepp-sdk' ) Note : You need to have the SDK installed via npm i @aetenity/aepp-sdk -g to run that example code. 2. Define constants The following constants are used in the subsequent code snippets. const PAYER_ACCOUNT_KEYPAIR = { publicKey : 'ak_2dATVcZ9KJU5a8hdsVtTv21pYiGWiPbmVcU1Pz72FFqpk9pSRR' , secretKey : 'bf66e1c256931870908a649572ed0257876bb84e3cdf71efb12f56c7335fad54d5cf08400e988222f26eb4b02c8f89077457467211a6e6d955edb70749c6a33b' } const NODE_URL = 'https://testnet.aeternity.io' const NEW_USER_KEYPAIR = generateKeyPair () const AMOUNT = 1 ; Note: The keypair of the account is pre-funded and only used for demonstration purpose You can replace it with your own keypair (see Create a Keypair ) In case the account runs out of funds you can always request AE using the Faucet The AMOUNT (in aettos ) will be send to the new user and returned to the payer. 3. Open async codeblock Most functions of the SDK return Promises , so the recommended way of dealing with subsequent actions is running them one by one using await . Therefore we are putting our logic into an async code block ( async () => { 4. Create object instances const payerAccount = MemoryAccount ({ keypair : PAYER_ACCOUNT_KEYPAIR }) const newUserAccount = MemoryAccount ({ keypair : NEW_USER_KEYPAIR }) const node = await Node ({ url : NODE_URL }) const aeSdk = await Universal ({ nodes : [{ name : 'testnet' , instance : node }], accounts : [ payerAccount , newUserAccount ] }) The Universal Stamp itself is asynchronous as it determines the node's version and rest interface automatically. Only once the Promise is fulfilled, you know you have a working object instance which is assigned to the aeSdk constant in this case. Note: Universal is not a constructor but a factory, which means it's not invoked with new . 5. Send 1 aetto from payer to new user const spendTxResult = await aeSdk . spend ( AMOUNT , await newUserAccount . address (), { onAccount : payerAccount } ) console . log ( spendTxResult ) 6. Check balance of new user (before) const newUserBalanceBefore = await aeSdk . getBalance ( await newUserAccount . address ()) console . log ( `new user balance (before): ${ newUserBalanceBefore } ` ) Note: The balance should now be 1 7. Create and sign SpendTx on behalf of new user const spendTx = await aeSdk . buildTx ( TX_TYPE . spend , { senderId : await newUserAccount . address (), recipientId : await payerAccount . address (), amount : AMOUNT }) const signedSpendTx = await aeSdk . signTransaction ( spendTx , { onAccount : newUserAccount , innerTx : true } ) Note: The provided transaction option innerTx indicates that the transaction needs to be signed in a special way 7. Create, sign & broadcast the PayingForTx as payer const payForTx = await aeSdk . payForTransaction ( signedSpendTx , { onAccount : payerAccount }) console . log ( payForTx ) Note: Normally sending the whole balance (1 aetto ) would not be possible as the new user would have to cover the transaction fee. 8. Check balance of new user (after) const newUserBalanceAfter = await aeSdk . getBalance ( await newUserAccount . address ()) console . log ( `new user balance (after): ${ newUserBalanceAfter } ` ) Note: The balance should now be 0 9. Close and run async codeblock Now you can close the async codeblock and execute it at the same time. })()","title":"InnerTx: SpendTx"},{"location":"examples/node/paying-for-tx-spend-tx/#innertx-spendtx","text":"","title":"InnerTx: SpendTx"},{"location":"examples/node/paying-for-tx-spend-tx/#introduction","text":"The whole script is located in the repository and this page explains in detail how to: Create and sign a SpendTx for an account with the innerTx option. Wrap the signed SpendTx in a PayingForTx , signing it using an account that pays the fees of the inner SpendTx and broadcasts it to the network. Note: This can be done for any transaction type!","title":"Introduction"},{"location":"examples/node/paying-for-tx-spend-tx/#1-specify-imports","text":"You need to import Universal , Node and MemoryAccount Stamps from the SDK. Additionally you import the generateKeyPair utility function to generate a new keypair. const { Universal , Node , MemoryAccount , generateKeyPair , TX_TYPE } = require ( '@aeternity/aepp-sdk' ) Note : You need to have the SDK installed via npm i @aetenity/aepp-sdk -g to run that example code.","title":"1. Specify imports"},{"location":"examples/node/paying-for-tx-spend-tx/#2-define-constants","text":"The following constants are used in the subsequent code snippets. const PAYER_ACCOUNT_KEYPAIR = { publicKey : 'ak_2dATVcZ9KJU5a8hdsVtTv21pYiGWiPbmVcU1Pz72FFqpk9pSRR' , secretKey : 'bf66e1c256931870908a649572ed0257876bb84e3cdf71efb12f56c7335fad54d5cf08400e988222f26eb4b02c8f89077457467211a6e6d955edb70749c6a33b' } const NODE_URL = 'https://testnet.aeternity.io' const NEW_USER_KEYPAIR = generateKeyPair () const AMOUNT = 1 ; Note: The keypair of the account is pre-funded and only used for demonstration purpose You can replace it with your own keypair (see Create a Keypair ) In case the account runs out of funds you can always request AE using the Faucet The AMOUNT (in aettos ) will be send to the new user and returned to the payer.","title":"2. Define constants"},{"location":"examples/node/paying-for-tx-spend-tx/#3-open-async-codeblock","text":"Most functions of the SDK return Promises , so the recommended way of dealing with subsequent actions is running them one by one using await . Therefore we are putting our logic into an async code block ( async () => {","title":"3. Open async codeblock"},{"location":"examples/node/paying-for-tx-spend-tx/#4-create-object-instances","text":"const payerAccount = MemoryAccount ({ keypair : PAYER_ACCOUNT_KEYPAIR }) const newUserAccount = MemoryAccount ({ keypair : NEW_USER_KEYPAIR }) const node = await Node ({ url : NODE_URL }) const aeSdk = await Universal ({ nodes : [{ name : 'testnet' , instance : node }], accounts : [ payerAccount , newUserAccount ] }) The Universal Stamp itself is asynchronous as it determines the node's version and rest interface automatically. Only once the Promise is fulfilled, you know you have a working object instance which is assigned to the aeSdk constant in this case. Note: Universal is not a constructor but a factory, which means it's not invoked with new .","title":"4. Create object instances"},{"location":"examples/node/paying-for-tx-spend-tx/#5-send-1-aetto-from-payer-to-new-user","text":"const spendTxResult = await aeSdk . spend ( AMOUNT , await newUserAccount . address (), { onAccount : payerAccount } ) console . log ( spendTxResult )","title":"5. Send 1 aetto from payer to new user"},{"location":"examples/node/paying-for-tx-spend-tx/#6-check-balance-of-new-user-before","text":"const newUserBalanceBefore = await aeSdk . getBalance ( await newUserAccount . address ()) console . log ( `new user balance (before): ${ newUserBalanceBefore } ` ) Note: The balance should now be 1","title":"6. Check balance of new user (before)"},{"location":"examples/node/paying-for-tx-spend-tx/#7-create-and-sign-spendtx-on-behalf-of-new-user","text":"const spendTx = await aeSdk . buildTx ( TX_TYPE . spend , { senderId : await newUserAccount . address (), recipientId : await payerAccount . address (), amount : AMOUNT }) const signedSpendTx = await aeSdk . signTransaction ( spendTx , { onAccount : newUserAccount , innerTx : true } ) Note: The provided transaction option innerTx indicates that the transaction needs to be signed in a special way","title":"7. Create and sign SpendTx on behalf of new user"},{"location":"examples/node/paying-for-tx-spend-tx/#7-create-sign-broadcast-the-payingfortx-as-payer","text":"const payForTx = await aeSdk . payForTransaction ( signedSpendTx , { onAccount : payerAccount }) console . log ( payForTx ) Note: Normally sending the whole balance (1 aetto ) would not be possible as the new user would have to cover the transaction fee.","title":"7. Create, sign &amp; broadcast the PayingForTx as payer"},{"location":"examples/node/paying-for-tx-spend-tx/#8-check-balance-of-new-user-after","text":"const newUserBalanceAfter = await aeSdk . getBalance ( await newUserAccount . address ()) console . log ( `new user balance (after): ${ newUserBalanceAfter } ` ) Note: The balance should now be 0","title":"8. Check balance of new user (after)"},{"location":"examples/node/paying-for-tx-spend-tx/#9-close-and-run-async-codeblock","text":"Now you can close the async codeblock and execute it at the same time. })()","title":"9. Close and run async codeblock"},{"location":"examples/node/transfer-ae/","text":"Transfer AE Introduction The whole script is located in the repository and this page explains in detail how to: initialize an instance of the SDK with a pre-funded account transfer AE to another account 1. Specify imports You need to import Universal , Node and MemoryAccount Stamps from the SDK. const { Universal , Node , MemoryAccount } = require ( '@aeternity/aepp-sdk' ) Note : You need to have the SDK installed via npm i @aetenity/aepp-sdk -g to run that example code. 2. Define constants The following constants are used in the subsequent code snippets. const ACCOUNT_KEYPAIR = { publicKey : 'ak_2dATVcZ9KJU5a8hdsVtTv21pYiGWiPbmVcU1Pz72FFqpk9pSRR' , secretKey : 'bf66e1c256931870908a649572ed0257876bb84e3cdf71efb12f56c7335fad54d5cf08400e988222f26eb4b02c8f89077457467211a6e6d955edb70749c6a33b' } const NODE_URL = 'https://testnet.aeternity.io' const [ amount = 1 , recipient = ACCOUNT_KEYPAIR . publicKey ] = process . argv . slice ( 2 ); Note: The keypair of the account is pre-funded and only used for demonstration purpose You should replace it with your own keypair (see Create a Keypair ) In case the account runs out of funds you can always request AE using the Faucet By default the script will transfer 1 aetto and use the demo account itself as recipient Optionally you can provide the amount and a different recipient by providing the arguments when executing the script, e.g. node transfer-ae.js 3 ak_6D2uyunJaERXfgbsc94G8vrp79nZrbtorL7VCRXk3sWiFK5jb 3. Open async codeblock Most functions of the SDK return Promises , so the recommended way of dealing with subsequent actions is running them one by one using await . Therefore we are putting our logic into an async code block ( async () => { 4. Create object instances const account = MemoryAccount ({ keypair : ACCOUNT_KEYPAIR }) const node = await Node ({ url : NODE_URL }) const aeSdk = await Universal ({ nodes : [{ name : 'testnet' , instance : node }], accounts : [ account ] }) The Universal Stamp itself is asynchronous as it determines the node's version and rest interface automatically. Only once the Promise is fulfilled, you know you have a working object instance which is assigned to the aeSdk constant in this case. Note: Universal is not a constructor but a factory, which means it's not invoked with new . 5. Get AE balance of recipient (before transfer) Before the transfer of AE you can check the AE balance of the recipient. const balanceBefore = await aeSdk . getBalance ( recipient ) console . log ( `Balance of ${ recipient } (before): ${ balanceBefore } aettos` ) 6. Transfer AE Calling the spend function will create, sign and broadcast a SpendTx to the network. const tx = await aeSdk . spend ( amount , recipient ) console . log ( 'Transaction mined' , tx ) 7. Get AE balance of recipient (after transfer) const balanceAfter = await aeSdk . getBalance ( recipient ) console . log ( `Balance of ${ recipient } (after): ${ balanceAfter } aettos` ) Note: If the recipient is the same account as the sender (default of the script if no arguments provided) the balance will be lower after transfer because a transaction fee has been paid to the miners. 8. Close and run async codeblock Now you can close the async codeblock and execute it at the same time. })()","title":"Transfer AE"},{"location":"examples/node/transfer-ae/#transfer-ae","text":"","title":"Transfer AE"},{"location":"examples/node/transfer-ae/#introduction","text":"The whole script is located in the repository and this page explains in detail how to: initialize an instance of the SDK with a pre-funded account transfer AE to another account","title":"Introduction"},{"location":"examples/node/transfer-ae/#1-specify-imports","text":"You need to import Universal , Node and MemoryAccount Stamps from the SDK. const { Universal , Node , MemoryAccount } = require ( '@aeternity/aepp-sdk' ) Note : You need to have the SDK installed via npm i @aetenity/aepp-sdk -g to run that example code.","title":"1. Specify imports"},{"location":"examples/node/transfer-ae/#2-define-constants","text":"The following constants are used in the subsequent code snippets. const ACCOUNT_KEYPAIR = { publicKey : 'ak_2dATVcZ9KJU5a8hdsVtTv21pYiGWiPbmVcU1Pz72FFqpk9pSRR' , secretKey : 'bf66e1c256931870908a649572ed0257876bb84e3cdf71efb12f56c7335fad54d5cf08400e988222f26eb4b02c8f89077457467211a6e6d955edb70749c6a33b' } const NODE_URL = 'https://testnet.aeternity.io' const [ amount = 1 , recipient = ACCOUNT_KEYPAIR . publicKey ] = process . argv . slice ( 2 ); Note: The keypair of the account is pre-funded and only used for demonstration purpose You should replace it with your own keypair (see Create a Keypair ) In case the account runs out of funds you can always request AE using the Faucet By default the script will transfer 1 aetto and use the demo account itself as recipient Optionally you can provide the amount and a different recipient by providing the arguments when executing the script, e.g. node transfer-ae.js 3 ak_6D2uyunJaERXfgbsc94G8vrp79nZrbtorL7VCRXk3sWiFK5jb","title":"2. Define constants"},{"location":"examples/node/transfer-ae/#3-open-async-codeblock","text":"Most functions of the SDK return Promises , so the recommended way of dealing with subsequent actions is running them one by one using await . Therefore we are putting our logic into an async code block ( async () => {","title":"3. Open async codeblock"},{"location":"examples/node/transfer-ae/#4-create-object-instances","text":"const account = MemoryAccount ({ keypair : ACCOUNT_KEYPAIR }) const node = await Node ({ url : NODE_URL }) const aeSdk = await Universal ({ nodes : [{ name : 'testnet' , instance : node }], accounts : [ account ] }) The Universal Stamp itself is asynchronous as it determines the node's version and rest interface automatically. Only once the Promise is fulfilled, you know you have a working object instance which is assigned to the aeSdk constant in this case. Note: Universal is not a constructor but a factory, which means it's not invoked with new .","title":"4. Create object instances"},{"location":"examples/node/transfer-ae/#5-get-ae-balance-of-recipient-before-transfer","text":"Before the transfer of AE you can check the AE balance of the recipient. const balanceBefore = await aeSdk . getBalance ( recipient ) console . log ( `Balance of ${ recipient } (before): ${ balanceBefore } aettos` )","title":"5. Get AE balance of recipient (before transfer)"},{"location":"examples/node/transfer-ae/#6-transfer-ae","text":"Calling the spend function will create, sign and broadcast a SpendTx to the network. const tx = await aeSdk . spend ( amount , recipient ) console . log ( 'Transaction mined' , tx )","title":"6. Transfer AE"},{"location":"examples/node/transfer-ae/#7-get-ae-balance-of-recipient-after-transfer","text":"const balanceAfter = await aeSdk . getBalance ( recipient ) console . log ( `Balance of ${ recipient } (after): ${ balanceAfter } aettos` ) Note: If the recipient is the same account as the sender (default of the script if no arguments provided) the balance will be lower after transfer because a transaction fee has been paid to the miners.","title":"7. Get AE balance of recipient (after transfer)"},{"location":"examples/node/transfer-ae/#8-close-and-run-async-codeblock","text":"Now you can close the async codeblock and execute it at the same time. })()","title":"8. Close and run async codeblock"},{"location":"guides/aens/","text":"AENS (\u00e6ternity naming system) Introduction This guide shows you how to perform all the operations that you need within the lifecycle of \u00e6ternity naming system (AENS) using the SDK. If you successfully claimed a name it will expire after 180000 keyblocks (~375 days). You will need to update your name before it expires! 1. Claim a name Claiming an AENS name requires you (at least) 2 transactions: First you need to perform a pre-claim by providing a commitmentId (hash). The commitmentId is calculated with a random salt and the provided name. The SDK automatically generates the random salt , calculates the commitmentId and includes it into the NamePreclaimTx . After the NamePreclaimTx transaction has been mined you will be able to perform the actual claim of the name. When performing the actual claim via a NameClaimTx you will, depending on the length of the name: immediately become owner of that name initiate an auction Pre-claim // imports const aeSdk = await Universal ({ ... }) // init the SDK instance with Universal Stamp const name = 'testNameForTheGuide.chain' const preClaimTx = await aeSdk . aensPreclaim ( name ) console . log ( preClaimTx ) /* { blockHash: 'mh_2UsggiUaQQmEPjxLnXkXHpm1WawTWqZb1jBx6UzsQNHgirWAwd', blockHeight: 449499, hash: 'th_48RktjEutZC8TCubaq9YhjaF1cKLV9D3VRCJyzJLs7oSp4Ry6', signatures: [ 'sg_Da98k2EKMun1TkE7ytonRypvJwaKg9iBjp8rNcYuodFXqzRqwjQyuFQP5DhxWUpTYRzSTurrNtDmUft8eyTStjCyNqFf8' ], tx: { accountId: 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk', commitmentId: 'cm_2igvW9egddKh77gDdE8mjotmL8PzE7Tf2Q639Q5stUqWQoEfap', fee: 16620000000000, nonce: 18, type: 'NamePreclaimTx', version: 1 }, rawTx: 'tx_+JkLAfhCuEBgFzAL0bPDufmzDq0558vaKtrIyRpNxCYVtkgnJjBrxDpQZHkfbwG+oRuBUAfgfrAKF0lO9mRI1zq0H6bXIq8KuFH4TyEBoQGMyNToF1flcYDSVsPl5DZ9ZY3FJWRpDRQYD32quWBEAhKhA+Jawe/spFaw823K+U59CWx+xD1i34gngUPiAAKJqv/fhg8dpTI4AAAGc20E', height: 449499, claim: [Function: claim], salt: 7595805618692717, commitmentId: 'cm_2igvW9egddKh77gDdE8mjotmL8PzE7Tf2Q639Q5stUqWQoEfap' } */ Note: After transaction is included, you have 300 keyblocks to broadcast claim transaction with the same salt and it should be signed with the same private key as pre-claim . As the pre-claim is required to avoid front running it is recommended to wait with the actual claim until at least 1 keyblock has been mined so that nobody knows which name you aim to claim. The corresponding claim cannot be included in the same keyblock anyway. The protocol doesn't allow that. You should check if the name is still available before performing a pre-claim . The protocol itself doesn't reject a pre-claim transaction if the name isn't available anymore. As you can see above in the logs the result ( preClaimTx ) of the aensPreclaim has bound a claim function that you can make use of to perform the actual claim. In case you want to perform the actual claim at a later point you should remember the salt that has been used for the pre-claim Claim This example assumes that you perform the actual claim manually by having remembered the required salt . In most cases you'd probably use the claim function that is bound to the result of the aensPreclaim function directly (see above). Depending on the length of the name the actual claim will result in direct ownership of the AENS name or start an auction: Name length > 12: ownership of the name is immediately transfered to your account Name length <= 12: an auction is started const salt = 7595805618692717 // salt from pre-claim transaction // the minimum `nameFee` will be automatically generated by sdk // in case you want to provide a custom `nameFee` you can so so by providing it in an options object // in case of starting the auction `nameFee` will be the starting bid const claimTx = await aeSdk . aensClaim ( name , salt ) console . log ( claimTx ) /* { blockHash: 'mh_UvtuVNvK7k29G3anF48W4hgUMaFFLc1wKir55FFifgT49Egk', blockHeight: 449507, hash: 'th_2sWNusGUf2wuRn7d453wPWTAe8pKVbtNF4DqakvippsxjvF8g1', signatures: [ 'sg_LYsVj9zUoKFPDiSvFUWG5QaRhnqQ525YA314xMVzRhApYuPnFyMWgAQGpChKHHWyMbykBwVRrmoQtTENTFCaCoMj17CBK' ], tx: { accountId: 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk', fee: 16800000000000, name: 'testNameForTheGuide.chain', nameFee: '2865700000000000000', nameSalt: '7595805618692717', nonce: 19, type: 'NameClaimTx', version: 2 }, rawTx: 'tx_+KILAfhCuECVba2mm3Un3nrN9U+LpuB2wzqDDmAzXwvc+9sVkpkcALzqm14p7kGqyt8pwjGTyKeLM9lp+KgXWF4PHmHz0WAPuFr4WCACoQGMyNToF1flcYDSVsPl5DZ9ZY3FJWRpDRQYD32quWBEAhOZdGVzdE5hbWVGb3JUaGVHdWlkZS5jaGFpboca/FhPr2JtiCfFAveE1kAAhg9HjghAAADilhgr', id: 'nm_1Cz5HGY8PMWZxNrM6s51CtsJZDU3DDT1LdmpEipa3DRghyGz5', owner: 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk', pointers: [], ttl: 629507, update: [Function (anonymous)], transfer: [Function (anonymous)], revoke: [Function (anonymous)], extendTtl: [Function (anonymous)] } */ Note: The nameFee that is required will be correctly calculated automatically for the initial claim. It's still possible to pass it as additional param, see transaction options . In case the claim triggers an auction the required nameFee is locked by the protocol. If you win the auction the nameFee is permanently deducted from your accounts balance and effectively burned . It will be credited to ak_11111111111111111111111111111111273Yts which nobody can access. This reduces the total supply of AE over time. If somebody else outbids you the provided nameFee is immediately released and returned to your account. Bid during an auction In case there is an auction running for a name you want to claim you need to place a bid. import { computeBidFee , computeAuctionEndBlock } from '@aeternity/aepp-sdk' const name = 'auctiontest1.chain' const startFee = ... // request from middleware, e.g. https://testnet.aeternity.io/mdw/name/auctiontest1.chain const increment = 0.05 // 5%, the minimum required increment // startFee is OPTIONAL and defaults to minimum calculated fee for the name in general // startFee MUST be at least the nameFee of the last bid // increment is OPTIONAL and defaults to 0.05 const nameFee = computeBidFee ( name , startFee , increment ) const bidTx = await aeSdk . aensBid ( name , nameFee ) console . log ( bidTx ) console . log ( `BID PLACED AT ${ bidTx . blockHeight } WILL END AT ${ computeAuctionEndBlock ( name , bidTx . blockHeight ) } ` ) /* { blockHash: 'mh_Y5LDYPtPWzcop2FCbxnwTSwjWo9d3rYcBBcChCEHfzHo2YZpm', blockHeight: 449693, hash: 'th_2nZshewM7FtKSsDEP4zXPsGCe9cdxaFTRrcNjJyE22ktjGidZR', signatures: [ 'sg_7G49bziWjjZAjayBhFffRyfLbmFczs2foJgXcx1n1Vo7iGELQqggdH4w72MqWbNUbM9Jv2EBJnd2LFjv6LJhqTmvJBWyr' ], tx: { accountId: 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk', fee: 16520000000000, name: 'auctiontest1.chain', nameFee: '3159434250000000000', nameSalt: 0, nonce: 24, type: 'NameClaimTx', version: 2 }, rawTx: 'tx_+JQLAfhCuEAv2HQoyLa7krHpcQAsPpWdP+6PJYzdPSifmwNIgpWZtyrdgVD+IGMzzAqxkOQEDeAwc/Oh+dfXPBZpNslCNFgBuEz4SiACoQGMyNToF1flcYDSVsPl5DZ9ZY3FJWRpDRQYD32quWBEAhiSYXVjdGlvbnRlc3QxLmNoYWluAIgr2JC2AnPkAIYPBly7UAAAm/NY1g==', nameFee: BigNumber { s: 1, e: 18, c: [ 31594, 34250000000000 ] } } BID PLACED AT 449693 WILL END AT 479453 */ Note: It is required to provide a nameFee that is at least 5% higher than the current bid. The node doesn't expose an API to request the nameFee of the last bid. You need to receive that information from the middleware that you ideally host yourself. 2. Update a name Now that you own your AENS name you might want to update it in order to: Set pointers to accounts , oracles , contracts or channels . Extend the TTL before it expires. By default a name will have a TTL of 180000 keyblocks (~375 days). It cannot be extended longer than 180000 keyblocks. Set pointers & update TTL import { getDefaultPointerKey } from '@aeternity/aepp-sdk' const name = 'testNameForTheGuide.chain' const oracle = 'ok_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk' const pointers = { account_pubkey : 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk' , customKey : 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk' , [ getDefaultPointerKey ( oracle )] : oracle , // the same as `oracle_pubkey: oracle,` contract_pubkey : 'ct_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk' , channel : 'ch_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk' , } // using aeSdk directly (instance of Universal Stamp) const nameUpdateTx = await aeSdk . aensUpdate ( name , pointers ) // OR using the instance of a name const nameInstance = await aeSdk . aensQuery ( name ) const nameUpdateTx = await nameInstance . update ( pointers ) console . log ( nameUpdateTx ) /* { blockHash: 'mh_AiaGtTWBRys7EX5apAidShyCw1kefocuWt49DgLE2fWNCgKvq', blockHeight: 449855, hash: 'th_LLef19g2mLWQfG7Ds1XZNGyb3SGvi8PGvk7mJczpD9iToBcqL', signatures: [ 'sg_Zm7kp1oBnXGnHwdzsim9nTXtrGoV4bWJhcC1nkw9f3eMPibVaYQRoM829iNrPandAfs8TK7ogEkYByxQx11xCAFMpwUBz' ], tx: { accountId: 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk', clientTtl: 84600, fee: 17800000000000, nameId: 'nm_1Cz5HGY8PMWZxNrM6s51CtsJZDU3DDT1LdmpEipa3DRghyGz5', nameTtl: 180000, nonce: 27, pointers: [ [Object] ], type: 'NameUpdateTx', version: 1 }, rawTx: 'tx_+NQLAfhCuED6aLVAlIfcqczlZ4XzOjG3U23l5+egPFDVEKTSMuL0Zj18jUG6ctJxGGQubNoANFcwQl79T7w0dG4+FV7Qn3AKuIz4iiIBoQGMyNToF1flcYDSVsPl5DZ9ZY3FJWRpDRQYD32quWBEAhuhAgB4Gsn+dalOdWvHXJd+3LBBiO9HsZoHIF2/aQ4n/bbagwK/IPLxjmFjY291bnRfcHVia2V5oQGMyNToF1flcYDSVsPl5DZ9ZY3FJWRpDRQYD32quWBEAoMBSniGEDBirVAAAJ7I9GA=', id: 'nm_1Cz5HGY8PMWZxNrM6s51CtsJZDU3DDT1LdmpEipa3DRghyGz5', owner: 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk', pointers: [ { id: 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk', key: 'account_pubkey' } ], ttl: 629855, update: [Function (anonymous)], transfer: [Function (anonymous)], revoke: [Function (anonymous)], extendTtl: [Function (anonymous)] } */ Note: It's also possible to pass additional transaction options here, too. Extend TTL while keeping pointers In case you want to extend a name using a custom TTL and keep the current pointers you can do this as follows: const name = 'testNameForTheGuide.chain' // using aeSdk directly (instance of Universal Stamp) const nameUpdateTx = await aeSdk . aensUpdate ( name , {}, { nameTtl : 100000 , extendPointers : true }) // OR using the instance of a name const nameInstance = await aeSdk . aensQuery ( name ) const nameUpdateTx = await nameInstance . update ({}, { nameTtl : 100000 , extendPointers : true }) console . log ( nameUpdateTx ) /* { blockHash: 'mh_2mbAuBtyPp7wN6hrcvkYD7LZRSegwZZKYnLcNQkGVGRZ3uVxW6', blockHeight: 449860, hash: 'th_2wXE8i5BUFCUPuioKwAuwNysm6RPQo8STf5m91CuT3LTh7q4ko', signatures: [ 'sg_E69tfR3STWi5Dg6yUHQj5D5waTCEhoFmb1LYWGU2bsCnuLkMgH1KqhRKrCZaatDMyg5szgABDuU1r6ZD5K74qXWW5pMJ' ], tx: { accountId: 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk', clientTtl: 100000, fee: 17800000000000, nameId: 'nm_1Cz5HGY8PMWZxNrM6s51CtsJZDU3DDT1LdmpEipa3DRghyGz5', nameTtl: 100000, nonce: 28, pointers: [ [Object] ], type: 'NameUpdateTx', version: 1 }, rawTx: 'tx_+NQLAfhCuEABuZTyU+W5xmBpQn5GCJiSpK6fI0pYoMIQ5IqD2bs6pJ+oyU7HDGoSU0Mn6tsfYOn+MVRsxLR6yM1Vyv0c4JQNuIz4iiIBoQGMyNToF1flcYDSVsPl5DZ9ZY3FJWRpDRQYD32quWBEAhyhAgB4Gsn+dalOdWvHXJd+3LBBiO9HsZoHIF2/aQ4n/bbagwGGoPLxjmFjY291bnRfcHVia2V5oQGMyNToF1flcYDSVsPl5DZ9ZY3FJWRpDRQYD32quWBEAoMBhqCGEDBirVAAANKYAm0=' } */ Note: If you provide a non-empty array of pointers to that function while using extendPointers the SDK will merge the existing pointers with those provided. In case there already exists an account pointer and you provide an accounts address in the array the old account pointer will be overwritten If you provide an empty array and don't set extendPointers to true all of your current pointers will be removed. 3. Transfer ownership of a name In some cases you might want to transfer the ownership of a name to another account. Of course this is also possible and you can do that as follows: const recipient = 'ak_...' // using aeSdk directly (instance of Universal Stamp) const nameTransferTx = await aeSdk . aensTransfer ( name , recipient ) // OR using the instance of a name const nameInstance = await aeSdk . aensQuery ( name ) const nameTransferTx = await nameInstance . transfer ( recipient ) console . log ( nameTransferTx ) /* { blockHash: 'mh_ZuYV5tmJM4PhrfxzXfo9e37uqPcYpCiAoEC2uRcqbUXeMSmLH', blockHeight: 449982, hash: 'th_xXqmZxR7WJDe6YTz1GnHWgNjtcZjpTPA5bVuiQstmd8o6Gg7x', signatures: [ 'sg_72fiMzprywNmFtuf1i1FFfhBBXcPHpHDfi1Uv2bDnYayoCRWe1yyzvwLmhM6cfA3TR6pBF9Kj3iyYm3mrC46rvNCpchyi' ], tx: { accountId: 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk', fee: 17300000000000, nameId: 'nm_1Cz5HGY8PMWZxNrM6s51CtsJZDU3DDT1LdmpEipa3DRghyGz5', nonce: 33, recipientId: 'ak_2dATVcZ9KJU5a8hdsVtTv21pYiGWiPbmVcU1Pz72FFqpk9pSRR', type: 'NameTransferTx', version: 1 }, rawTx: 'tx_+LsLAfhCuEAuFNHG4gniZjJDQtbm5cIfJACkU/NI96mZpwMvdyuxxOYWYxSxUF2NF5oxjmsYLdXWfSrdmgWj40JzZU/TRA4DuHP4cSQBoQGMyNToF1flcYDSVsPl5DZ9ZY3FJWRpDRQYD32quWBEAiGhAgB4Gsn+dalOdWvHXJd+3LBBiO9HsZoHIF2/aQ4n/bbaoQHVzwhADpiCIvJutLAsj4kHdFdGchGm5tlV7bcHScajO4YPu/hayAAABhgUgg==' } */ 4. Revoke a name In case you want to revoke a name prior to its expiration for whatever reason you can do that as follows: // using aeSdk directly (instance of Universal Stamp) const nameRevokeTx = await aeSdk . aensRevoke ( name ) // OR using the instance of a name const nameInstance = await aeSdk . aensQuery ( name ) const nameRevokeTx = await nameInstance . revoke () console . log ( nameRevokeTx ) /* { blockHash: 'mh_2Q5Xqd4vrmwkS98SBkN79k1t9VLNmDX4wk8xnUJYTEvkK3YoH4', blockHeight: 450018, hash: 'th_2XhJradAVKN2jR2tgNYdKNWikMc8XunqTdUhRPh2TyhAwMqijJ', signatures: [ 'sg_Tjbf8SJDQXgBhaYk7AzTTr7d1RF3bDcMp6BMgRoHcHcgBp13HjcMYmZJ8vvqrZ94An9gvQD4NegYrR7eaBLt6jEy99xyM' ], tx: { accountId: 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk', fee: 16620000000000, nameId: 'nm_1Cz5HGY8PMWZxNrM6s51CtsJZDU3DDT1LdmpEipa3DRghyGz5', nonce: 34, type: 'NameRevokeTx', version: 1 }, rawTx: 'tx_+JkLAfhCuEDMWOZac70tEHQ4AHGBIedZepwTvsBjIHk36vhTd5yBepmTemTQcUVrAtbNO3jZVZD4GUOhN+DfXm2lNrpZu+8FuFH4TyMBoQGMyNToF1flcYDSVsPl5DZ9ZY3FJWRpDRQYD32quWBEAiKhAgB4Gsn+dalOdWvHXJd+3LBBiO9HsZoHIF2/aQ4n/bbahg8dpTI4AAB44bma' } */ Note: On revocation the name enters in a revoked state. After a timeout of 2016 keyblocks the name will be available for claiming again. Delegate signature to contract (AENS interface) It is possible to authorize a Sophia contract to manage an AENS name on behalf of your account. In order to achieve that you need to provide a delegation signature to the contract. The contract will then be able to use the AENS interface and perform AENS related actions on behalf of your account. This functionality could for example be used to build an AENS marketplace. // imports const aeSdk = await Universal ({ ... }) // init the SDK instance with Universal Stamp // contract address const contractId = 'ct_asd2ks...' // AENS name const name = 'example.chain' // Sign with a specific account const onAccount = await aeSdk . address () // this signature will allow the contract to perform a pre-claim on your behalf const preClaimSig = await aeSdk . createAensDelegationSignature ({ contractId }, { onAccount }) // this signature will allow the contract to perform // any name related transaction for a specific name that you own const aensDelegationSig = await aeSdk . createAensDelegationSignature ({ contractId , name }, { onAccount })","title":"AENS (\u00e6ternity naming system)"},{"location":"guides/aens/#aens-ternity-naming-system","text":"","title":"AENS (\u00e6ternity naming system)"},{"location":"guides/aens/#introduction","text":"This guide shows you how to perform all the operations that you need within the lifecycle of \u00e6ternity naming system (AENS) using the SDK. If you successfully claimed a name it will expire after 180000 keyblocks (~375 days). You will need to update your name before it expires!","title":"Introduction"},{"location":"guides/aens/#1-claim-a-name","text":"Claiming an AENS name requires you (at least) 2 transactions: First you need to perform a pre-claim by providing a commitmentId (hash). The commitmentId is calculated with a random salt and the provided name. The SDK automatically generates the random salt , calculates the commitmentId and includes it into the NamePreclaimTx . After the NamePreclaimTx transaction has been mined you will be able to perform the actual claim of the name. When performing the actual claim via a NameClaimTx you will, depending on the length of the name: immediately become owner of that name initiate an auction","title":"1. Claim a name"},{"location":"guides/aens/#pre-claim","text":"// imports const aeSdk = await Universal ({ ... }) // init the SDK instance with Universal Stamp const name = 'testNameForTheGuide.chain' const preClaimTx = await aeSdk . aensPreclaim ( name ) console . log ( preClaimTx ) /* { blockHash: 'mh_2UsggiUaQQmEPjxLnXkXHpm1WawTWqZb1jBx6UzsQNHgirWAwd', blockHeight: 449499, hash: 'th_48RktjEutZC8TCubaq9YhjaF1cKLV9D3VRCJyzJLs7oSp4Ry6', signatures: [ 'sg_Da98k2EKMun1TkE7ytonRypvJwaKg9iBjp8rNcYuodFXqzRqwjQyuFQP5DhxWUpTYRzSTurrNtDmUft8eyTStjCyNqFf8' ], tx: { accountId: 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk', commitmentId: 'cm_2igvW9egddKh77gDdE8mjotmL8PzE7Tf2Q639Q5stUqWQoEfap', fee: 16620000000000, nonce: 18, type: 'NamePreclaimTx', version: 1 }, rawTx: 'tx_+JkLAfhCuEBgFzAL0bPDufmzDq0558vaKtrIyRpNxCYVtkgnJjBrxDpQZHkfbwG+oRuBUAfgfrAKF0lO9mRI1zq0H6bXIq8KuFH4TyEBoQGMyNToF1flcYDSVsPl5DZ9ZY3FJWRpDRQYD32quWBEAhKhA+Jawe/spFaw823K+U59CWx+xD1i34gngUPiAAKJqv/fhg8dpTI4AAAGc20E', height: 449499, claim: [Function: claim], salt: 7595805618692717, commitmentId: 'cm_2igvW9egddKh77gDdE8mjotmL8PzE7Tf2Q639Q5stUqWQoEfap' } */ Note: After transaction is included, you have 300 keyblocks to broadcast claim transaction with the same salt and it should be signed with the same private key as pre-claim . As the pre-claim is required to avoid front running it is recommended to wait with the actual claim until at least 1 keyblock has been mined so that nobody knows which name you aim to claim. The corresponding claim cannot be included in the same keyblock anyway. The protocol doesn't allow that. You should check if the name is still available before performing a pre-claim . The protocol itself doesn't reject a pre-claim transaction if the name isn't available anymore. As you can see above in the logs the result ( preClaimTx ) of the aensPreclaim has bound a claim function that you can make use of to perform the actual claim. In case you want to perform the actual claim at a later point you should remember the salt that has been used for the pre-claim","title":"Pre-claim"},{"location":"guides/aens/#claim","text":"This example assumes that you perform the actual claim manually by having remembered the required salt . In most cases you'd probably use the claim function that is bound to the result of the aensPreclaim function directly (see above). Depending on the length of the name the actual claim will result in direct ownership of the AENS name or start an auction: Name length > 12: ownership of the name is immediately transfered to your account Name length <= 12: an auction is started const salt = 7595805618692717 // salt from pre-claim transaction // the minimum `nameFee` will be automatically generated by sdk // in case you want to provide a custom `nameFee` you can so so by providing it in an options object // in case of starting the auction `nameFee` will be the starting bid const claimTx = await aeSdk . aensClaim ( name , salt ) console . log ( claimTx ) /* { blockHash: 'mh_UvtuVNvK7k29G3anF48W4hgUMaFFLc1wKir55FFifgT49Egk', blockHeight: 449507, hash: 'th_2sWNusGUf2wuRn7d453wPWTAe8pKVbtNF4DqakvippsxjvF8g1', signatures: [ 'sg_LYsVj9zUoKFPDiSvFUWG5QaRhnqQ525YA314xMVzRhApYuPnFyMWgAQGpChKHHWyMbykBwVRrmoQtTENTFCaCoMj17CBK' ], tx: { accountId: 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk', fee: 16800000000000, name: 'testNameForTheGuide.chain', nameFee: '2865700000000000000', nameSalt: '7595805618692717', nonce: 19, type: 'NameClaimTx', version: 2 }, rawTx: 'tx_+KILAfhCuECVba2mm3Un3nrN9U+LpuB2wzqDDmAzXwvc+9sVkpkcALzqm14p7kGqyt8pwjGTyKeLM9lp+KgXWF4PHmHz0WAPuFr4WCACoQGMyNToF1flcYDSVsPl5DZ9ZY3FJWRpDRQYD32quWBEAhOZdGVzdE5hbWVGb3JUaGVHdWlkZS5jaGFpboca/FhPr2JtiCfFAveE1kAAhg9HjghAAADilhgr', id: 'nm_1Cz5HGY8PMWZxNrM6s51CtsJZDU3DDT1LdmpEipa3DRghyGz5', owner: 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk', pointers: [], ttl: 629507, update: [Function (anonymous)], transfer: [Function (anonymous)], revoke: [Function (anonymous)], extendTtl: [Function (anonymous)] } */ Note: The nameFee that is required will be correctly calculated automatically for the initial claim. It's still possible to pass it as additional param, see transaction options . In case the claim triggers an auction the required nameFee is locked by the protocol. If you win the auction the nameFee is permanently deducted from your accounts balance and effectively burned . It will be credited to ak_11111111111111111111111111111111273Yts which nobody can access. This reduces the total supply of AE over time. If somebody else outbids you the provided nameFee is immediately released and returned to your account.","title":"Claim"},{"location":"guides/aens/#bid-during-an-auction","text":"In case there is an auction running for a name you want to claim you need to place a bid. import { computeBidFee , computeAuctionEndBlock } from '@aeternity/aepp-sdk' const name = 'auctiontest1.chain' const startFee = ... // request from middleware, e.g. https://testnet.aeternity.io/mdw/name/auctiontest1.chain const increment = 0.05 // 5%, the minimum required increment // startFee is OPTIONAL and defaults to minimum calculated fee for the name in general // startFee MUST be at least the nameFee of the last bid // increment is OPTIONAL and defaults to 0.05 const nameFee = computeBidFee ( name , startFee , increment ) const bidTx = await aeSdk . aensBid ( name , nameFee ) console . log ( bidTx ) console . log ( `BID PLACED AT ${ bidTx . blockHeight } WILL END AT ${ computeAuctionEndBlock ( name , bidTx . blockHeight ) } ` ) /* { blockHash: 'mh_Y5LDYPtPWzcop2FCbxnwTSwjWo9d3rYcBBcChCEHfzHo2YZpm', blockHeight: 449693, hash: 'th_2nZshewM7FtKSsDEP4zXPsGCe9cdxaFTRrcNjJyE22ktjGidZR', signatures: [ 'sg_7G49bziWjjZAjayBhFffRyfLbmFczs2foJgXcx1n1Vo7iGELQqggdH4w72MqWbNUbM9Jv2EBJnd2LFjv6LJhqTmvJBWyr' ], tx: { accountId: 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk', fee: 16520000000000, name: 'auctiontest1.chain', nameFee: '3159434250000000000', nameSalt: 0, nonce: 24, type: 'NameClaimTx', version: 2 }, rawTx: 'tx_+JQLAfhCuEAv2HQoyLa7krHpcQAsPpWdP+6PJYzdPSifmwNIgpWZtyrdgVD+IGMzzAqxkOQEDeAwc/Oh+dfXPBZpNslCNFgBuEz4SiACoQGMyNToF1flcYDSVsPl5DZ9ZY3FJWRpDRQYD32quWBEAhiSYXVjdGlvbnRlc3QxLmNoYWluAIgr2JC2AnPkAIYPBly7UAAAm/NY1g==', nameFee: BigNumber { s: 1, e: 18, c: [ 31594, 34250000000000 ] } } BID PLACED AT 449693 WILL END AT 479453 */ Note: It is required to provide a nameFee that is at least 5% higher than the current bid. The node doesn't expose an API to request the nameFee of the last bid. You need to receive that information from the middleware that you ideally host yourself.","title":"Bid during an auction"},{"location":"guides/aens/#2-update-a-name","text":"Now that you own your AENS name you might want to update it in order to: Set pointers to accounts , oracles , contracts or channels . Extend the TTL before it expires. By default a name will have a TTL of 180000 keyblocks (~375 days). It cannot be extended longer than 180000 keyblocks.","title":"2. Update a name"},{"location":"guides/aens/#set-pointers-update-ttl","text":"import { getDefaultPointerKey } from '@aeternity/aepp-sdk' const name = 'testNameForTheGuide.chain' const oracle = 'ok_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk' const pointers = { account_pubkey : 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk' , customKey : 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk' , [ getDefaultPointerKey ( oracle )] : oracle , // the same as `oracle_pubkey: oracle,` contract_pubkey : 'ct_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk' , channel : 'ch_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk' , } // using aeSdk directly (instance of Universal Stamp) const nameUpdateTx = await aeSdk . aensUpdate ( name , pointers ) // OR using the instance of a name const nameInstance = await aeSdk . aensQuery ( name ) const nameUpdateTx = await nameInstance . update ( pointers ) console . log ( nameUpdateTx ) /* { blockHash: 'mh_AiaGtTWBRys7EX5apAidShyCw1kefocuWt49DgLE2fWNCgKvq', blockHeight: 449855, hash: 'th_LLef19g2mLWQfG7Ds1XZNGyb3SGvi8PGvk7mJczpD9iToBcqL', signatures: [ 'sg_Zm7kp1oBnXGnHwdzsim9nTXtrGoV4bWJhcC1nkw9f3eMPibVaYQRoM829iNrPandAfs8TK7ogEkYByxQx11xCAFMpwUBz' ], tx: { accountId: 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk', clientTtl: 84600, fee: 17800000000000, nameId: 'nm_1Cz5HGY8PMWZxNrM6s51CtsJZDU3DDT1LdmpEipa3DRghyGz5', nameTtl: 180000, nonce: 27, pointers: [ [Object] ], type: 'NameUpdateTx', version: 1 }, rawTx: 'tx_+NQLAfhCuED6aLVAlIfcqczlZ4XzOjG3U23l5+egPFDVEKTSMuL0Zj18jUG6ctJxGGQubNoANFcwQl79T7w0dG4+FV7Qn3AKuIz4iiIBoQGMyNToF1flcYDSVsPl5DZ9ZY3FJWRpDRQYD32quWBEAhuhAgB4Gsn+dalOdWvHXJd+3LBBiO9HsZoHIF2/aQ4n/bbagwK/IPLxjmFjY291bnRfcHVia2V5oQGMyNToF1flcYDSVsPl5DZ9ZY3FJWRpDRQYD32quWBEAoMBSniGEDBirVAAAJ7I9GA=', id: 'nm_1Cz5HGY8PMWZxNrM6s51CtsJZDU3DDT1LdmpEipa3DRghyGz5', owner: 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk', pointers: [ { id: 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk', key: 'account_pubkey' } ], ttl: 629855, update: [Function (anonymous)], transfer: [Function (anonymous)], revoke: [Function (anonymous)], extendTtl: [Function (anonymous)] } */ Note: It's also possible to pass additional transaction options here, too.","title":"Set pointers &amp; update TTL"},{"location":"guides/aens/#extend-ttl-while-keeping-pointers","text":"In case you want to extend a name using a custom TTL and keep the current pointers you can do this as follows: const name = 'testNameForTheGuide.chain' // using aeSdk directly (instance of Universal Stamp) const nameUpdateTx = await aeSdk . aensUpdate ( name , {}, { nameTtl : 100000 , extendPointers : true }) // OR using the instance of a name const nameInstance = await aeSdk . aensQuery ( name ) const nameUpdateTx = await nameInstance . update ({}, { nameTtl : 100000 , extendPointers : true }) console . log ( nameUpdateTx ) /* { blockHash: 'mh_2mbAuBtyPp7wN6hrcvkYD7LZRSegwZZKYnLcNQkGVGRZ3uVxW6', blockHeight: 449860, hash: 'th_2wXE8i5BUFCUPuioKwAuwNysm6RPQo8STf5m91CuT3LTh7q4ko', signatures: [ 'sg_E69tfR3STWi5Dg6yUHQj5D5waTCEhoFmb1LYWGU2bsCnuLkMgH1KqhRKrCZaatDMyg5szgABDuU1r6ZD5K74qXWW5pMJ' ], tx: { accountId: 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk', clientTtl: 100000, fee: 17800000000000, nameId: 'nm_1Cz5HGY8PMWZxNrM6s51CtsJZDU3DDT1LdmpEipa3DRghyGz5', nameTtl: 100000, nonce: 28, pointers: [ [Object] ], type: 'NameUpdateTx', version: 1 }, rawTx: 'tx_+NQLAfhCuEABuZTyU+W5xmBpQn5GCJiSpK6fI0pYoMIQ5IqD2bs6pJ+oyU7HDGoSU0Mn6tsfYOn+MVRsxLR6yM1Vyv0c4JQNuIz4iiIBoQGMyNToF1flcYDSVsPl5DZ9ZY3FJWRpDRQYD32quWBEAhyhAgB4Gsn+dalOdWvHXJd+3LBBiO9HsZoHIF2/aQ4n/bbagwGGoPLxjmFjY291bnRfcHVia2V5oQGMyNToF1flcYDSVsPl5DZ9ZY3FJWRpDRQYD32quWBEAoMBhqCGEDBirVAAANKYAm0=' } */ Note: If you provide a non-empty array of pointers to that function while using extendPointers the SDK will merge the existing pointers with those provided. In case there already exists an account pointer and you provide an accounts address in the array the old account pointer will be overwritten If you provide an empty array and don't set extendPointers to true all of your current pointers will be removed.","title":"Extend TTL while keeping pointers"},{"location":"guides/aens/#3-transfer-ownership-of-a-name","text":"In some cases you might want to transfer the ownership of a name to another account. Of course this is also possible and you can do that as follows: const recipient = 'ak_...' // using aeSdk directly (instance of Universal Stamp) const nameTransferTx = await aeSdk . aensTransfer ( name , recipient ) // OR using the instance of a name const nameInstance = await aeSdk . aensQuery ( name ) const nameTransferTx = await nameInstance . transfer ( recipient ) console . log ( nameTransferTx ) /* { blockHash: 'mh_ZuYV5tmJM4PhrfxzXfo9e37uqPcYpCiAoEC2uRcqbUXeMSmLH', blockHeight: 449982, hash: 'th_xXqmZxR7WJDe6YTz1GnHWgNjtcZjpTPA5bVuiQstmd8o6Gg7x', signatures: [ 'sg_72fiMzprywNmFtuf1i1FFfhBBXcPHpHDfi1Uv2bDnYayoCRWe1yyzvwLmhM6cfA3TR6pBF9Kj3iyYm3mrC46rvNCpchyi' ], tx: { accountId: 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk', fee: 17300000000000, nameId: 'nm_1Cz5HGY8PMWZxNrM6s51CtsJZDU3DDT1LdmpEipa3DRghyGz5', nonce: 33, recipientId: 'ak_2dATVcZ9KJU5a8hdsVtTv21pYiGWiPbmVcU1Pz72FFqpk9pSRR', type: 'NameTransferTx', version: 1 }, rawTx: 'tx_+LsLAfhCuEAuFNHG4gniZjJDQtbm5cIfJACkU/NI96mZpwMvdyuxxOYWYxSxUF2NF5oxjmsYLdXWfSrdmgWj40JzZU/TRA4DuHP4cSQBoQGMyNToF1flcYDSVsPl5DZ9ZY3FJWRpDRQYD32quWBEAiGhAgB4Gsn+dalOdWvHXJd+3LBBiO9HsZoHIF2/aQ4n/bbaoQHVzwhADpiCIvJutLAsj4kHdFdGchGm5tlV7bcHScajO4YPu/hayAAABhgUgg==' } */","title":"3. Transfer ownership of a name"},{"location":"guides/aens/#4-revoke-a-name","text":"In case you want to revoke a name prior to its expiration for whatever reason you can do that as follows: // using aeSdk directly (instance of Universal Stamp) const nameRevokeTx = await aeSdk . aensRevoke ( name ) // OR using the instance of a name const nameInstance = await aeSdk . aensQuery ( name ) const nameRevokeTx = await nameInstance . revoke () console . log ( nameRevokeTx ) /* { blockHash: 'mh_2Q5Xqd4vrmwkS98SBkN79k1t9VLNmDX4wk8xnUJYTEvkK3YoH4', blockHeight: 450018, hash: 'th_2XhJradAVKN2jR2tgNYdKNWikMc8XunqTdUhRPh2TyhAwMqijJ', signatures: [ 'sg_Tjbf8SJDQXgBhaYk7AzTTr7d1RF3bDcMp6BMgRoHcHcgBp13HjcMYmZJ8vvqrZ94An9gvQD4NegYrR7eaBLt6jEy99xyM' ], tx: { accountId: 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk', fee: 16620000000000, nameId: 'nm_1Cz5HGY8PMWZxNrM6s51CtsJZDU3DDT1LdmpEipa3DRghyGz5', nonce: 34, type: 'NameRevokeTx', version: 1 }, rawTx: 'tx_+JkLAfhCuEDMWOZac70tEHQ4AHGBIedZepwTvsBjIHk36vhTd5yBepmTemTQcUVrAtbNO3jZVZD4GUOhN+DfXm2lNrpZu+8FuFH4TyMBoQGMyNToF1flcYDSVsPl5DZ9ZY3FJWRpDRQYD32quWBEAiKhAgB4Gsn+dalOdWvHXJd+3LBBiO9HsZoHIF2/aQ4n/bbahg8dpTI4AAB44bma' } */ Note: On revocation the name enters in a revoked state. After a timeout of 2016 keyblocks the name will be available for claiming again.","title":"4. Revoke a name"},{"location":"guides/aens/#delegate-signature-to-contract-aens-interface","text":"It is possible to authorize a Sophia contract to manage an AENS name on behalf of your account. In order to achieve that you need to provide a delegation signature to the contract. The contract will then be able to use the AENS interface and perform AENS related actions on behalf of your account. This functionality could for example be used to build an AENS marketplace. // imports const aeSdk = await Universal ({ ... }) // init the SDK instance with Universal Stamp // contract address const contractId = 'ct_asd2ks...' // AENS name const name = 'example.chain' // Sign with a specific account const onAccount = await aeSdk . address () // this signature will allow the contract to perform a pre-claim on your behalf const preClaimSig = await aeSdk . createAensDelegationSignature ({ contractId }, { onAccount }) // this signature will allow the contract to perform // any name related transaction for a specific name that you own const aensDelegationSig = await aeSdk . createAensDelegationSignature ({ contractId , name }, { onAccount })","title":"Delegate signature to contract (AENS interface)"},{"location":"guides/batch-requests/","text":"Batch Transactions Introduction In some cases, aepp developer may need to send a set of transactions at once. The SDK provides optimizations for this scenario but it also requires additional effort by the developer. This guide covers specific cases with suggestions on how to proceed with them to produce a sequence of requests in an efficient way. Multiple spend transactions Obviously, multiple spends may be done like: for ( const { address , amount } of spends ) { await aeSdk . spend ( amount , address ) } But this isn't the fastest approach, because on each iteration SDK would: request the sender data (its type and nonce) verify the transaction (including additional requests) wait until the transaction is mined It can be avoided by making spends as: const base = ( await aeSdk . api . getAccountNextNonce ( await aeSdk . address ())). nextNonce await Promise . all ( spends . map (({ amount , address }, idx ) => aeSdk . spend ( amount , address , { nonce : base + idx , verify : false , waitMined : false })) ) This way, SDK would make a single request to get info about the sender account and a transaction post request per each item in the spends array. Multiple contract static calls Basically, the dry-run endpoint of the node is used to run them. Doing requests one by one, like const results = [] for ( const d of data ) { results . push ( await contractInstance . methods . foo ( d )) } will make SDK create a new dry-run request for each static call. It may be not efficient because dry-run supports executing multiple transactions at a single request. It can be done by making all calls at once: const base = ( await aeSdk . api . getAccountNextNonce ( await aeSdk . address ())). nextNonce const results = await Promise . all ( data . map (( d , idx ) => contractInstance . methods . foo ( d , { nonce : base + idx , combine : true })) ) With combine flag SDK would put all of them into a single dry-run request. Also, it is necessary to generate increasing nonces on the aepp side to avoid nonce-already-used errors. This approach has another limitation: by default, dry-run is limited by 6000000 gas. This is enough to execute only 32 plain contract calls. it can be avoided by: increasing the default gas limit of restricted dry-run endpoint in node configuration decreasing the gas limit of each static call using a debug dry-run endpoint instead of the restricted one","title":"Batch Transactions"},{"location":"guides/batch-requests/#batch-transactions","text":"","title":"Batch Transactions"},{"location":"guides/batch-requests/#introduction","text":"In some cases, aepp developer may need to send a set of transactions at once. The SDK provides optimizations for this scenario but it also requires additional effort by the developer. This guide covers specific cases with suggestions on how to proceed with them to produce a sequence of requests in an efficient way.","title":"Introduction"},{"location":"guides/batch-requests/#multiple-spend-transactions","text":"Obviously, multiple spends may be done like: for ( const { address , amount } of spends ) { await aeSdk . spend ( amount , address ) } But this isn't the fastest approach, because on each iteration SDK would: request the sender data (its type and nonce) verify the transaction (including additional requests) wait until the transaction is mined It can be avoided by making spends as: const base = ( await aeSdk . api . getAccountNextNonce ( await aeSdk . address ())). nextNonce await Promise . all ( spends . map (({ amount , address }, idx ) => aeSdk . spend ( amount , address , { nonce : base + idx , verify : false , waitMined : false })) ) This way, SDK would make a single request to get info about the sender account and a transaction post request per each item in the spends array.","title":"Multiple spend transactions"},{"location":"guides/batch-requests/#multiple-contract-static-calls","text":"Basically, the dry-run endpoint of the node is used to run them. Doing requests one by one, like const results = [] for ( const d of data ) { results . push ( await contractInstance . methods . foo ( d )) } will make SDK create a new dry-run request for each static call. It may be not efficient because dry-run supports executing multiple transactions at a single request. It can be done by making all calls at once: const base = ( await aeSdk . api . getAccountNextNonce ( await aeSdk . address ())). nextNonce const results = await Promise . all ( data . map (( d , idx ) => contractInstance . methods . foo ( d , { nonce : base + idx , combine : true })) ) With combine flag SDK would put all of them into a single dry-run request. Also, it is necessary to generate increasing nonces on the aepp side to avoid nonce-already-used errors. This approach has another limitation: by default, dry-run is limited by 6000000 gas. This is enough to execute only 32 plain contract calls. it can be avoided by: increasing the default gas limit of restricted dry-run endpoint in node configuration decreasing the gas limit of each static call using a debug dry-run endpoint instead of the restricted one","title":"Multiple contract static calls"},{"location":"guides/build-wallet/","text":"How to build a wallet This guide shows how to build either an WebExtension Wallet or a iFrame-based Wallet . WebExtension wallet The full implementation of this example can be found here: WebExtension Wallet Example Note: If you want to see a more advanced implementation you can take a look into the repository of the Superhero Wallet 1. Create bridge between extension and page First you need to create a bridge between your extension and the page. This can be done as follows: import browser from 'webextension-polyfill' import { BrowserRuntimeConnection , BrowserWindowMessageConnection , MESSAGE_DIRECTION , connectionProxy } from '@aeternity/aepp-sdk' const readyStateCheckInterval = setInterval ( function () { if ( document . readyState === 'complete' ) { clearInterval ( readyStateCheckInterval ) const port = browser . runtime . connect () const extConnection = new BrowserRuntimeConnection ({ port }) const pageConnection = new BrowserWindowMessageConnection ({ target : window , origin : window . origin , sendDirection : MESSAGE_DIRECTION . to_aepp , receiveDirection : MESSAGE_DIRECTION . to_waellet }) connectionProxy ( pageConnection , extConnection ) } }, 10 ) 2. Initialize RpcWallet Stamp Then you need to initialize RpcWallet Stamp in your extension and subscribe for new runtime connections. After the connection is established you can share the wallet details with the application. import browser from 'webextension-polyfill' // ideally this can be configured by the users of the extension const NODE_URL = 'https://testnet.aeternity.io' const COMPILER_URL = 'https://compiler.aepps.com' const accounts = [ MemoryAccount ({ keypair : generateKeyPair () }), // generate keypair for account1 MemoryAccount ({ keypair : generateKeyPair () }) // generate keypair for account2 ] async function init () { // Init extension stamp from sdk RpcWallet ({ compilerUrl : COMPILER_URL , nodes : [{ name : 'testnet' , instance : await Node ({ url : NODE_URL }) }], id : browser . runtime . id , type : WALLET_TYPE . extension , name : 'Wallet WebExtension' , // The `ExtensionProvider` uses the first account by default. You can change active account using `selectAccount(address)` function accounts , // Hook for sdk registration onConnection ( aepp , action ) { if ( confirm ( `Aepp ${ aepp . info . name } with id ${ aepp . id } wants to connect` )) { action . accept () } else { action . deny () } }, onDisconnect ( msg , client ) { console . log ( 'Disconnect client: ' , client ) }, onSubscription ( aepp , action ) { if ( confirm ( `Aepp ${ aepp . info . name } with id ${ aepp . id } wants to subscribe for accounts` )) { action . accept () } else { action . deny () } }, onSign ( aepp , action ) { if ( confirm ( `Aepp ${ aepp . info . name } with id ${ aepp . id } wants to sign tx ${ action . params . tx } ` )) { action . accept () } else { action . deny () } }, onAskAccounts ( aepp , action ) { if ( confirm ( `Aepp ${ aepp . info . name } with id ${ aepp . id } wants to get accounts` )) { action . accept () } else { action . deny () } }, onMessageSign ( aepp , action ) { if ( confirm ( `Aepp ${ aepp . info . name } with id ${ aepp . id } wants to sign msg ${ action . params . message } ` )) { action . accept () } else { action . deny () } } }). then ( wallet => { chrome . runtime . onConnect . addListener ( async function ( port ) { // create connection const connection = new BrowserRuntimeConnection ({ port }) // add new aepp to wallet wallet . addRpcClient ( connection ) // share wallet details wallet . shareWalletInfo ( port . postMessage . bind ( port )) setTimeout (() => wallet . shareWalletInfo ( port . postMessage . bind ( port )), 3000 ) }) }). catch ( err => { console . error ( err ) }) } init (). then ( _ => console . log ( 'Wallet initialized!' )) 2. Sharing wallet node with AEPP AEPP can request the wallet for its connected node URLs. Wallet can selectively accept or reject the connection request using the AEPP information(name, id, domain) // ideally this can be configured by the users of the extension const NODE_URL = 'https://testnet.aeternity.io' const COMPILER_URL = 'https://compiler.aepps.com' const accounts = [ MemoryAccount ({ keypair : generateKeyPair () }), // generate keypair for account1 MemoryAccount ({ keypair : generateKeyPair () }) // generate keypair for account2 ] async function init () { // Init extension stamp from sdk RpcWallet ({ compilerUrl : COMPILER_URL , nodes : [{ name : 'testnet' , instance : await Node ({ url : NODE_URL }) }], id : browser . runtime . id , type : WALLET_TYPE . extension , name : 'Wallet WebExtension' , // The `ExtensionProvider` uses the first account by default. You can change active account using `selectAccount(address)` function accounts , // Hook for sdk registration onConnection ( aepp , action ) { if ( confirm ( `Aepp ${ aepp . info . name } with id ${ aepp . id } wants to connect` )) { // Whitelist aepp domains for node connection const aepps = [ 'https://test' , 'https://aepp.aeternity.com' ] if ( aepp . info . connectNode && aepps . includes ( aepp . info . origin )) { action . accept ({ shareNode : true }) } action . accept () // Accept wallet connection without sharing node URLs } else { action . deny () } }, onDisconnect ( msg , client ) { console . log ( 'Disconnect client: ' , client ) }, onSubscription ( aepp , action ) { if ( confirm ( `Aepp ${ aepp . info . name } with id ${ aepp . id } wants to subscribe for accounts` )) { action . accept () } else { action . deny () } }, onSign ( aepp , action ) { if ( confirm ( `Aepp ${ aepp . info . name } with id ${ aepp . id } wants to sign tx ${ action . params . tx } ` )) { action . accept () } else { action . deny () } }, onAskAccounts ( aepp , action ) { if ( confirm ( `Aepp ${ aepp . info . name } with id ${ aepp . id } wants to get accounts` )) { action . accept () } else { action . deny () } }, onMessageSign ( aepp , action ) { if ( confirm ( `Aepp ${ aepp . info . name } with id ${ aepp . id } wants to sign msg ${ action . params . message } ` )) { action . accept () } else { action . deny () } } }). then ( wallet => { chrome . runtime . onConnect . addListener ( async function ( port ) { // create connection const connection = new BrowserRuntimeConnection ({ port }) // add new aepp to wallet wallet . addRpcClient ( connection ) // share wallet details wallet . shareWalletInfo ( port . postMessage . bind ( port )) setTimeout (() => wallet . shareWalletInfo ( port . postMessage . bind ( port )), 3000 ) }) }). catch ( err => { console . error ( err ) }) } init (). then ( _ => console . log ( 'Wallet initialized!' )) iFrame-based Wallet The iFrame-based approach works similar to the WebExtension approach except that the connectionProxy in between isn't needed. You can take a look into the implementation of the following example to see how it works: iFrame-based Wallet Example","title":"How to build a wallet"},{"location":"guides/build-wallet/#how-to-build-a-wallet","text":"This guide shows how to build either an WebExtension Wallet or a iFrame-based Wallet .","title":"How to build a wallet"},{"location":"guides/build-wallet/#webextension-wallet","text":"The full implementation of this example can be found here: WebExtension Wallet Example Note: If you want to see a more advanced implementation you can take a look into the repository of the Superhero Wallet","title":"WebExtension wallet"},{"location":"guides/build-wallet/#1-create-bridge-between-extension-and-page","text":"First you need to create a bridge between your extension and the page. This can be done as follows: import browser from 'webextension-polyfill' import { BrowserRuntimeConnection , BrowserWindowMessageConnection , MESSAGE_DIRECTION , connectionProxy } from '@aeternity/aepp-sdk' const readyStateCheckInterval = setInterval ( function () { if ( document . readyState === 'complete' ) { clearInterval ( readyStateCheckInterval ) const port = browser . runtime . connect () const extConnection = new BrowserRuntimeConnection ({ port }) const pageConnection = new BrowserWindowMessageConnection ({ target : window , origin : window . origin , sendDirection : MESSAGE_DIRECTION . to_aepp , receiveDirection : MESSAGE_DIRECTION . to_waellet }) connectionProxy ( pageConnection , extConnection ) } }, 10 )","title":"1. Create bridge between extension and page"},{"location":"guides/build-wallet/#2-initialize-rpcwallet-stamp","text":"Then you need to initialize RpcWallet Stamp in your extension and subscribe for new runtime connections. After the connection is established you can share the wallet details with the application. import browser from 'webextension-polyfill' // ideally this can be configured by the users of the extension const NODE_URL = 'https://testnet.aeternity.io' const COMPILER_URL = 'https://compiler.aepps.com' const accounts = [ MemoryAccount ({ keypair : generateKeyPair () }), // generate keypair for account1 MemoryAccount ({ keypair : generateKeyPair () }) // generate keypair for account2 ] async function init () { // Init extension stamp from sdk RpcWallet ({ compilerUrl : COMPILER_URL , nodes : [{ name : 'testnet' , instance : await Node ({ url : NODE_URL }) }], id : browser . runtime . id , type : WALLET_TYPE . extension , name : 'Wallet WebExtension' , // The `ExtensionProvider` uses the first account by default. You can change active account using `selectAccount(address)` function accounts , // Hook for sdk registration onConnection ( aepp , action ) { if ( confirm ( `Aepp ${ aepp . info . name } with id ${ aepp . id } wants to connect` )) { action . accept () } else { action . deny () } }, onDisconnect ( msg , client ) { console . log ( 'Disconnect client: ' , client ) }, onSubscription ( aepp , action ) { if ( confirm ( `Aepp ${ aepp . info . name } with id ${ aepp . id } wants to subscribe for accounts` )) { action . accept () } else { action . deny () } }, onSign ( aepp , action ) { if ( confirm ( `Aepp ${ aepp . info . name } with id ${ aepp . id } wants to sign tx ${ action . params . tx } ` )) { action . accept () } else { action . deny () } }, onAskAccounts ( aepp , action ) { if ( confirm ( `Aepp ${ aepp . info . name } with id ${ aepp . id } wants to get accounts` )) { action . accept () } else { action . deny () } }, onMessageSign ( aepp , action ) { if ( confirm ( `Aepp ${ aepp . info . name } with id ${ aepp . id } wants to sign msg ${ action . params . message } ` )) { action . accept () } else { action . deny () } } }). then ( wallet => { chrome . runtime . onConnect . addListener ( async function ( port ) { // create connection const connection = new BrowserRuntimeConnection ({ port }) // add new aepp to wallet wallet . addRpcClient ( connection ) // share wallet details wallet . shareWalletInfo ( port . postMessage . bind ( port )) setTimeout (() => wallet . shareWalletInfo ( port . postMessage . bind ( port )), 3000 ) }) }). catch ( err => { console . error ( err ) }) } init (). then ( _ => console . log ( 'Wallet initialized!' ))","title":"2. Initialize RpcWallet Stamp"},{"location":"guides/build-wallet/#2-sharing-wallet-node-with-aepp","text":"AEPP can request the wallet for its connected node URLs. Wallet can selectively accept or reject the connection request using the AEPP information(name, id, domain) // ideally this can be configured by the users of the extension const NODE_URL = 'https://testnet.aeternity.io' const COMPILER_URL = 'https://compiler.aepps.com' const accounts = [ MemoryAccount ({ keypair : generateKeyPair () }), // generate keypair for account1 MemoryAccount ({ keypair : generateKeyPair () }) // generate keypair for account2 ] async function init () { // Init extension stamp from sdk RpcWallet ({ compilerUrl : COMPILER_URL , nodes : [{ name : 'testnet' , instance : await Node ({ url : NODE_URL }) }], id : browser . runtime . id , type : WALLET_TYPE . extension , name : 'Wallet WebExtension' , // The `ExtensionProvider` uses the first account by default. You can change active account using `selectAccount(address)` function accounts , // Hook for sdk registration onConnection ( aepp , action ) { if ( confirm ( `Aepp ${ aepp . info . name } with id ${ aepp . id } wants to connect` )) { // Whitelist aepp domains for node connection const aepps = [ 'https://test' , 'https://aepp.aeternity.com' ] if ( aepp . info . connectNode && aepps . includes ( aepp . info . origin )) { action . accept ({ shareNode : true }) } action . accept () // Accept wallet connection without sharing node URLs } else { action . deny () } }, onDisconnect ( msg , client ) { console . log ( 'Disconnect client: ' , client ) }, onSubscription ( aepp , action ) { if ( confirm ( `Aepp ${ aepp . info . name } with id ${ aepp . id } wants to subscribe for accounts` )) { action . accept () } else { action . deny () } }, onSign ( aepp , action ) { if ( confirm ( `Aepp ${ aepp . info . name } with id ${ aepp . id } wants to sign tx ${ action . params . tx } ` )) { action . accept () } else { action . deny () } }, onAskAccounts ( aepp , action ) { if ( confirm ( `Aepp ${ aepp . info . name } with id ${ aepp . id } wants to get accounts` )) { action . accept () } else { action . deny () } }, onMessageSign ( aepp , action ) { if ( confirm ( `Aepp ${ aepp . info . name } with id ${ aepp . id } wants to sign msg ${ action . params . message } ` )) { action . accept () } else { action . deny () } } }). then ( wallet => { chrome . runtime . onConnect . addListener ( async function ( port ) { // create connection const connection = new BrowserRuntimeConnection ({ port }) // add new aepp to wallet wallet . addRpcClient ( connection ) // share wallet details wallet . shareWalletInfo ( port . postMessage . bind ( port )) setTimeout (() => wallet . shareWalletInfo ( port . postMessage . bind ( port )), 3000 ) }) }). catch ( err => { console . error ( err ) }) } init (). then ( _ => console . log ( 'Wallet initialized!' ))","title":"2. Sharing wallet node with AEPP"},{"location":"guides/build-wallet/#iframe-based-wallet","text":"The iFrame-based approach works similar to the WebExtension approach except that the connectionProxy in between isn't needed. You can take a look into the implementation of the following example to see how it works: iFrame-based Wallet Example","title":"iFrame-based Wallet"},{"location":"guides/connect-aepp-to-wallet/","text":"Connect an \u00e6pp to a wallet This guide describes the 4 steps that are necessary to connect your application to a wallet using the RPC API. Prerequisites Install Superhero Wallet extension for simplicity of example. You can build your own wallet in the next example 1. Specify imports and constants and state import { RpcAepp , walletDetector , BrowserWindowMessageConnection , Node } from '@aeternity/aepp-sdk' const TESTNET_NODE_URL = 'https://testnet.aeternity.io' const MAINNET_NODE_URL = 'https://mainnet.aeternity.io' const COMPILER_URL = 'https://compiler.aepps.com' ; export default { data : () => ({ aeSdk : null , address : '' , balance : 0 , nodeInfo : null , connectedAccounts : null }), } 2. Initialize the RpcAepp Stamp async created () { this . aeSdk = await RpcAepp ({ name : 'Simple Aepp' , nodes : [ { name : 'ae_uat' , instance : await Node ({ url : TESTNET_NODE_URL }) }, { name : 'ae_mainnet' , instance : await Node ({ url : MAINNET_NODE_URL }) } ], compilerUrl : COMPILER_URL , onNetworkChange : async ({ networkId }) => { this . aeSdk . selectNode ( networkId ) this . nodeInfo = await this . aeSdk . getNodeInfo () }, onAddressChange : async () => { this . address = await this . aeSdk . address () this . balance = await this . aeSdk . getBalance ( this . address ) }, onDisconnect : () => { // you may want to reset state here alert ( 'Disconnected' ) } }) this . scanForWallets () } 3. Scan for wallets methods : { async scanForWallets () { const handleWallets = async function ({ wallets , newWallet }) { newWallet = newWallet || Object . values ( wallets )[ 0 ] if ( confirm ( `Do you want to connect to wallet ${ newWallet . name } ` )) { stopScan () // connect to the wallet, see step 4. await this . connect ( newWallet ) } } const scannerConnection = new BrowserWindowMessageConnection () const stopScan = walletDetector ( scannerConnection , handleWallets . bind ( this )) } } 4. Connect to a wallet Append method for wallet connection async connect ( wallet ) { await this . aeSdk . connectToWallet ( wallet . info , wallet . getConnection ()) this . connectedAccounts = await this . aeSdk . subscribeAddress ( 'subscribe' , 'connected' ) this . address = await this . aeSdk . address () this . balance = await this . aeSdk . getBalance ( this . address ). catch (() => '0' ) this . nodeInfo = await this . aeSdk . getNodeInfo () } 4. Use Wallet's Node for chain communication Aepp can request the wallet to share its connected node URLs if any to interact with the chain. async connect ( wallet ) { await this . aeSdk . connectToWallet ( wallet . info , wallet . getConnection (), { connectNode : true , name : 'wallet-node' , select : true }) } Note: The steps above are snippets taken from the full implementation of the Simple \u00e6pp","title":"Connect an \u00e6pp to a wallet"},{"location":"guides/connect-aepp-to-wallet/#connect-an-pp-to-a-wallet","text":"This guide describes the 4 steps that are necessary to connect your application to a wallet using the RPC API.","title":"Connect an \u00e6pp to a wallet"},{"location":"guides/connect-aepp-to-wallet/#prerequisites","text":"Install Superhero Wallet extension for simplicity of example. You can build your own wallet in the next example","title":"Prerequisites"},{"location":"guides/connect-aepp-to-wallet/#1-specify-imports-and-constants-and-state","text":"import { RpcAepp , walletDetector , BrowserWindowMessageConnection , Node } from '@aeternity/aepp-sdk' const TESTNET_NODE_URL = 'https://testnet.aeternity.io' const MAINNET_NODE_URL = 'https://mainnet.aeternity.io' const COMPILER_URL = 'https://compiler.aepps.com' ; export default { data : () => ({ aeSdk : null , address : '' , balance : 0 , nodeInfo : null , connectedAccounts : null }), }","title":"1. Specify imports and constants and state"},{"location":"guides/connect-aepp-to-wallet/#2-initialize-the-rpcaepp-stamp","text":"async created () { this . aeSdk = await RpcAepp ({ name : 'Simple Aepp' , nodes : [ { name : 'ae_uat' , instance : await Node ({ url : TESTNET_NODE_URL }) }, { name : 'ae_mainnet' , instance : await Node ({ url : MAINNET_NODE_URL }) } ], compilerUrl : COMPILER_URL , onNetworkChange : async ({ networkId }) => { this . aeSdk . selectNode ( networkId ) this . nodeInfo = await this . aeSdk . getNodeInfo () }, onAddressChange : async () => { this . address = await this . aeSdk . address () this . balance = await this . aeSdk . getBalance ( this . address ) }, onDisconnect : () => { // you may want to reset state here alert ( 'Disconnected' ) } }) this . scanForWallets () }","title":"2. Initialize the RpcAepp Stamp"},{"location":"guides/connect-aepp-to-wallet/#3-scan-for-wallets","text":"methods : { async scanForWallets () { const handleWallets = async function ({ wallets , newWallet }) { newWallet = newWallet || Object . values ( wallets )[ 0 ] if ( confirm ( `Do you want to connect to wallet ${ newWallet . name } ` )) { stopScan () // connect to the wallet, see step 4. await this . connect ( newWallet ) } } const scannerConnection = new BrowserWindowMessageConnection () const stopScan = walletDetector ( scannerConnection , handleWallets . bind ( this )) } }","title":"3. Scan for wallets"},{"location":"guides/connect-aepp-to-wallet/#4-connect-to-a-wallet","text":"Append method for wallet connection async connect ( wallet ) { await this . aeSdk . connectToWallet ( wallet . info , wallet . getConnection ()) this . connectedAccounts = await this . aeSdk . subscribeAddress ( 'subscribe' , 'connected' ) this . address = await this . aeSdk . address () this . balance = await this . aeSdk . getBalance ( this . address ). catch (() => '0' ) this . nodeInfo = await this . aeSdk . getNodeInfo () }","title":"4. Connect to a wallet"},{"location":"guides/connect-aepp-to-wallet/#4-use-wallets-node-for-chain-communication","text":"Aepp can request the wallet to share its connected node URLs if any to interact with the chain. async connect ( wallet ) { await this . aeSdk . connectToWallet ( wallet . info , wallet . getConnection (), { connectNode : true , name : 'wallet-node' , select : true }) } Note: The steps above are snippets taken from the full implementation of the Simple \u00e6pp","title":"4. Use Wallet's Node for chain communication"},{"location":"guides/contract-events/","text":"Contract Events The Sophia language also provides you the possibility to emit Events in your functions. On this page you will learn how to access and decode the event log of a specific transaction. EventEmitter contract This example contract that emits events will be used in the following examples: contract EventEmitter = datatype event = FirstEvent ( int ) | AnotherEvent ( indexed address , string ) entrypoint emitEvents ( value : int , msg : string ) = Chain . event ( FirstEvent ( value )) Chain . event ( AnotherEvent ( Call . caller , msg )) Decode events using ACI When initializing a contract instance using the source code and providing the ACI or obtaining it via http compiler (default) you will be able to access the emitEvents entrypoint of the Sophia contract above as follows: // events emitted by contract calls are automatically decoded const tx = await contractInstance . methods . emitEvents ( 1337 , \"this message is not indexed\" ) console . log ( tx . decodedEvents ) /* [ { name: 'AnotherEvent', args: [ 'fUq2NesPXcYZ1CcqBcGC3StpdnQw3iVxMA3YSeCNAwfN4myQk', 'this message is not indexed' ], contract: { name: 'EventEmitter', address: 'ct_6y3N9KqQb74QsvR9NrESyhWeLNiA9aJgJ7ua8CvsTuGot6uzh' } }, { name: 'FirstEvent', args: [1337n], contract: { name: 'EventEmitter', address: 'ct_6y3N9KqQb74QsvR9NrESyhWeLNiA9aJgJ7ua8CvsTuGot6uzh' } } ] */ Note: As you can see the event log will be automatically decoded in case you perform a ContractCallTx directly Of course it is also possible to decode the event log if you request the transaction details from the node for a transaction that has been mined already. You can request the transaction details by providing the tx-hash and then decode the event log using the contractInstance as follows: const txHash = 'th_2YV3AmAz2kXdTnQxXtR2uxQi3KuLS9wfvXyqKkQQ2Y6dE6RnET' ; // aeSdk is an instance of the Universal Stamp const txInfo = await aeSdk . api . getTransactionInfoByHash ( txHash ) // decode events using contract instance const decodedUsingInstance = contractInstance . decodeEvents ( txInfo . callInfo . log ) console . log ( decodedUsingInstance ) /* [ { name: 'AnotherEvent', args: [ 'fUq2NesPXcYZ1CcqBcGC3StpdnQw3iVxMA3YSeCNAwfN4myQk', 'this message is not indexed' ], contract: { name: 'EventEmitter', address: 'ct_fKhQBiNQkDfoZcVF1ZzPzY7Lig6FnHDCLyFYBY33ZjfzGYPps' } }, { name: 'FirstEvent', args: [1337n], contract: { name: 'EventEmitter', address: 'ct_fKhQBiNQkDfoZcVF1ZzPzY7Lig6FnHDCLyFYBY33ZjfzGYPps' } } ] */","title":"Contract Events"},{"location":"guides/contract-events/#contract-events","text":"The Sophia language also provides you the possibility to emit Events in your functions. On this page you will learn how to access and decode the event log of a specific transaction.","title":"Contract Events"},{"location":"guides/contract-events/#eventemitter-contract","text":"This example contract that emits events will be used in the following examples: contract EventEmitter = datatype event = FirstEvent ( int ) | AnotherEvent ( indexed address , string ) entrypoint emitEvents ( value : int , msg : string ) = Chain . event ( FirstEvent ( value )) Chain . event ( AnotherEvent ( Call . caller , msg ))","title":"EventEmitter contract"},{"location":"guides/contract-events/#decode-events-using-aci","text":"When initializing a contract instance using the source code and providing the ACI or obtaining it via http compiler (default) you will be able to access the emitEvents entrypoint of the Sophia contract above as follows: // events emitted by contract calls are automatically decoded const tx = await contractInstance . methods . emitEvents ( 1337 , \"this message is not indexed\" ) console . log ( tx . decodedEvents ) /* [ { name: 'AnotherEvent', args: [ 'fUq2NesPXcYZ1CcqBcGC3StpdnQw3iVxMA3YSeCNAwfN4myQk', 'this message is not indexed' ], contract: { name: 'EventEmitter', address: 'ct_6y3N9KqQb74QsvR9NrESyhWeLNiA9aJgJ7ua8CvsTuGot6uzh' } }, { name: 'FirstEvent', args: [1337n], contract: { name: 'EventEmitter', address: 'ct_6y3N9KqQb74QsvR9NrESyhWeLNiA9aJgJ7ua8CvsTuGot6uzh' } } ] */ Note: As you can see the event log will be automatically decoded in case you perform a ContractCallTx directly Of course it is also possible to decode the event log if you request the transaction details from the node for a transaction that has been mined already. You can request the transaction details by providing the tx-hash and then decode the event log using the contractInstance as follows: const txHash = 'th_2YV3AmAz2kXdTnQxXtR2uxQi3KuLS9wfvXyqKkQQ2Y6dE6RnET' ; // aeSdk is an instance of the Universal Stamp const txInfo = await aeSdk . api . getTransactionInfoByHash ( txHash ) // decode events using contract instance const decodedUsingInstance = contractInstance . decodeEvents ( txInfo . callInfo . log ) console . log ( decodedUsingInstance ) /* [ { name: 'AnotherEvent', args: [ 'fUq2NesPXcYZ1CcqBcGC3StpdnQw3iVxMA3YSeCNAwfN4myQk', 'this message is not indexed' ], contract: { name: 'EventEmitter', address: 'ct_fKhQBiNQkDfoZcVF1ZzPzY7Lig6FnHDCLyFYBY33ZjfzGYPps' } }, { name: 'FirstEvent', args: [1337n], contract: { name: 'EventEmitter', address: 'ct_fKhQBiNQkDfoZcVF1ZzPzY7Lig6FnHDCLyFYBY33ZjfzGYPps' } } ] */","title":"Decode events using ACI"},{"location":"guides/contracts/","text":"Contracts Introduction The smart contract language of the \u00e6ternity blockchain is Sophia . It is a functional language in the ML family, strongly typed and has restricted mutable state. Before interacting with contracts using the SDK you should get familiar with Sophia itself first. Have a look into aepp-sophia-examples and start rapid prototyping using AEstudio . The SDK needs to interact with following components in order to enable smart contract interactions on the \u00e6ternity blockchain: \u00e6ternity (host your own one or use the public testnet node at https://testnet.aeternity.io ) aesophia_http (host your own one or use the public compiler at https://compiler.aepps.com ) Note: For production deployments you should always host these services by yourself. 1. Specify imports // node.js import const { Universal , MemoryAccount , Node } = require ( '@aeternity/aepp-sdk' ) // ES import import { Universal , MemoryAccount , Node } from '@aeternity/aepp-sdk' 2. Create an instance of the SDK When creating an instance of the SDK you need to provide an account which will be used to sign transactions like ContractCreateTx and ContractCallTx that will be broadcasted to the network. const node = await Node ({ url : 'https://testnet.aeternity.io' // ideally host your own node }) const account = MemoryAccount ({ // provide a valid keypair with your secretKey and publicKey keypair : { secretKey : SECRET_KEY , publicKey : PUBLIC_KEY } }) const aeSdk = await Universal ({ nodes : [ { name : 'testnet' , instance : node } ], compilerUrl : 'https://compiler.aepps.com' , // ideally host your own compiler accounts : [ account ] }) Note: You can provide multiple accounts to the SDK. For each transaction you can choose a specific account to use for signing (by default the first account will be used), see transaction options . This is specifically important and useful for writing tests. 3. Initialize the contract instance By source code const sourceCode = ... // source code of the contract const contractInstance = await aeSdk . getContractInstance ({ source : sourceCode }) Note: If your contract includes external dependencies which are not part of the standard library you should initialize the contract using: const fileSystem = ... // key-value map with name of the include as key and source code of the include as value const contractInstance = await aeSdk . getContractInstance ({ source : sourceCode , fileSystem }) By ACI and bytecode If you pre-compiled the contracts you can also initialize a contract instance by providing ACI and bytecode: const aci = ... // ACI of the contract const bytecode = ... // bytecode of the contract const contractInstance = await aeSdk . getContractInstance ({ aci , bytecode }) By ACI and contract address In many cases an application doesn't need to deploy a contract or verify its bytecode. In this case you'd want to initialize the instance by just providing the ACI and the contract address. This is also possible: const aci = ... // ACI of the contract const contractAddress = ... // the address of the contract const contractInstance = await aeSdk . getContractInstance ({ aci , contractAddress }) Options Following attributes can be provided via options to getContractInstance : aci (default: obtained via http compiler) The Contract ACI. contractAddress The address where the contract is located at. To be used if a contract is already deployed. fileSystem (default: {}) Key-value map with name of the include as key and source code of the include as value. validateBytecode (default: false) Compare source code with on-chain version. other transaction options which will be provided to every transaction that is initiated using the contract instance. You should be aware that: For most of these additional options it doesn't make sense to define them at contract instance level. You wouldn't want to provide an amount to each transaction or use the same nonce which would result in invalid transactions. For options like ttl or gasPrice it does absolutely make sense to set this on contract instance level. 4. Deploy the contract If you have a Sophia contract source code that looks like this: contract Increment = record state = { count : int } entrypoint init ( start : int ) = { count = start } stateful entrypoint increment ( value : int ) = put ( state { count = state . count + value }) entrypoint get_count () = state . count The contract can be deployed using the contractInstance in two different ways: const tx = await contractInstance . deploy ([ 1 ]) // recommended // or const tx = await contractInstance . methods . init ( 1 ) // after successful deployment you can look up the transaction and the deploy information console . log ( tx ) console . log ( contractInstance . deployInfo ) // { owner, transaction, address, result, rawTx } Note: Deployment is only possible if the contract instance was initialized by providing source code or bytecode. The init entrypoint is a special function which is only called once for deployment, initializes the contract's state and doesn't require the stateful declaration. In Sophia all public functions are called entrypoints and need to be declared as stateful if they should produce changes to the state of the smart contract, see increment(value: int) . 5. Call contract entrypoints a) Stateful entrypoints According to the example above you can call the stateful entrypoint increment by using one of the following lines: const tx = await contractInstance . methods . increment ( 3 ) // recommended // or const tx = await contractInstance . methods . increment . send ( 3 ) // or const tx = await contractInstance . call ( 'increment' , [ 3 ]) Note: The functions send and call provide an explicit way to tell the SDK to sign and broadcast the transaction. When using the increment function directly the SDK will automatically determine if it's a stateful entrypoint. b) Regular entrypoints The \u00e6ternity node can expose an API endpoint that allows to execute a dry-run for a transaction. You can make use of that functionality to get the result of entrypoints that don't execute state changes. Following lines show how you can do that using the SDK for the get_count entrypoint of the example above: const tx = await contractInstance . methods . get_count () // recommended // or const tx = await contractInstance . methods . get_count . get () // access the decoded result returned by the execution of the entrypoint console . log ( tx . decodedResult ); Note: The functions get and callStatic provide an explicit way to tell the SDK to perform a dry-run and to NOT broadcast the transaction. When using the get_count function directly the SDK will automatically determine that the function is not declared stateful and thus perform a dry-run , too. c) Payable entrypoints You will probably also write functions that require an amount of aettos to be provided. These functions must be declared with payable and (most likely) stateful . Let's assume you have declared following Sophia entrypoint which checks if a required amount of aettos has been provided before it continues execution: payable stateful entrypoint fund_project ( project_id : int ) = require ( Call . value >= 50 , 'at least 50 aettos need to be provided' ) // further logic ... In order to successfully call the fund_project entrypoint you need to provide at least 50 aettos . You can do this by providing the desired amount of aettos using one of the following lines: const tx = await contractInstance . methods . fund_project ( 1 , { amount : 50 }) // recommended // or const tx = await contractInstance . methods . fund_project . send ( 1 , { amount : 50 }) // or const tx = await contractInstance . call ( 'fund_project' , [ 1 ], { amount : 50 }) Transaction options As already stated various times in the guide it is possible to provide transaction options as object to a function of the SDK that builds and potentially broadcasts a transaction. This object can be passed as additional param to each of these functions and overrides the default settings. Sophia datatype cheatsheet Sometimes you might wonder how to pass params to the JavaScript method that calls an entrypoint of your Sophia smart contract. The following table may help you out. Type Sophia entrypoint definition JavaScript method call int add_two(one: int, two: int) add_two(1 , 2) address set_owner(owner: address) set_owner('ak_1337...') bool is_it_true(answer: bool) is_it_true(true) bits give_me_bits(input: bits) give_me_bits(0b10110n) bytes get_bytes(test: bytes(3)) get_bytes(new Uint8Array([0x1, 0x1f, 0x10])) string hello_world(say_hello: string) hello_world('Hello!') list have_a_few(candy: list(string)) have_a_few(['Skittles', 'M&Ms', 'JellyBelly']) tuple a_few_things(things: (string * int * map(address, bool))) a_few_things(['hola', 3, new Map([['ak_1337...', true]])]) record record user = { firstname: string, lastname: string } get_firstname(input: user): string get_firstname({'firstname': 'Alfred', 'lastname': 'Mustermann'}) map balances(values: map(address, int)) balances(new Map([['ak_1337...', 123], ['ak_FCKGW...', 321], ['ak_Rm5U...', 999]])) option() number_defined(value: option(int)): bool = Option.is_some(value) // the datatype in the option() number_defined(1337) // int in this case hash a_gram(of: hash) // 32 bytes signature a_gram('af01...490f') signature one_signature(sig: signature) // 64 bytes signature one_signature('af01...490f') functions (Higher order) functions are not allowed in entrypoint params","title":"Contracts"},{"location":"guides/contracts/#contracts","text":"","title":"Contracts"},{"location":"guides/contracts/#introduction","text":"The smart contract language of the \u00e6ternity blockchain is Sophia . It is a functional language in the ML family, strongly typed and has restricted mutable state. Before interacting with contracts using the SDK you should get familiar with Sophia itself first. Have a look into aepp-sophia-examples and start rapid prototyping using AEstudio . The SDK needs to interact with following components in order to enable smart contract interactions on the \u00e6ternity blockchain: \u00e6ternity (host your own one or use the public testnet node at https://testnet.aeternity.io ) aesophia_http (host your own one or use the public compiler at https://compiler.aepps.com ) Note: For production deployments you should always host these services by yourself.","title":"Introduction"},{"location":"guides/contracts/#1-specify-imports","text":"// node.js import const { Universal , MemoryAccount , Node } = require ( '@aeternity/aepp-sdk' ) // ES import import { Universal , MemoryAccount , Node } from '@aeternity/aepp-sdk'","title":"1. Specify imports"},{"location":"guides/contracts/#2-create-an-instance-of-the-sdk","text":"When creating an instance of the SDK you need to provide an account which will be used to sign transactions like ContractCreateTx and ContractCallTx that will be broadcasted to the network. const node = await Node ({ url : 'https://testnet.aeternity.io' // ideally host your own node }) const account = MemoryAccount ({ // provide a valid keypair with your secretKey and publicKey keypair : { secretKey : SECRET_KEY , publicKey : PUBLIC_KEY } }) const aeSdk = await Universal ({ nodes : [ { name : 'testnet' , instance : node } ], compilerUrl : 'https://compiler.aepps.com' , // ideally host your own compiler accounts : [ account ] }) Note: You can provide multiple accounts to the SDK. For each transaction you can choose a specific account to use for signing (by default the first account will be used), see transaction options . This is specifically important and useful for writing tests.","title":"2. Create an instance of the SDK"},{"location":"guides/contracts/#3-initialize-the-contract-instance","text":"","title":"3. Initialize the contract instance"},{"location":"guides/contracts/#by-source-code","text":"const sourceCode = ... // source code of the contract const contractInstance = await aeSdk . getContractInstance ({ source : sourceCode }) Note: If your contract includes external dependencies which are not part of the standard library you should initialize the contract using: const fileSystem = ... // key-value map with name of the include as key and source code of the include as value const contractInstance = await aeSdk . getContractInstance ({ source : sourceCode , fileSystem })","title":"By source code"},{"location":"guides/contracts/#by-aci-and-bytecode","text":"If you pre-compiled the contracts you can also initialize a contract instance by providing ACI and bytecode: const aci = ... // ACI of the contract const bytecode = ... // bytecode of the contract const contractInstance = await aeSdk . getContractInstance ({ aci , bytecode })","title":"By ACI and bytecode"},{"location":"guides/contracts/#by-aci-and-contract-address","text":"In many cases an application doesn't need to deploy a contract or verify its bytecode. In this case you'd want to initialize the instance by just providing the ACI and the contract address. This is also possible: const aci = ... // ACI of the contract const contractAddress = ... // the address of the contract const contractInstance = await aeSdk . getContractInstance ({ aci , contractAddress })","title":"By ACI and contract address"},{"location":"guides/contracts/#options","text":"Following attributes can be provided via options to getContractInstance : aci (default: obtained via http compiler) The Contract ACI. contractAddress The address where the contract is located at. To be used if a contract is already deployed. fileSystem (default: {}) Key-value map with name of the include as key and source code of the include as value. validateBytecode (default: false) Compare source code with on-chain version. other transaction options which will be provided to every transaction that is initiated using the contract instance. You should be aware that: For most of these additional options it doesn't make sense to define them at contract instance level. You wouldn't want to provide an amount to each transaction or use the same nonce which would result in invalid transactions. For options like ttl or gasPrice it does absolutely make sense to set this on contract instance level.","title":"Options"},{"location":"guides/contracts/#4-deploy-the-contract","text":"If you have a Sophia contract source code that looks like this: contract Increment = record state = { count : int } entrypoint init ( start : int ) = { count = start } stateful entrypoint increment ( value : int ) = put ( state { count = state . count + value }) entrypoint get_count () = state . count The contract can be deployed using the contractInstance in two different ways: const tx = await contractInstance . deploy ([ 1 ]) // recommended // or const tx = await contractInstance . methods . init ( 1 ) // after successful deployment you can look up the transaction and the deploy information console . log ( tx ) console . log ( contractInstance . deployInfo ) // { owner, transaction, address, result, rawTx } Note: Deployment is only possible if the contract instance was initialized by providing source code or bytecode. The init entrypoint is a special function which is only called once for deployment, initializes the contract's state and doesn't require the stateful declaration. In Sophia all public functions are called entrypoints and need to be declared as stateful if they should produce changes to the state of the smart contract, see increment(value: int) .","title":"4. Deploy the contract"},{"location":"guides/contracts/#5-call-contract-entrypoints","text":"","title":"5. Call contract entrypoints"},{"location":"guides/contracts/#a-stateful-entrypoints","text":"According to the example above you can call the stateful entrypoint increment by using one of the following lines: const tx = await contractInstance . methods . increment ( 3 ) // recommended // or const tx = await contractInstance . methods . increment . send ( 3 ) // or const tx = await contractInstance . call ( 'increment' , [ 3 ]) Note: The functions send and call provide an explicit way to tell the SDK to sign and broadcast the transaction. When using the increment function directly the SDK will automatically determine if it's a stateful entrypoint.","title":"a) Stateful entrypoints"},{"location":"guides/contracts/#b-regular-entrypoints","text":"The \u00e6ternity node can expose an API endpoint that allows to execute a dry-run for a transaction. You can make use of that functionality to get the result of entrypoints that don't execute state changes. Following lines show how you can do that using the SDK for the get_count entrypoint of the example above: const tx = await contractInstance . methods . get_count () // recommended // or const tx = await contractInstance . methods . get_count . get () // access the decoded result returned by the execution of the entrypoint console . log ( tx . decodedResult ); Note: The functions get and callStatic provide an explicit way to tell the SDK to perform a dry-run and to NOT broadcast the transaction. When using the get_count function directly the SDK will automatically determine that the function is not declared stateful and thus perform a dry-run , too.","title":"b) Regular entrypoints"},{"location":"guides/contracts/#c-payable-entrypoints","text":"You will probably also write functions that require an amount of aettos to be provided. These functions must be declared with payable and (most likely) stateful . Let's assume you have declared following Sophia entrypoint which checks if a required amount of aettos has been provided before it continues execution: payable stateful entrypoint fund_project ( project_id : int ) = require ( Call . value >= 50 , 'at least 50 aettos need to be provided' ) // further logic ... In order to successfully call the fund_project entrypoint you need to provide at least 50 aettos . You can do this by providing the desired amount of aettos using one of the following lines: const tx = await contractInstance . methods . fund_project ( 1 , { amount : 50 }) // recommended // or const tx = await contractInstance . methods . fund_project . send ( 1 , { amount : 50 }) // or const tx = await contractInstance . call ( 'fund_project' , [ 1 ], { amount : 50 })","title":"c) Payable entrypoints"},{"location":"guides/contracts/#transaction-options","text":"As already stated various times in the guide it is possible to provide transaction options as object to a function of the SDK that builds and potentially broadcasts a transaction. This object can be passed as additional param to each of these functions and overrides the default settings.","title":"Transaction options"},{"location":"guides/contracts/#sophia-datatype-cheatsheet","text":"Sometimes you might wonder how to pass params to the JavaScript method that calls an entrypoint of your Sophia smart contract. The following table may help you out. Type Sophia entrypoint definition JavaScript method call int add_two(one: int, two: int) add_two(1 , 2) address set_owner(owner: address) set_owner('ak_1337...') bool is_it_true(answer: bool) is_it_true(true) bits give_me_bits(input: bits) give_me_bits(0b10110n) bytes get_bytes(test: bytes(3)) get_bytes(new Uint8Array([0x1, 0x1f, 0x10])) string hello_world(say_hello: string) hello_world('Hello!') list have_a_few(candy: list(string)) have_a_few(['Skittles', 'M&Ms', 'JellyBelly']) tuple a_few_things(things: (string * int * map(address, bool))) a_few_things(['hola', 3, new Map([['ak_1337...', true]])]) record record user = { firstname: string, lastname: string } get_firstname(input: user): string get_firstname({'firstname': 'Alfred', 'lastname': 'Mustermann'}) map balances(values: map(address, int)) balances(new Map([['ak_1337...', 123], ['ak_FCKGW...', 321], ['ak_Rm5U...', 999]])) option() number_defined(value: option(int)): bool = Option.is_some(value) // the datatype in the option() number_defined(1337) // int in this case hash a_gram(of: hash) // 32 bytes signature a_gram('af01...490f') signature one_signature(sig: signature) // 64 bytes signature one_signature('af01...490f') functions (Higher order) functions are not allowed in entrypoint params","title":"Sophia datatype cheatsheet"},{"location":"guides/error-handling/","text":"Error Handling This guide shows you how to handle errors originating from the SDK. SDK by default exports the following error classes from file errors.ts Error Hierarchy BaseError \u2502 ArgumentError \u2502 IllegalArgumentError \u2502 ArgumentCountMismatchError \u2502 InsufficientBalanceError \u2502 InvalidDenominationError \u2502 MissingParamError \u2502 NoSerializerFoundError \u2502 RequestTimedOutError \u2502 TxTimedOutError \u2502 TypeError \u2502 UnsupportedPlatformError \u2502 UnsupportedProtocolError \u2502 NotImplementedError \u2502 UnsupportedVersionError \u2502 InternalError \u2502 \u2514\u2500\u2500\u2500AccountError \u2502 \u2502 InvalidKeypairError \u2502 \u2502 UnavailableAccountError \u2502 \u2514\u2500\u2500\u2500AensError \u2502 \u2502 AensPointerContextError \u2502 \u2502 InsufficientNameFeeError \u2502 \u2502 InvalidAensNameError \u2502 \u2514\u2500\u2500\u2500AeppError \u2502 \u2502 DuplicateCallbackError \u2502 \u2502 InvalidRpcMessageError \u2502 \u2502 MissingCallbackError \u2502 \u2502 UnAuthorizedAccountError \u2502 \u2502 UnknownRpcClientError \u2502 \u2502 UnsubscribedAccountError \u2502 \u2514\u2500\u2500\u2500ChannelError \u2502 \u2502 ChannelCallError \u2502 \u2502 ChannelConnectionError \u2502 \u2502 ChannelPingTimedOutError \u2502 \u2502 UnexpectedChannelMessageError \u2502 \u2502 UnknownChannelStateError \u2502 \u2514\u2500\u2500\u2500CompilerError \u2502 \u2502 InvalidAuthDataError \u2502 \u2514\u2500\u2500\u2500ContractError \u2502 \u2502 BytecodeMismatchError \u2502 \u2502 DuplicateContractError \u2502 \u2502 InactiveContractError \u2502 \u2502 InvalidMethodInvocationError \u2502 \u2502 MissingContractAddressError \u2502 \u2502 MissingContractDefError \u2502 \u2502 MissingFunctionNameError \u2502 \u2502 NodeInvocationError \u2502 \u2502 NoSuchContractFunctionError \u2502 \u2502 NotPayableFunctionError \u2502 \u2502 MissingEventDefinitionError \u2502 \u2502 AmbiguousEventDefinitionError \u2502 \u2514\u2500\u2500\u2500CryptographyError \u2502 \u2502 InvalidChecksumError \u2502 \u2502 DerivationError \u2502 \u2502 InvalidPasswordError \u2502 \u2502 MerkleTreeHashMismatchError \u2502 \u2502 MissingNodeInTreeError \u2502 \u2502 UnknownNodeLengthError \u2502 \u2502 UnknownPathNibbleError \u2502 \u2514\u2500\u2500\u2500NodeError \u2502 \u2502 DisconnectedError \u2502 \u2502 DuplicateNodeError \u2502 \u2502 NodeNotFoundError \u2502 \u2514\u2500\u2500\u2500TransactionError \u2502 \u2502 DecodeError \u2502 \u2502 EncodeError \u2502 \u2502 PayloadLengthError \u2502 \u2502 DryRunError \u2502 \u2502 IllegalBidFeeError \u2502 \u2502 InvalidSignatureError \u2502 \u2502 InvalidTxError \u2502 \u2502 InvalidTxParamsError \u2502 \u2502 NoDefaultAensPointerError \u2502 \u2502 PrefixNotFoundError \u2502 \u2502 SchemaNotFoundError \u2502 \u2502 TagNotFoundError \u2502 \u2502 TxNotInChainError \u2502 \u2502 UnknownTxError \u2502 \u2502 UnsupportedABIversionError \u2502 \u2502 UnsupportedVMversionError \u2502 \u2514\u030c\u2500\u2500\u2500WalletError \u2502 \u2502 AlreadyConnectedError \u2502 \u2502 NoWalletConnectedError \u2502 \u2502 RpcConnectionError Usage // import required error classes const { Universal , Node , MemoryAccount , generateKeyPair , InvalidTxParamsError , InvalidAensNameError } = require ( '@aeternity/aepp-sdk' ) // setup const NODE_URL = 'https://testnet.aeternity.io' const PAYER_ACCOUNT_KEYPAIR = generateKeyPair () const NEW_USER_KEYPAIR = generateKeyPair () const payerAccount = MemoryAccount ({ keypair : PAYER_ACCOUNT_KEYPAIR }) const newUserAccount = MemoryAccount ({ keypair : NEW_USER_KEYPAIR }) const node = await Node ({ url : NODE_URL }) const aeSdk = await Universal ({ nodes : [{ name : 'testnet' , instance : node }], accounts : [ payerAccount , newUserAccount ] }) // catch exceptions try { const spendTxResult = await aeSdk . spend ( - 1 , await newUserAccount . address (), { onAccount : payerAccount }) } catch ( err ) { if ( err instanceof InvalidTxParamsError ){ console . log ( `Amount specified is not valid, ${ err . message } ` ) } else if ( err instanceof InvalidAensNameError ) { console . log ( `Address specified is not valid, ${ err . message } ` ) } } // using generic error classes const { AensError , TransactionError , BaseError } = require ( '@aeternity/aepp-sdk' ) try { const spendTxResult = await aeSdk . spend ( 1 , \"ak_2tv\" , { onAccount : payerAccount }) } catch ( err ) { if ( err instanceof AensError ) { // address or AENS related errors } else if ( err instanceof TransactionError ) { // transaction errors } else if ( err instanceof BaseError ) { // match any errors from the SDK } }","title":"Error Handling"},{"location":"guides/error-handling/#error-handling","text":"This guide shows you how to handle errors originating from the SDK. SDK by default exports the following error classes from file errors.ts","title":"Error Handling"},{"location":"guides/error-handling/#error-hierarchy","text":"BaseError \u2502 ArgumentError \u2502 IllegalArgumentError \u2502 ArgumentCountMismatchError \u2502 InsufficientBalanceError \u2502 InvalidDenominationError \u2502 MissingParamError \u2502 NoSerializerFoundError \u2502 RequestTimedOutError \u2502 TxTimedOutError \u2502 TypeError \u2502 UnsupportedPlatformError \u2502 UnsupportedProtocolError \u2502 NotImplementedError \u2502 UnsupportedVersionError \u2502 InternalError \u2502 \u2514\u2500\u2500\u2500AccountError \u2502 \u2502 InvalidKeypairError \u2502 \u2502 UnavailableAccountError \u2502 \u2514\u2500\u2500\u2500AensError \u2502 \u2502 AensPointerContextError \u2502 \u2502 InsufficientNameFeeError \u2502 \u2502 InvalidAensNameError \u2502 \u2514\u2500\u2500\u2500AeppError \u2502 \u2502 DuplicateCallbackError \u2502 \u2502 InvalidRpcMessageError \u2502 \u2502 MissingCallbackError \u2502 \u2502 UnAuthorizedAccountError \u2502 \u2502 UnknownRpcClientError \u2502 \u2502 UnsubscribedAccountError \u2502 \u2514\u2500\u2500\u2500ChannelError \u2502 \u2502 ChannelCallError \u2502 \u2502 ChannelConnectionError \u2502 \u2502 ChannelPingTimedOutError \u2502 \u2502 UnexpectedChannelMessageError \u2502 \u2502 UnknownChannelStateError \u2502 \u2514\u2500\u2500\u2500CompilerError \u2502 \u2502 InvalidAuthDataError \u2502 \u2514\u2500\u2500\u2500ContractError \u2502 \u2502 BytecodeMismatchError \u2502 \u2502 DuplicateContractError \u2502 \u2502 InactiveContractError \u2502 \u2502 InvalidMethodInvocationError \u2502 \u2502 MissingContractAddressError \u2502 \u2502 MissingContractDefError \u2502 \u2502 MissingFunctionNameError \u2502 \u2502 NodeInvocationError \u2502 \u2502 NoSuchContractFunctionError \u2502 \u2502 NotPayableFunctionError \u2502 \u2502 MissingEventDefinitionError \u2502 \u2502 AmbiguousEventDefinitionError \u2502 \u2514\u2500\u2500\u2500CryptographyError \u2502 \u2502 InvalidChecksumError \u2502 \u2502 DerivationError \u2502 \u2502 InvalidPasswordError \u2502 \u2502 MerkleTreeHashMismatchError \u2502 \u2502 MissingNodeInTreeError \u2502 \u2502 UnknownNodeLengthError \u2502 \u2502 UnknownPathNibbleError \u2502 \u2514\u2500\u2500\u2500NodeError \u2502 \u2502 DisconnectedError \u2502 \u2502 DuplicateNodeError \u2502 \u2502 NodeNotFoundError \u2502 \u2514\u2500\u2500\u2500TransactionError \u2502 \u2502 DecodeError \u2502 \u2502 EncodeError \u2502 \u2502 PayloadLengthError \u2502 \u2502 DryRunError \u2502 \u2502 IllegalBidFeeError \u2502 \u2502 InvalidSignatureError \u2502 \u2502 InvalidTxError \u2502 \u2502 InvalidTxParamsError \u2502 \u2502 NoDefaultAensPointerError \u2502 \u2502 PrefixNotFoundError \u2502 \u2502 SchemaNotFoundError \u2502 \u2502 TagNotFoundError \u2502 \u2502 TxNotInChainError \u2502 \u2502 UnknownTxError \u2502 \u2502 UnsupportedABIversionError \u2502 \u2502 UnsupportedVMversionError \u2502 \u2514\u030c\u2500\u2500\u2500WalletError \u2502 \u2502 AlreadyConnectedError \u2502 \u2502 NoWalletConnectedError \u2502 \u2502 RpcConnectionError","title":"Error Hierarchy"},{"location":"guides/error-handling/#usage","text":"// import required error classes const { Universal , Node , MemoryAccount , generateKeyPair , InvalidTxParamsError , InvalidAensNameError } = require ( '@aeternity/aepp-sdk' ) // setup const NODE_URL = 'https://testnet.aeternity.io' const PAYER_ACCOUNT_KEYPAIR = generateKeyPair () const NEW_USER_KEYPAIR = generateKeyPair () const payerAccount = MemoryAccount ({ keypair : PAYER_ACCOUNT_KEYPAIR }) const newUserAccount = MemoryAccount ({ keypair : NEW_USER_KEYPAIR }) const node = await Node ({ url : NODE_URL }) const aeSdk = await Universal ({ nodes : [{ name : 'testnet' , instance : node }], accounts : [ payerAccount , newUserAccount ] }) // catch exceptions try { const spendTxResult = await aeSdk . spend ( - 1 , await newUserAccount . address (), { onAccount : payerAccount }) } catch ( err ) { if ( err instanceof InvalidTxParamsError ){ console . log ( `Amount specified is not valid, ${ err . message } ` ) } else if ( err instanceof InvalidAensNameError ) { console . log ( `Address specified is not valid, ${ err . message } ` ) } } // using generic error classes const { AensError , TransactionError , BaseError } = require ( '@aeternity/aepp-sdk' ) try { const spendTxResult = await aeSdk . spend ( 1 , \"ak_2tv\" , { onAccount : payerAccount }) } catch ( err ) { if ( err instanceof AensError ) { // address or AENS related errors } else if ( err instanceof TransactionError ) { // transaction errors } else if ( err instanceof BaseError ) { // match any errors from the SDK } }","title":"Usage"},{"location":"guides/low-vs-high-usage/","text":"Low vs High level API Interactions \"There are two approaches, purist and high-level.\" Alexander Kahl. The purist uses the functions generated out of the Swagger file. After creating the SDK instance aeSdk with the Universal Stamp it exposes a mapping of all operationId s as functions, converted to camelCase (from PascalCase). So e.g. in order to get a transaction based on its hash you would invoke aeSdk.api.getTransactionByHash('th_...') . In this way the SDK is simply a mapping of the raw API calls into JavaScript. It's excellent for low-level control, and as a teaching tool to understand the node's operations. Most real-world requirements involves a series of chain operations, so the SDK provides abstractions for these. ( Recommended ) High-level SDK usage Example spend function, using \u00e6ternity's SDK abstraction. import { MemoryAccount , Node , Universal } from '@aeternity/aepp-sdk' async function init () { const node = await Node ({ 'https://testnet.aeternity.io' }) // ideally host your own node! const aeSdk = await Universal ({ nodes : [{ name : 'testnet' , instance : node }], compilerUrl : 'https://compiler.aepps.com' , // ideally host your own compiler! accounts : [ MemoryAccount ({ keypair : { secretKey : '<PRIV_KEY_HERE>' , publicKey : '<PUB_KEY_HERE>' }})], }) // log transaction info console . log ( await aeSdk . spend ( 100 , 'ak_...' )) } Low-level SDK usage (use API endpoints directly) Example spend function, using the SDK, talking directly to the API : import { MemoryAccount , Node , Universal } from '@aeternity/aepp-sdk' async function spend ( amount , recipient ) { const node = await Node ({ 'https://testnet.aeternity.io' }) // ideally host your own node! const aeSdk = await Universal ({ nodes : [{ name : 'testnet' , instance : node }], compilerUrl : 'https://compiler.aepps.com' , // ideally host your own compiler! accounts : [ MemoryAccount ({ keypair : { secretKey : '<PRIV_KEY_HERE>' , publicKey : '<PUB_KEY_HERE>' }})], }) // builds an unsigned SpendTx using the debug endpoint of the node's API const spendTx = await aeSdk . buildTx ( TX_TYPE . spend , { senderId : await aeSdk . address (), recipientId : recipient , fee : 18000000000000 , // you must provide enough fee amount , // aettos payload : 'using low-level api is funny' }) // sign the encoded transaction returned by the node const signedTx = await aeSdk . signTransaction ( spendTx ) // broadcast the signed tx to the node console . log ( await aeSdk . api . postTransaction ({ tx : signedTx })) } Following functions are available with the low-level API right now: console . log ( aeSdk . api ) /* { getTopHeader: [AsyncFunction (anonymous)], getCurrentKeyBlock: [AsyncFunction (anonymous)], getCurrentKeyBlockHash: [AsyncFunction (anonymous)], getCurrentKeyBlockHeight: [AsyncFunction (anonymous)], getPendingKeyBlock: [AsyncFunction (anonymous)], getKeyBlockByHash: [AsyncFunction (anonymous)], getKeyBlockByHeight: [AsyncFunction (anonymous)], getMicroBlockHeaderByHash: [AsyncFunction (anonymous)], getMicroBlockTransactionsByHash: [AsyncFunction (anonymous)], getMicroBlockTransactionByHashAndIndex: [AsyncFunction (anonymous)], getMicroBlockTransactionsCountByHash: [AsyncFunction (anonymous)], getCurrentGeneration: [AsyncFunction (anonymous)], getGenerationByHash: [AsyncFunction (anonymous)], getGenerationByHeight: [AsyncFunction (anonymous)], getAccountByPubkey: [AsyncFunction (anonymous)], getAccountByPubkeyAndHeight: [AsyncFunction (anonymous)], getAccountByPubkeyAndHash: [AsyncFunction (anonymous)], getPendingAccountTransactionsByPubkey: [AsyncFunction (anonymous)], getAccountNextNonce: [AsyncFunction (anonymous)], protectedDryRunTxs: [AsyncFunction (anonymous)], getTransactionByHash: [AsyncFunction (anonymous)], getTransactionInfoByHash: [AsyncFunction (anonymous)], postTransaction: [AsyncFunction (anonymous)], getContract: [AsyncFunction (anonymous)], getContractCode: [AsyncFunction (anonymous)], getContractPoI: [AsyncFunction (anonymous)], getOracleByPubkey: [AsyncFunction (anonymous)], getOracleQueriesByPubkey: [AsyncFunction (anonymous)], getOracleQueryByPubkeyAndQueryId: [AsyncFunction (anonymous)], getNameEntryByName: [AsyncFunction (anonymous)], getChannelByPubkey: [AsyncFunction (anonymous)], getPeerPubkey: [AsyncFunction (anonymous)], getStatus: [AsyncFunction (anonymous)], getChainEnds: [AsyncFunction (anonymous)] } */","title":"Low vs High level API"},{"location":"guides/low-vs-high-usage/#low-vs-high-level-api","text":"","title":"Low vs High level API"},{"location":"guides/low-vs-high-usage/#interactions","text":"\"There are two approaches, purist and high-level.\" Alexander Kahl. The purist uses the functions generated out of the Swagger file. After creating the SDK instance aeSdk with the Universal Stamp it exposes a mapping of all operationId s as functions, converted to camelCase (from PascalCase). So e.g. in order to get a transaction based on its hash you would invoke aeSdk.api.getTransactionByHash('th_...') . In this way the SDK is simply a mapping of the raw API calls into JavaScript. It's excellent for low-level control, and as a teaching tool to understand the node's operations. Most real-world requirements involves a series of chain operations, so the SDK provides abstractions for these.","title":"Interactions"},{"location":"guides/low-vs-high-usage/#recommended-high-level-sdk-usage","text":"Example spend function, using \u00e6ternity's SDK abstraction. import { MemoryAccount , Node , Universal } from '@aeternity/aepp-sdk' async function init () { const node = await Node ({ 'https://testnet.aeternity.io' }) // ideally host your own node! const aeSdk = await Universal ({ nodes : [{ name : 'testnet' , instance : node }], compilerUrl : 'https://compiler.aepps.com' , // ideally host your own compiler! accounts : [ MemoryAccount ({ keypair : { secretKey : '<PRIV_KEY_HERE>' , publicKey : '<PUB_KEY_HERE>' }})], }) // log transaction info console . log ( await aeSdk . spend ( 100 , 'ak_...' )) }","title":"(Recommended) High-level SDK usage"},{"location":"guides/low-vs-high-usage/#low-level-sdk-usage-use-api-endpoints-directly","text":"Example spend function, using the SDK, talking directly to the API : import { MemoryAccount , Node , Universal } from '@aeternity/aepp-sdk' async function spend ( amount , recipient ) { const node = await Node ({ 'https://testnet.aeternity.io' }) // ideally host your own node! const aeSdk = await Universal ({ nodes : [{ name : 'testnet' , instance : node }], compilerUrl : 'https://compiler.aepps.com' , // ideally host your own compiler! accounts : [ MemoryAccount ({ keypair : { secretKey : '<PRIV_KEY_HERE>' , publicKey : '<PUB_KEY_HERE>' }})], }) // builds an unsigned SpendTx using the debug endpoint of the node's API const spendTx = await aeSdk . buildTx ( TX_TYPE . spend , { senderId : await aeSdk . address (), recipientId : recipient , fee : 18000000000000 , // you must provide enough fee amount , // aettos payload : 'using low-level api is funny' }) // sign the encoded transaction returned by the node const signedTx = await aeSdk . signTransaction ( spendTx ) // broadcast the signed tx to the node console . log ( await aeSdk . api . postTransaction ({ tx : signedTx })) } Following functions are available with the low-level API right now: console . log ( aeSdk . api ) /* { getTopHeader: [AsyncFunction (anonymous)], getCurrentKeyBlock: [AsyncFunction (anonymous)], getCurrentKeyBlockHash: [AsyncFunction (anonymous)], getCurrentKeyBlockHeight: [AsyncFunction (anonymous)], getPendingKeyBlock: [AsyncFunction (anonymous)], getKeyBlockByHash: [AsyncFunction (anonymous)], getKeyBlockByHeight: [AsyncFunction (anonymous)], getMicroBlockHeaderByHash: [AsyncFunction (anonymous)], getMicroBlockTransactionsByHash: [AsyncFunction (anonymous)], getMicroBlockTransactionByHashAndIndex: [AsyncFunction (anonymous)], getMicroBlockTransactionsCountByHash: [AsyncFunction (anonymous)], getCurrentGeneration: [AsyncFunction (anonymous)], getGenerationByHash: [AsyncFunction (anonymous)], getGenerationByHeight: [AsyncFunction (anonymous)], getAccountByPubkey: [AsyncFunction (anonymous)], getAccountByPubkeyAndHeight: [AsyncFunction (anonymous)], getAccountByPubkeyAndHash: [AsyncFunction (anonymous)], getPendingAccountTransactionsByPubkey: [AsyncFunction (anonymous)], getAccountNextNonce: [AsyncFunction (anonymous)], protectedDryRunTxs: [AsyncFunction (anonymous)], getTransactionByHash: [AsyncFunction (anonymous)], getTransactionInfoByHash: [AsyncFunction (anonymous)], postTransaction: [AsyncFunction (anonymous)], getContract: [AsyncFunction (anonymous)], getContractCode: [AsyncFunction (anonymous)], getContractPoI: [AsyncFunction (anonymous)], getOracleByPubkey: [AsyncFunction (anonymous)], getOracleQueriesByPubkey: [AsyncFunction (anonymous)], getOracleQueryByPubkeyAndQueryId: [AsyncFunction (anonymous)], getNameEntryByName: [AsyncFunction (anonymous)], getChannelByPubkey: [AsyncFunction (anonymous)], getPeerPubkey: [AsyncFunction (anonymous)], getStatus: [AsyncFunction (anonymous)], getChainEnds: [AsyncFunction (anonymous)] } */","title":"Low-level SDK usage (use API endpoints directly)"},{"location":"guides/oracles/","text":"Oracles Introduction This guide shows you how to perform all the operations that you need within the lifecycle of oracles using the SDK. 1. Oracle: register You register an oracle that responds with the temperature of the city that is included in the query. To register an oracle you need to provide a queryFormat and a responseFormat to the registerOracle function of the SDK. In addition to the common transaction options you can provide the oracle specific options queryFee and oracleTtl , see transaction options . // init an instance of the SDK using the Universal Stamp const aeSdk = await Universal ({ ... }) // set TTL with a delta of 1000 blocks const oracleTtl = { type : 'delta' , value : 1000 } // OR set a specific block height to expire const oracleTtl = { type : 'block' , value : 555555 } // queryFee is optional and defaults to 30000 // oracleTtl is optional and defaults to { type: 'delta', value: 500 } const options = { queryFee : 1337 , oracleTtl } // the first argument is the queryFormat and the second is the responseFormat const oracle = await aeSdk . registerOracle ( \"{'city': string}\" , \"{'temperature': int}\" , options ) Note: By default the oracle will exist for the next 500 KeyBlocks. If you intend to keep your oracle running longer you should increase the oracleTtl and/or set up a service that automatically extends the TTL before it expires. The oracleId will be similar to the address of the account that registered the Oracle. The only difference is the prefix that will be ok_ instead of ak_ This means that each account can only host 1 oracle. It's not possible to manage multiple oracles using the same account. 2. Some party: query an oracle and poll for response Query After the oracle has been registered and as long as it isn't expired, everybody that knows the oracleId can query it. const oracleId = 'ok_...' ; // queryFee should cover the requested fee of the oracle and defaults to 30000 // queryTtl is optional and defaults to {type: 'delta', value: 10} // responseTtl is optional and defaults to {type: 'delta', value: 10} const options = { queryFee : 1337 , queryTtl : { type : 'delta' , value : 20 }, responseTtl : { type : 'delta' , value : 50 }} // using the oracle object const oracle = await aeSdk . getOracleObject ( oracleId ) // in case you need to instantiate the oracle object first const query = await oracle . postQuery ( \"{'city': 'Berlin'}\" , options ) // using the oracle instance // OR using the aeSdk (instance of Universal stamp) directly by providing the oracleId const query = await aeSdk . postQueryToOracle ( oracleId , \"{'city': 'Berlin'}\" , options ) Note: Again, take a look into the transaction options to see what (other) options you can provide. Poll for response Now you have access to the query object and can poll for the response to that specific query: const oracleId = 'ok_...' ; const queryId = 'oq_...' ; // using the query instance const query = await aeSdk . getQueryObject ( oracleId , queryId ) // in case you need to get the query instance first const response = await query . pollForResponse ({ attempts : 10 , interval : 6000 }) // OR using the aeSdk (instance of Universal stamp) directly by providing the oracleId const response = await aeSdk . pollForQueryResponse ( oracleId , queryId , { attempts : 10 , interval : 6000 }) // decode the oracle response // the decode function returns a buffer that needs to be converted to a string const decodedResponse = String ( response . decode ()); console . log ( decodedResponse ) 3. Oracle: poll for queries and respond Poll for queries Typically the oracle itself polls for its own queries and responds as soon as possible: const stopPolling = await oracle . pollQueries (( queries ) => { console . log ( queries ) // log all new queries }, { interval : 1000 }) // polling interval in milliseconds stopPolling () // stop polling Note: Probably the oracle would respond here directly (see below) instead of just logging the queries. Respond to query If the oracle recognizes that it has been queried it can respond to the query as long as the query's TTL has not been expired. const oracleId = 'ok_...' ; const queryId = 'oq_...' ; const options = { onAccount : 'ak_...' } // only the account of the oracle can respond to the query // using the query instance const query = await aeSdk . getQueryObject ( oracleId , queryId ) await query . respond ( '{ \"temperature\": 27.5 }' , options ) // OR using the aeSdk (instance of Universal stamp) directly by providing the oracleId and the queryId await aeSdk . respondToQuery ( oracleId , queryId , '{ \"temperature\": 27.5 }' , options ) Note: Of course the oracle itself would either use an API to get the current temperature for a certain city or ideally directly communicate with measuring devices located in that specific city. If the Universal Stamp is initialized with the oracle's account there is no need to pass the onAccount option as this is done implicitely. 4. Oracle: extend As mentioned above an Oracle has a certain TTL that can be specified when registering it. You might want to extend the TTL of the oracle before it expires. You can do that as follows: const oracleId = 'ok_...' ; // extend TTL by additional 500 blocks (based on current expiration height of the oracle) const oracleTtl = { type : 'delta' , value : 500 } // using the oracle instance const oracle = await aeSdk . getOracleObject ( oracleId ) const extendedOracle = await oracle . extendOracle ( oracleTtl ) // OR using the aeSdk (instance of Universal stamp) directly by providing the oracleId const extendedOracle = await aeSdk . extendOracleTtl ( oracleId , oracleTtl ) Example applications ae-oracle-pricefeed NodeJS example that registers an oracle, extends it if required and responds to queries automatically.","title":"Oracles"},{"location":"guides/oracles/#oracles","text":"","title":"Oracles"},{"location":"guides/oracles/#introduction","text":"This guide shows you how to perform all the operations that you need within the lifecycle of oracles using the SDK.","title":"Introduction"},{"location":"guides/oracles/#1-oracle-register","text":"You register an oracle that responds with the temperature of the city that is included in the query. To register an oracle you need to provide a queryFormat and a responseFormat to the registerOracle function of the SDK. In addition to the common transaction options you can provide the oracle specific options queryFee and oracleTtl , see transaction options . // init an instance of the SDK using the Universal Stamp const aeSdk = await Universal ({ ... }) // set TTL with a delta of 1000 blocks const oracleTtl = { type : 'delta' , value : 1000 } // OR set a specific block height to expire const oracleTtl = { type : 'block' , value : 555555 } // queryFee is optional and defaults to 30000 // oracleTtl is optional and defaults to { type: 'delta', value: 500 } const options = { queryFee : 1337 , oracleTtl } // the first argument is the queryFormat and the second is the responseFormat const oracle = await aeSdk . registerOracle ( \"{'city': string}\" , \"{'temperature': int}\" , options ) Note: By default the oracle will exist for the next 500 KeyBlocks. If you intend to keep your oracle running longer you should increase the oracleTtl and/or set up a service that automatically extends the TTL before it expires. The oracleId will be similar to the address of the account that registered the Oracle. The only difference is the prefix that will be ok_ instead of ak_ This means that each account can only host 1 oracle. It's not possible to manage multiple oracles using the same account.","title":"1. Oracle: register"},{"location":"guides/oracles/#2-some-party-query-an-oracle-and-poll-for-response","text":"","title":"2. Some party: query an oracle and poll for response"},{"location":"guides/oracles/#query","text":"After the oracle has been registered and as long as it isn't expired, everybody that knows the oracleId can query it. const oracleId = 'ok_...' ; // queryFee should cover the requested fee of the oracle and defaults to 30000 // queryTtl is optional and defaults to {type: 'delta', value: 10} // responseTtl is optional and defaults to {type: 'delta', value: 10} const options = { queryFee : 1337 , queryTtl : { type : 'delta' , value : 20 }, responseTtl : { type : 'delta' , value : 50 }} // using the oracle object const oracle = await aeSdk . getOracleObject ( oracleId ) // in case you need to instantiate the oracle object first const query = await oracle . postQuery ( \"{'city': 'Berlin'}\" , options ) // using the oracle instance // OR using the aeSdk (instance of Universal stamp) directly by providing the oracleId const query = await aeSdk . postQueryToOracle ( oracleId , \"{'city': 'Berlin'}\" , options ) Note: Again, take a look into the transaction options to see what (other) options you can provide.","title":"Query"},{"location":"guides/oracles/#poll-for-response","text":"Now you have access to the query object and can poll for the response to that specific query: const oracleId = 'ok_...' ; const queryId = 'oq_...' ; // using the query instance const query = await aeSdk . getQueryObject ( oracleId , queryId ) // in case you need to get the query instance first const response = await query . pollForResponse ({ attempts : 10 , interval : 6000 }) // OR using the aeSdk (instance of Universal stamp) directly by providing the oracleId const response = await aeSdk . pollForQueryResponse ( oracleId , queryId , { attempts : 10 , interval : 6000 }) // decode the oracle response // the decode function returns a buffer that needs to be converted to a string const decodedResponse = String ( response . decode ()); console . log ( decodedResponse )","title":"Poll for response"},{"location":"guides/oracles/#3-oracle-poll-for-queries-and-respond","text":"","title":"3. Oracle: poll for queries and respond"},{"location":"guides/oracles/#poll-for-queries","text":"Typically the oracle itself polls for its own queries and responds as soon as possible: const stopPolling = await oracle . pollQueries (( queries ) => { console . log ( queries ) // log all new queries }, { interval : 1000 }) // polling interval in milliseconds stopPolling () // stop polling Note: Probably the oracle would respond here directly (see below) instead of just logging the queries.","title":"Poll for queries"},{"location":"guides/oracles/#respond-to-query","text":"If the oracle recognizes that it has been queried it can respond to the query as long as the query's TTL has not been expired. const oracleId = 'ok_...' ; const queryId = 'oq_...' ; const options = { onAccount : 'ak_...' } // only the account of the oracle can respond to the query // using the query instance const query = await aeSdk . getQueryObject ( oracleId , queryId ) await query . respond ( '{ \"temperature\": 27.5 }' , options ) // OR using the aeSdk (instance of Universal stamp) directly by providing the oracleId and the queryId await aeSdk . respondToQuery ( oracleId , queryId , '{ \"temperature\": 27.5 }' , options ) Note: Of course the oracle itself would either use an API to get the current temperature for a certain city or ideally directly communicate with measuring devices located in that specific city. If the Universal Stamp is initialized with the oracle's account there is no need to pass the onAccount option as this is done implicitely.","title":"Respond to query"},{"location":"guides/oracles/#4-oracle-extend","text":"As mentioned above an Oracle has a certain TTL that can be specified when registering it. You might want to extend the TTL of the oracle before it expires. You can do that as follows: const oracleId = 'ok_...' ; // extend TTL by additional 500 blocks (based on current expiration height of the oracle) const oracleTtl = { type : 'delta' , value : 500 } // using the oracle instance const oracle = await aeSdk . getOracleObject ( oracleId ) const extendedOracle = await oracle . extendOracle ( oracleTtl ) // OR using the aeSdk (instance of Universal stamp) directly by providing the oracleId const extendedOracle = await aeSdk . extendOracleTtl ( oracleId , oracleTtl )","title":"4. Oracle: extend"},{"location":"guides/oracles/#example-applications","text":"ae-oracle-pricefeed NodeJS example that registers an oracle, extends it if required and responds to queries automatically.","title":"Example applications"},{"location":"guides/paying-for-tx/","text":"PayingForTx (Meta-Transactions) Introduction This guide explains you how to perform a PayingForTx (also known as meta-transaction) using the SDK. It is a very powerful and efficient solution that is crucial for onboarding new users into you ecosystem. By making use of the PayingForTx you will be able to cover the fees of your users. How it works Typically somebody that you want to pay the transaction for (e.g. a new user of your decentralized aepp) signs the inner transaction (e.g. of type ContractCallTx ) with a specific signature that is used for inner transactions. You can then collect the signed inner transaction, wrap it into a PayingForTx and broadcast it to the network. Usage examples We provided following two NodeJS examples which you can take a look at: InnerTx: ContractCallTx InnerTx: SpendTx Note: A PayingForTx can wrap any kind of other transaction type supported by the protocol as inner transaction. UseCases Game developers that want to quickly onboard new users. Governance aepps that want people to vote on important proposals without having them to pay anything. Custodians that want to offer an additional services to cover the transaction fees of their clients. ... many more!","title":"PayingForTx (Meta-Transactions)"},{"location":"guides/paying-for-tx/#payingfortx-meta-transactions","text":"","title":"PayingForTx (Meta-Transactions)"},{"location":"guides/paying-for-tx/#introduction","text":"This guide explains you how to perform a PayingForTx (also known as meta-transaction) using the SDK. It is a very powerful and efficient solution that is crucial for onboarding new users into you ecosystem. By making use of the PayingForTx you will be able to cover the fees of your users.","title":"Introduction"},{"location":"guides/paying-for-tx/#how-it-works","text":"Typically somebody that you want to pay the transaction for (e.g. a new user of your decentralized aepp) signs the inner transaction (e.g. of type ContractCallTx ) with a specific signature that is used for inner transactions. You can then collect the signed inner transaction, wrap it into a PayingForTx and broadcast it to the network.","title":"How it works"},{"location":"guides/paying-for-tx/#usage-examples","text":"We provided following two NodeJS examples which you can take a look at: InnerTx: ContractCallTx InnerTx: SpendTx Note: A PayingForTx can wrap any kind of other transaction type supported by the protocol as inner transaction.","title":"Usage examples"},{"location":"guides/paying-for-tx/#usecases","text":"Game developers that want to quickly onboard new users. Governance aepps that want people to vote on important proposals without having them to pay anything. Custodians that want to offer an additional services to cover the transaction fees of their clients. ... many more!","title":"UseCases"},{"location":"guides/migration/10.0.0/","text":"Migration to 10.0.0 This guide describes all breaking changes introduced with v10.0.0 . pollForQueryResponse returns response as string ( #1285 ) replace oldResult.decode with new Buffer(newResult) . replace oldResult.response with TxBuilderHelper.encode(new Buffer(newResult), 'or'') . removed skipArgsConvert option of contract call and deployment ( 6d4a599 ) Convert arguments in intermediate Sophia representation to JavaScript types. For example: contract . methods . listFn ( '[1, 2]' , { skipArgsConvert : false }) rewrite to contract . methods . listFn ([ 1 , 2 ]) removed skipTransformDecoded option of contract call and deployment ( bb49239 ) Decoding to JavaScript types is enforced, please use it instead. ak_ addresses are not accepted as hashes, bytes, and signatures anymore ( cbaac62 ) Encode addresses as an ak_ -prefixed string instead. removed contractEncodeCall ( a4b303f ) Use contractEncodeCallDataAPI instead. removed contractDecodeData ( 5df2285 ) Use contractDecodeCallResultAPI instead. removed setOptions on contract instance ( b88e767 ) Pass them through getContractInstance options instead. contractCallStatic , contractCall , contractDeploy are deprecated now ( c4ec019 ) Use getContractInstance instead. Also, these methods will accept JavaScript-type variables instead of Sophia-encoded. For example: sdk . contractCallStatic ( source , address , methodName , [ '42' ]) should be replaced with sdk . contractCallStatic ( source , address , methodName , [ 42 ]) dropped compatibility with compiler@4.1.0 ( f9cef12 ) Use compiler 6.0.0 and above. invert and rename forceCodeCheck option to validateBytecode in getContractInstance ( 72122fa ) Use validateBytecode when you need to ensure that the source code/bytecode provided to getContractInstance corresponds to the on-chain bytecode. removed getConsensusProtocolVersion method ( 75f0447 ) Use node.consensusProtocolVersion instead. switched to @aeternity/aepp-calldata package ( #1313 ) Numbers in Sophia are not limited in size. Before they were returned from contract methods as usual JavaScript numbers that have limited accuracy. To fix this, we make it return instances of BigInt. Variant types are now supported by sdk, so replace \"RelativeTTL(50)\" with { RelativeTTL: [50] } . As an exception Some(value) is converted to the exact value in JavaScript and None is converted to undefined (Sophia's option type). Contract methods will accept/return instances of JavaScript's Map as variables of Sophia's map type. Objects are not accepted as maps any longer. Sophia's hash , signature , bytes types return values as Uint8Array instead of a hex-encoded string. Check the documentation of calldata package for additional info. Use .decodedResult instead of .decode() to get the result of method call. Most of the errors thrown by contract iterations will be different due to doing validation using calldata package instead of joi . pass source in options of sdk.getContractInstance ( 5c690d2 ) For example: sdk . getContractInstance ( contractSource , { contractAddress : '...' }) rewrite to sdk . getContractInstance ({ source : contractSource , contractAddress : '...' }) Contract instance can be generated by ACI and bytecode: sdk . getContractInstance ({ aci , bytecode }) SDK won't use hosted compiler in this case. Also, contract.compiled was renamed to contract.bytecode . additional options of getContractInstance accepted as usual ones ( 10fb7ba ) For example, replace sdk . getContractInstance ({ source , opt : { ttl : 1 } }) with sdk . getContractInstance ({ source , ttl : 1 }) drop compatibility with es5 ( #1331 ) To support old environments, you need to set up transpilation of SDK package while building your app. In Webpack it can be done by excluding node_modules folder except for this package in babe-loader rule. In @vue/cli you can use transpileDependencies option. removed primitives for encryption/decryption by keypairs ( #1183 ) Use third-party cryptographic packages instead of Crypto.encryptData , Crypto.decryptData methods. aensUpdate accepts pointers as object ( f6b8999 ) For example, replace sdk . aensUpdate ( 'test.chain' , [ 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk' ]) with sdk . aensUpdate ( 'test.chain' , { account_pubkey : 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk' }) Additionally, getDefaultPointerKey (was named classify before) helper function can be used import { getDefaultPointerKey } from '@aeternity/aepp-sdk' const address = 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk' sdk . aensUpdate ( 'test.chain' , { [ getDefaultPointerKey ( address )] : address })","title":"Migration to 10.0.0"},{"location":"guides/migration/10.0.0/#migration-to-1000","text":"This guide describes all breaking changes introduced with v10.0.0 .","title":"Migration to 10.0.0"},{"location":"guides/migration/10.0.0/#pollforqueryresponse-returns-response-as-string-1285","text":"replace oldResult.decode with new Buffer(newResult) . replace oldResult.response with TxBuilderHelper.encode(new Buffer(newResult), 'or'') .","title":"pollForQueryResponse returns response as string (#1285)"},{"location":"guides/migration/10.0.0/#removed-skipargsconvert-option-of-contract-call-and-deployment-6d4a599","text":"Convert arguments in intermediate Sophia representation to JavaScript types. For example: contract . methods . listFn ( '[1, 2]' , { skipArgsConvert : false }) rewrite to contract . methods . listFn ([ 1 , 2 ])","title":"removed skipArgsConvert option of contract call and deployment (6d4a599)"},{"location":"guides/migration/10.0.0/#removed-skiptransformdecoded-option-of-contract-call-and-deployment-bb49239","text":"Decoding to JavaScript types is enforced, please use it instead.","title":"removed skipTransformDecoded option of contract call and deployment (bb49239)"},{"location":"guides/migration/10.0.0/#ak_-addresses-are-not-accepted-as-hashes-bytes-and-signatures-anymore-cbaac62","text":"Encode addresses as an ak_ -prefixed string instead.","title":"ak_ addresses are not accepted as hashes, bytes, and signatures anymore (cbaac62)"},{"location":"guides/migration/10.0.0/#removed-contractencodecall-a4b303f","text":"Use contractEncodeCallDataAPI instead.","title":"removed contractEncodeCall (a4b303f)"},{"location":"guides/migration/10.0.0/#removed-contractdecodedata-5df2285","text":"Use contractDecodeCallResultAPI instead.","title":"removed contractDecodeData (5df2285)"},{"location":"guides/migration/10.0.0/#removed-setoptions-on-contract-instance-b88e767","text":"Pass them through getContractInstance options instead.","title":"removed setOptions on contract instance (b88e767)"},{"location":"guides/migration/10.0.0/#contractcallstatic-contractcall-contractdeploy-are-deprecated-now-c4ec019","text":"Use getContractInstance instead. Also, these methods will accept JavaScript-type variables instead of Sophia-encoded. For example: sdk . contractCallStatic ( source , address , methodName , [ '42' ]) should be replaced with sdk . contractCallStatic ( source , address , methodName , [ 42 ])","title":"contractCallStatic, contractCall, contractDeploy are deprecated now (c4ec019)"},{"location":"guides/migration/10.0.0/#dropped-compatibility-with-compiler410-f9cef12","text":"Use compiler 6.0.0 and above.","title":"dropped compatibility with compiler@4.1.0 (f9cef12)"},{"location":"guides/migration/10.0.0/#invert-and-rename-forcecodecheck-option-to-validatebytecode-in-getcontractinstance-72122fa","text":"Use validateBytecode when you need to ensure that the source code/bytecode provided to getContractInstance corresponds to the on-chain bytecode.","title":"invert and rename forceCodeCheck option to validateBytecode in getContractInstance (72122fa)"},{"location":"guides/migration/10.0.0/#removed-getconsensusprotocolversion-method-75f0447","text":"Use node.consensusProtocolVersion instead.","title":"removed getConsensusProtocolVersion method (75f0447)"},{"location":"guides/migration/10.0.0/#switched-to-aeternityaepp-calldata-package-1313","text":"Numbers in Sophia are not limited in size. Before they were returned from contract methods as usual JavaScript numbers that have limited accuracy. To fix this, we make it return instances of BigInt. Variant types are now supported by sdk, so replace \"RelativeTTL(50)\" with { RelativeTTL: [50] } . As an exception Some(value) is converted to the exact value in JavaScript and None is converted to undefined (Sophia's option type). Contract methods will accept/return instances of JavaScript's Map as variables of Sophia's map type. Objects are not accepted as maps any longer. Sophia's hash , signature , bytes types return values as Uint8Array instead of a hex-encoded string. Check the documentation of calldata package for additional info. Use .decodedResult instead of .decode() to get the result of method call. Most of the errors thrown by contract iterations will be different due to doing validation using calldata package instead of joi .","title":"switched to @aeternity/aepp-calldata package (#1313)"},{"location":"guides/migration/10.0.0/#pass-source-in-options-of-sdkgetcontractinstance-5c690d2","text":"For example: sdk . getContractInstance ( contractSource , { contractAddress : '...' }) rewrite to sdk . getContractInstance ({ source : contractSource , contractAddress : '...' }) Contract instance can be generated by ACI and bytecode: sdk . getContractInstance ({ aci , bytecode }) SDK won't use hosted compiler in this case. Also, contract.compiled was renamed to contract.bytecode .","title":"pass source in options of sdk.getContractInstance (5c690d2)"},{"location":"guides/migration/10.0.0/#additional-options-of-getcontractinstance-accepted-as-usual-ones-10fb7ba","text":"For example, replace sdk . getContractInstance ({ source , opt : { ttl : 1 } }) with sdk . getContractInstance ({ source , ttl : 1 })","title":"additional options of getContractInstance accepted as usual ones (10fb7ba)"},{"location":"guides/migration/10.0.0/#drop-compatibility-with-es5-1331","text":"To support old environments, you need to set up transpilation of SDK package while building your app. In Webpack it can be done by excluding node_modules folder except for this package in babe-loader rule. In @vue/cli you can use transpileDependencies option.","title":"drop compatibility with es5 (#1331)"},{"location":"guides/migration/10.0.0/#removed-primitives-for-encryptiondecryption-by-keypairs-1183","text":"Use third-party cryptographic packages instead of Crypto.encryptData , Crypto.decryptData methods.","title":"removed primitives for encryption/decryption by keypairs (#1183)"},{"location":"guides/migration/10.0.0/#aensupdate-accepts-pointers-as-object-f6b8999","text":"For example, replace sdk . aensUpdate ( 'test.chain' , [ 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk' ]) with sdk . aensUpdate ( 'test.chain' , { account_pubkey : 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk' }) Additionally, getDefaultPointerKey (was named classify before) helper function can be used import { getDefaultPointerKey } from '@aeternity/aepp-sdk' const address = 'ak_2519mBsgjJEVEFoRgno1ryDsn3BEaCZGRbXPEjThWYLX9MTpmk' sdk . aensUpdate ( 'test.chain' , { [ getDefaultPointerKey ( address )] : address })","title":"aensUpdate accepts pointers as object (f6b8999)"},{"location":"guides/migration/11.0.0/","text":"Migration to 11.0.0 This guide describes all breaking changes introduced with v11.0.0 . Changes to decodeEvents method Removed decodeEvents from contract ACI methods ( a84d781 ). rewrite cInstance . methods . emitEvents . decodeEvents ( log ) to cInstance . decodeEvents ( log ) Removed raw fields from the decodeEvents response ( 45bae5f ) use processed fields for the same. Renamed decoded events response field decoded to args old response // events emitted by contract calls are automatically decoded const tx = await contractInstance . methods . emitEvents ( 1337 , \"this message is not indexed\" ) console . log ( tx . decodedEvents ) /* [ { address: 'ct_6y3N9KqQb74QsvR9NrESyhWeLNiA9aJgJ7ua8CvsTuGot6uzh', data: 'cb_dGhpcyBtZXNzYWdlIGlzIG5vdCBpbmRleGVkdWmUpw==', topics: [ '101640830366340000167918459210098337687948756568954742276612796897811614700269', '39519965516565108473327470053407124751867067078530473195651550649472681599133' ], name: 'AnotherEvent', decoded: [ 'fUq2NesPXcYZ1CcqBcGC3StpdnQw3iVxMA3YSeCNAwfN4myQk', 'this message is not indexed' ] }, { address: 'ct_6y3N9KqQb74QsvR9NrESyhWeLNiA9aJgJ7ua8CvsTuGot6uzh', data: 'cb_Xfbg4g==', topics: [ '59505622142252318624300825714684802559980671551955787864303522023309554554980', 1337 ], name: 'FirstEvent', decoded: [ '1337' ] } ] */ new response // events emitted by contract calls are automatically decoded const tx = await contractInstance . methods . emitEvents ( 1337 , \"this message is not indexed\" ) console . log ( tx . decodedEvents ) /* [ { name: 'AnotherEvent', args: [ 'fUq2NesPXcYZ1CcqBcGC3StpdnQw3iVxMA3YSeCNAwfN4myQk', 'this message is not indexed' ], contract: { name: 'EventEmitter', address: 'ct_6y3N9KqQb74QsvR9NrESyhWeLNiA9aJgJ7ua8CvsTuGot6uzh' } }, { name: 'FirstEvent', args: [1337n], contract: { name: 'EventEmitter', address: 'ct_6y3N9KqQb74QsvR9NrESyhWeLNiA9aJgJ7ua8CvsTuGot6uzh' } } ] */ Removed allowUnsynced option of poll method ( 6baa15d ) Transaction poll method now checks if Tx is in the node pool ( 690db5b ) The default polling interval of 5000 is replaced by a method which calculates the default interval using expected mine rate and micro block cycle ( d9c6cf9 ) Following contract instance methods are dropped( #1368 ) topBlock use aeSdk.api.getTopHeader() instead contractCall replace await aeSdk.contractCall(identityContract, contractId, 'getArg', [42]) with (await aeSdk.getContractInstance({ source, contractAddress: contractId })).methods.getArg(42) contractCompile replace await aeSdk.contractCompile(CONTRACT_SOURCE) with (await aeSdk.getContractInstance({ source: CONTRACT_SOURCE })).compile() contractDeploy replace await aeSdk.contractDeploy(bytecode, identityContract) with (await aeSdk.getContractInstance({ bytecode, source: identityContract })).deploy() contractCallStatic replace await aeSdk.contractCallStatic(identityContract, null, 'init', [], { bytecode }) with await contract.deploy([], { callStatic: true }) Removed property createdAt from contract.deploy method response call/callStatic removed call and callStatic methods from deploy response rewrite deployed = await contract . deploy ([], { onAccount }) await deployed . call ( 'getArg' , [ 42 ]) await deployed . callStatic ( 'getArg' , [ 42 ]) to await contract . deploy () await contract . methods . getArg ( 42 , { callStatic : false }) await contract . methods . getArg ( 42 , { callStatic : true }) The default gas of 25000 limit has been dropped. Instead, SDK attempts to estimate the gas using dry-run feature ( #1367 ) See documentation on transaction-options.md for detailed explanation. Removed Wrappers around CompilerApi ( #1363 ) Removed getBytecodeCompilerVersion method. Removed encodeCall method from contractCompile response. Removed getCompilerVersion method, use aeSdk. sdk.compilerVersion instead. Removed contractDecodeCallDataByCodeAPI method. Removed contractDecodeCallResultAPI method. Removed getFateAssembler method. Removed compileContractAPI method. rewrite const code = await aeSdk . compileContractAPI ( identityContract ) const callData = await aeSdk . contractEncodeCallDataAPI ( identityContract , 'init' , []) const result = await initiatorCh . createContract ({ code , callData , deposit : 1000 , vmVersion : 5 , abiVersion : 3 , amount , gas , gasPrice , }) to contract = await aeSdk . getContractInstance ({ source : contractSource }) await contract . compile () const result = await aeSdk . createContract ({ code : contract . bytecode , callData : contract . calldata . encode ( 'Identity' , 'init' , []), deposit : 1000 , vmVersion : 5 , abiVersion : 3 , amount , gas , gasPrice , }) //or bytecode = ( await aeSdk . compilerApi . compileContract ({ code : contractSource })). bytecode Removed contractEncodeCallDataAPI : rewrite await aeSdk . contractEncodeCallDataAPI ( contractSource , 'getArg' , [ '42' ]) to contract = await aeSdkInitiator . getContractInstance ({ source : contractSource }) await contract . compile () contract . calldata . encode ( 'Identity' , 'getArg' , [ 42 ]) Removed contractGetACI : rewrite const aci = await aeSdk . contractGetACI ( contractSource ) to const aci = await aeSdk . compilerApi . generateACI ({ code : contractSource }) Removed validateByteCodeAPI : rewrite aeSdk . validateByteCodeAPI ( bytecode , identityContract ) to await aeSdk . compilerApi . validateByteCode ({ bytecode , source : identityContract }) Native build of claim tx now accepts unencoded name instead of encoded name ( eea92be ) rewrite const name = 'test123test.chain' const nameHash = `nm_ ${ encodeBase58Check ( Buffer . from ( name )) } ` const params = { accountId : senderId , nonce , name : nameHash , nameSalt : _salt , nameFee } const txFromAPI = await aeSdk . nameClaimTx ( params ) to const name = 'test123test.chain' const params = { accountId : senderId , nonce , name , nameSalt : _salt , nameFee } const txFromAPI = await aeSdk . nameClaimTx ( params ) Removed forceValidation flag from aepp-rpc and wallet-rpc stamps. ( 9f958c3 ) Renamed hd-wallet methods ( f6243ad ) Renamed generateSaveHDWallet to generateSaveHDWalletFromSeed Renamed getHdWalletAccountFromMnemonic to getHdWalletAccountFromSeed","title":"Migration to 11.0.0"},{"location":"guides/migration/11.0.0/#migration-to-1100","text":"This guide describes all breaking changes introduced with v11.0.0 .","title":"Migration to 11.0.0"},{"location":"guides/migration/11.0.0/#changes-to-decodeevents-method","text":"Removed decodeEvents from contract ACI methods ( a84d781 ). rewrite cInstance . methods . emitEvents . decodeEvents ( log ) to cInstance . decodeEvents ( log ) Removed raw fields from the decodeEvents response ( 45bae5f ) use processed fields for the same. Renamed decoded events response field decoded to args old response // events emitted by contract calls are automatically decoded const tx = await contractInstance . methods . emitEvents ( 1337 , \"this message is not indexed\" ) console . log ( tx . decodedEvents ) /* [ { address: 'ct_6y3N9KqQb74QsvR9NrESyhWeLNiA9aJgJ7ua8CvsTuGot6uzh', data: 'cb_dGhpcyBtZXNzYWdlIGlzIG5vdCBpbmRleGVkdWmUpw==', topics: [ '101640830366340000167918459210098337687948756568954742276612796897811614700269', '39519965516565108473327470053407124751867067078530473195651550649472681599133' ], name: 'AnotherEvent', decoded: [ 'fUq2NesPXcYZ1CcqBcGC3StpdnQw3iVxMA3YSeCNAwfN4myQk', 'this message is not indexed' ] }, { address: 'ct_6y3N9KqQb74QsvR9NrESyhWeLNiA9aJgJ7ua8CvsTuGot6uzh', data: 'cb_Xfbg4g==', topics: [ '59505622142252318624300825714684802559980671551955787864303522023309554554980', 1337 ], name: 'FirstEvent', decoded: [ '1337' ] } ] */ new response // events emitted by contract calls are automatically decoded const tx = await contractInstance . methods . emitEvents ( 1337 , \"this message is not indexed\" ) console . log ( tx . decodedEvents ) /* [ { name: 'AnotherEvent', args: [ 'fUq2NesPXcYZ1CcqBcGC3StpdnQw3iVxMA3YSeCNAwfN4myQk', 'this message is not indexed' ], contract: { name: 'EventEmitter', address: 'ct_6y3N9KqQb74QsvR9NrESyhWeLNiA9aJgJ7ua8CvsTuGot6uzh' } }, { name: 'FirstEvent', args: [1337n], contract: { name: 'EventEmitter', address: 'ct_6y3N9KqQb74QsvR9NrESyhWeLNiA9aJgJ7ua8CvsTuGot6uzh' } } ] */","title":"Changes to decodeEvents method"},{"location":"guides/migration/11.0.0/#removed-allowunsynced-option-of-poll-method-6baa15d","text":"","title":"Removed allowUnsynced option of poll method (6baa15d)"},{"location":"guides/migration/11.0.0/#transaction-poll-method-now-checks-if-tx-is-in-the-node-pool-690db5b","text":"","title":"Transaction poll method now checks if Tx is in the node pool (690db5b)"},{"location":"guides/migration/11.0.0/#the-default-polling-interval-of-5000-is-replaced-by-a-method-which-calculates-the-default-interval-using-expected-mine-rate-and-micro-block-cycle-d9c6cf9","text":"","title":"The default polling interval of 5000 is replaced by a method which calculates the default interval using expected mine rate and micro block cycle (d9c6cf9)"},{"location":"guides/migration/11.0.0/#following-contract-instance-methods-are-dropped1368","text":"topBlock use aeSdk.api.getTopHeader() instead contractCall replace await aeSdk.contractCall(identityContract, contractId, 'getArg', [42]) with (await aeSdk.getContractInstance({ source, contractAddress: contractId })).methods.getArg(42) contractCompile replace await aeSdk.contractCompile(CONTRACT_SOURCE) with (await aeSdk.getContractInstance({ source: CONTRACT_SOURCE })).compile() contractDeploy replace await aeSdk.contractDeploy(bytecode, identityContract) with (await aeSdk.getContractInstance({ bytecode, source: identityContract })).deploy() contractCallStatic replace await aeSdk.contractCallStatic(identityContract, null, 'init', [], { bytecode }) with await contract.deploy([], { callStatic: true }) Removed property createdAt from contract.deploy method response call/callStatic removed call and callStatic methods from deploy response rewrite deployed = await contract . deploy ([], { onAccount }) await deployed . call ( 'getArg' , [ 42 ]) await deployed . callStatic ( 'getArg' , [ 42 ]) to await contract . deploy () await contract . methods . getArg ( 42 , { callStatic : false }) await contract . methods . getArg ( 42 , { callStatic : true })","title":"Following contract instance methods are dropped(#1368)"},{"location":"guides/migration/11.0.0/#the-default-gas-of-25000-limit-has-been-dropped-instead-sdk-attempts-to-estimate-the-gas-using-dry-run-feature-1367","text":"See documentation on transaction-options.md for detailed explanation.","title":"The default gas of 25000 limit has been dropped. Instead, SDK attempts to estimate the gas using dry-run feature (#1367)"},{"location":"guides/migration/11.0.0/#removed-wrappers-around-compilerapi-1363","text":"Removed getBytecodeCompilerVersion method. Removed encodeCall method from contractCompile response. Removed getCompilerVersion method, use aeSdk. sdk.compilerVersion instead. Removed contractDecodeCallDataByCodeAPI method. Removed contractDecodeCallResultAPI method. Removed getFateAssembler method. Removed compileContractAPI method. rewrite const code = await aeSdk . compileContractAPI ( identityContract ) const callData = await aeSdk . contractEncodeCallDataAPI ( identityContract , 'init' , []) const result = await initiatorCh . createContract ({ code , callData , deposit : 1000 , vmVersion : 5 , abiVersion : 3 , amount , gas , gasPrice , }) to contract = await aeSdk . getContractInstance ({ source : contractSource }) await contract . compile () const result = await aeSdk . createContract ({ code : contract . bytecode , callData : contract . calldata . encode ( 'Identity' , 'init' , []), deposit : 1000 , vmVersion : 5 , abiVersion : 3 , amount , gas , gasPrice , }) //or bytecode = ( await aeSdk . compilerApi . compileContract ({ code : contractSource })). bytecode Removed contractEncodeCallDataAPI : rewrite await aeSdk . contractEncodeCallDataAPI ( contractSource , 'getArg' , [ '42' ]) to contract = await aeSdkInitiator . getContractInstance ({ source : contractSource }) await contract . compile () contract . calldata . encode ( 'Identity' , 'getArg' , [ 42 ]) Removed contractGetACI : rewrite const aci = await aeSdk . contractGetACI ( contractSource ) to const aci = await aeSdk . compilerApi . generateACI ({ code : contractSource }) Removed validateByteCodeAPI : rewrite aeSdk . validateByteCodeAPI ( bytecode , identityContract ) to await aeSdk . compilerApi . validateByteCode ({ bytecode , source : identityContract })","title":"Removed Wrappers around CompilerApi (#1363)"},{"location":"guides/migration/11.0.0/#native-build-of-claim-tx-now-accepts-unencoded-name-instead-of-encoded-name-eea92be","text":"rewrite const name = 'test123test.chain' const nameHash = `nm_ ${ encodeBase58Check ( Buffer . from ( name )) } ` const params = { accountId : senderId , nonce , name : nameHash , nameSalt : _salt , nameFee } const txFromAPI = await aeSdk . nameClaimTx ( params ) to const name = 'test123test.chain' const params = { accountId : senderId , nonce , name , nameSalt : _salt , nameFee } const txFromAPI = await aeSdk . nameClaimTx ( params )","title":"Native build of claim tx now accepts unencoded name instead of encoded name (eea92be)"},{"location":"guides/migration/11.0.0/#removed-forcevalidation-flag-from-aepp-rpc-and-wallet-rpc-stamps-9f958c3","text":"","title":"Removed forceValidation flag from aepp-rpc and wallet-rpc stamps. (9f958c3)"},{"location":"guides/migration/11.0.0/#renamed-hd-wallet-methods-f6243ad","text":"Renamed generateSaveHDWallet to generateSaveHDWalletFromSeed Renamed getHdWalletAccountFromMnemonic to getHdWalletAccountFromSeed","title":"Renamed hd-wallet methods (f6243ad)"},{"location":"guides/migration/7.0.0/","text":"Migration to 7.0.0 This guide describes the process of migrating to SDK version 7.0.0 Step 1 SDK will not accept url , internalUrl init arguments anymore: Before Universal ({ url , internalUrl }) After const nodeInstance = await Node ({ url , internalUrl }) Universal ({ nodes : [{ name : 'testnet' , instance : nodeInstance }] }) Step 2 Remove deprecated function setKeypair SDK will not accept keypair init argument anymore: Before Universal ({ keypair }) After Universal ({ accounts : [ MemoryAccount ({ keypair })] }) Step 3 Change all of AENS method's first argument from nameId to name Before const client = Universal ({ ... }) await client . aensUpdate ( 'cm_ad1wdsa...' , ...) await client . aensTransfer ( 'cm_ad1wdsa...' , ...) await client . aensRevoke ( 'cm_ad1wdsa...' , ...) After const client = Universal ({ ... }) await client . aensUpdate ( 'testname.chain' , ...) await client . aensTransfer ( 'testname.chain' , ...) await client . aensRevoke ( 'testname.chain' , ...) Other Breaking Changes Add new compiler methods to RPC communication (base-app update required) Drop compiler version to version >= 4.0.0 && version < 5.0.0 Change node compatibility range to node >= 5.0.0 && node < 6.0.0 Always verify transactions before sending them to the node (can be disabled using the option verify: false )","title":"Migration to 7.0.0"},{"location":"guides/migration/7.0.0/#migration-to-700","text":"This guide describes the process of migrating to SDK version 7.0.0","title":"Migration to 7.0.0"},{"location":"guides/migration/7.0.0/#step-1","text":"SDK will not accept url , internalUrl init arguments anymore:","title":"Step 1"},{"location":"guides/migration/7.0.0/#before","text":"Universal ({ url , internalUrl })","title":"Before"},{"location":"guides/migration/7.0.0/#after","text":"const nodeInstance = await Node ({ url , internalUrl }) Universal ({ nodes : [{ name : 'testnet' , instance : nodeInstance }] })","title":"After"},{"location":"guides/migration/7.0.0/#step-2","text":"Remove deprecated function setKeypair SDK will not accept keypair init argument anymore:","title":"Step 2"},{"location":"guides/migration/7.0.0/#before_1","text":"Universal ({ keypair })","title":"Before"},{"location":"guides/migration/7.0.0/#after_1","text":"Universal ({ accounts : [ MemoryAccount ({ keypair })] })","title":"After"},{"location":"guides/migration/7.0.0/#step-3","text":"Change all of AENS method's first argument from nameId to name","title":"Step 3"},{"location":"guides/migration/7.0.0/#before_2","text":"const client = Universal ({ ... }) await client . aensUpdate ( 'cm_ad1wdsa...' , ...) await client . aensTransfer ( 'cm_ad1wdsa...' , ...) await client . aensRevoke ( 'cm_ad1wdsa...' , ...)","title":"Before"},{"location":"guides/migration/7.0.0/#after_2","text":"const client = Universal ({ ... }) await client . aensUpdate ( 'testname.chain' , ...) await client . aensTransfer ( 'testname.chain' , ...) await client . aensRevoke ( 'testname.chain' , ...)","title":"After"},{"location":"guides/migration/7.0.0/#other-breaking-changes","text":"Add new compiler methods to RPC communication (base-app update required) Drop compiler version to version >= 4.0.0 && version < 5.0.0 Change node compatibility range to node >= 5.0.0 && node < 6.0.0 Always verify transactions before sending them to the node (can be disabled using the option verify: false )","title":"Other Breaking Changes"},{"location":"guides/migration/9.0.0/","text":"Migration to 9.0.0 This guide describes all breaking changes introduced with v9.0.0 . drop waitMined static method If you used it like const sdk = await Universal ({ ... }) sdk . waitMined ( false ) then you have to rewrite it using Stamp composition const sdk = await Universal . compose ({ deepProps : { Ae : { defaults : { waitMined : false } } } })({ ... }) or pass it to specific methods, like sdk . spend ( amount , receiver , { waitMined : false }) or even const sdk = await Universal ({ ... }) sdk . deepProps ({ Ae : { defaults : { waitMined : false } } }) drop assertedType , use decode instead If you used it like const payload = Crypto . decodeBase64Check ( Crypto . assertedType ( 'tx_...' , 'tx' )) then you have to rewrite it using decode method const payload = TxBuilderHelper . decode ( 'tx_...' , 'tx' ) validator: recursive validator, simplify schema Instead of TransactionValidator stamp use verifyTransaction function. The function accepts a transaction, and a Node instance for validation (instead of network id), it doesn't return an unpacked transaction anymore, just an array of errors. Each error contains a verbose message ( msg before), unique key (for easy comparison), checkedKeys array ( txKey before). Using node instead of networkId allows to ensure transaction validation, so warnings are errors now ( type field removed). SCHEMA doesn't contain validation schema anymore. This wasn't supposed to be used by external developers. simplify buildTxHash helper If you used buildHash like const hash = TxBuilderHelper . buildHash ( 'xx' , Buffer . from ([ 1 , 2 , 3 ]), { raw : true }) then use const hash = Crypto . hash ( Buffer . from ([ 1 , 2 , 3 ])) If you used it with a falsy raw then const hash = TxBuilderHelper . encode ( Crypto . hash ( Buffer . from ([ 1 , 2 , 3 ])), 'xx' ) buildTxHash don't have raw switch anymore, it returns th_ -encoded string in all cases, but it still accepts transactions as a string and as a buffer. enable verification in deep props instead of extra variable If you were passing verifyTx: false to sdk factory then use verify: false instead.","title":"Migration to 9.0.0"},{"location":"guides/migration/9.0.0/#migration-to-900","text":"This guide describes all breaking changes introduced with v9.0.0 .","title":"Migration to 9.0.0"},{"location":"guides/migration/9.0.0/#drop-waitmined-static-method","text":"If you used it like const sdk = await Universal ({ ... }) sdk . waitMined ( false ) then you have to rewrite it using Stamp composition const sdk = await Universal . compose ({ deepProps : { Ae : { defaults : { waitMined : false } } } })({ ... }) or pass it to specific methods, like sdk . spend ( amount , receiver , { waitMined : false }) or even const sdk = await Universal ({ ... }) sdk . deepProps ({ Ae : { defaults : { waitMined : false } } })","title":"drop waitMined static method"},{"location":"guides/migration/9.0.0/#drop-assertedtype-use-decode-instead","text":"If you used it like const payload = Crypto . decodeBase64Check ( Crypto . assertedType ( 'tx_...' , 'tx' )) then you have to rewrite it using decode method const payload = TxBuilderHelper . decode ( 'tx_...' , 'tx' )","title":"drop assertedType, use decode instead"},{"location":"guides/migration/9.0.0/#validator-recursive-validator-simplify-schema","text":"Instead of TransactionValidator stamp use verifyTransaction function. The function accepts a transaction, and a Node instance for validation (instead of network id), it doesn't return an unpacked transaction anymore, just an array of errors. Each error contains a verbose message ( msg before), unique key (for easy comparison), checkedKeys array ( txKey before). Using node instead of networkId allows to ensure transaction validation, so warnings are errors now ( type field removed). SCHEMA doesn't contain validation schema anymore. This wasn't supposed to be used by external developers.","title":"validator: recursive validator, simplify schema"},{"location":"guides/migration/9.0.0/#simplify-buildtxhash-helper","text":"If you used buildHash like const hash = TxBuilderHelper . buildHash ( 'xx' , Buffer . from ([ 1 , 2 , 3 ]), { raw : true }) then use const hash = Crypto . hash ( Buffer . from ([ 1 , 2 , 3 ])) If you used it with a falsy raw then const hash = TxBuilderHelper . encode ( Crypto . hash ( Buffer . from ([ 1 , 2 , 3 ])), 'xx' ) buildTxHash don't have raw switch anymore, it returns th_ -encoded string in all cases, but it still accepts transactions as a string and as a buffer.","title":"simplify buildTxHash helper"},{"location":"guides/migration/9.0.0/#enable-verification-in-deep-props-instead-of-extra-variable","text":"If you were passing verifyTx: false to sdk factory then use verify: false instead.","title":"enable verification in deep props instead of extra variable"},{"location":"tutorials/vuejs/helloworld-blockheight/","text":"Vue.js HelloWorld This tutorial shows you how to use the SDK in your Vue.js application. You will replace the content of the default HelloWorld component and display the current block height of the \u00e6ternity testnet. 1. Install Vue.js npm install -g @vue/cli 2. Create a new Vue.js project vue create my-project 3. Switch to the folder of your Vue.js project cd my-project 4. Install the SDK npm install @aeternity/aepp-sdk 5. Modify the HelloWorld component <!-- src / components / HelloWorld . vue --> < script > import { Universal , Node } from '@aeternity/aepp-sdk' export default { name : 'HelloWorld' , data () { return { msg : 'Loading latest block ...' } }, async mounted () { // Init required Node stamp const node = await Node ({ url : 'https://testnet.aeternity.io' }) // Init SDK instance with Universal stamp const aeSdk = await Universal ({ nodes : [{ name : 'test-net' , instance : node }], }) // Start using the SDK const height = await aeSdk . height () this . msg = 'Current Block: ' + height } } < /script> 6. Run the application npm run serve","title":"Vue.js HelloWorld"},{"location":"tutorials/vuejs/helloworld-blockheight/#vuejs-helloworld","text":"This tutorial shows you how to use the SDK in your Vue.js application. You will replace the content of the default HelloWorld component and display the current block height of the \u00e6ternity testnet.","title":"Vue.js HelloWorld"},{"location":"tutorials/vuejs/helloworld-blockheight/#1-install-vuejs","text":"npm install -g @vue/cli","title":"1. Install Vue.js"},{"location":"tutorials/vuejs/helloworld-blockheight/#2-create-a-new-vuejs-project","text":"vue create my-project","title":"2. Create a new Vue.js project"},{"location":"tutorials/vuejs/helloworld-blockheight/#3-switch-to-the-folder-of-your-vuejs-project","text":"cd my-project","title":"3. Switch to the folder of your Vue.js project"},{"location":"tutorials/vuejs/helloworld-blockheight/#4-install-the-sdk","text":"npm install @aeternity/aepp-sdk","title":"4. Install the SDK"},{"location":"tutorials/vuejs/helloworld-blockheight/#5-modify-the-helloworld-component","text":"<!-- src / components / HelloWorld . vue --> < script > import { Universal , Node } from '@aeternity/aepp-sdk' export default { name : 'HelloWorld' , data () { return { msg : 'Loading latest block ...' } }, async mounted () { // Init required Node stamp const node = await Node ({ url : 'https://testnet.aeternity.io' }) // Init SDK instance with Universal stamp const aeSdk = await Universal ({ nodes : [{ name : 'test-net' , instance : node }], }) // Start using the SDK const height = await aeSdk . height () this . msg = 'Current Block: ' + height } } < /script>","title":"5. Modify the HelloWorld component"},{"location":"tutorials/vuejs/helloworld-blockheight/#6-run-the-application","text":"npm run serve","title":"6. Run the application"}]}